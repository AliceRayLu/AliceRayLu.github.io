<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="算法复习框架"><meta name="keywords" content=""><meta name="author" content="A.R.L"><meta name="copyright" content="A.R.L"><title>算法复习框架 | A.R.L's Blog</title><link rel="shortcut icon" href="/bitbug_favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-283151977-1', 'auto');
ga('send', 'pageview');</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-MJTECTPJVQ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-MJTECTPJVQ');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="A.R.L's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-program-basic"><span class="toc-text"> 0 program basic</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E4%B8%87%E8%83%BD%E5%A4%B4"><span class="toc-text"> 0.1 万能头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86"><span class="toc-text"> 0.2 输入输出处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#021-%E8%BE%93%E5%87%BA%E4%BF%9D%E7%95%99%E5%B0%8F%E6%95%B0%E4%BD%8D%E6%95%B0"><span class="toc-text"> 0.2.1 输出保留小数位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#022-int-string%E4%BA%92%E8%BD%AC"><span class="toc-text"> 0.2.2 int string互转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#023-string%E6%93%8D%E4%BD%9C"><span class="toc-text"> 0.2.3 string操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03-stdsort%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95"><span class="toc-text"> 0.3 std::sort踩坑记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text"> 0.4 文件输入输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-java"><span class="toc-text"> 0.5 java</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#051-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text"> 0.5.1 输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#052-%E6%96%87%E4%BB%B6"><span class="toc-text"> 0.5.2 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0521-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-text"> 0.5.2.1 读取文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0522-%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-text"> 0.5.2.2 写入文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0523-junit%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83"><span class="toc-text"> 0.5.2.3 junit相关文件比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#053-string%E6%93%8D%E4%BD%9C"><span class="toc-text"> 0.5.3 string操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0531-string%E5%92%8Cint%E4%BA%92%E8%BD%AC"><span class="toc-text"> 0.5.3.1 string和int互转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0532"><span class="toc-text"> 0.5.3.2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#053-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text"> 0.5.3 常用数据结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-stl%E9%80%9F%E6%9F%A5"><span class="toc-text"> 1 STL速查</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%B8%B8%E7%94%A8stl%E6%93%8D%E4%BD%9C"><span class="toc-text"> 1.1 常用STL操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-vector"><span class="toc-text"> 1.2 vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-map"><span class="toc-text"> 1.3 map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-set"><span class="toc-text"> 1.4 set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-stack"><span class="toc-text"> 1.5 stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-queue"><span class="toc-text"> 1.6 queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#161-deque"><span class="toc-text"> 1.6.1 deque</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#162-priority_queue"><span class="toc-text"> 1.6.2 priority_queue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-pair"><span class="toc-text"> 1.7 pair</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text"> 2 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="toc-text"> 2.1 字符串哈希</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-manacher%E7%AE%97%E6%B3%95"><span class="toc-text"> 2.2 Manacher算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-kmp%E7%AE%97%E6%B3%95"><span class="toc-text"> 2.3 KMP算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-trie"><span class="toc-text"> 2.4 Trie</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%B8%B8%E7%94%A8%E7%BB%93%E6%9E%84"><span class="toc-text"> 3 常用结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E6%A0%88"><span class="toc-text"> 3.1 栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E9%98%9F%E5%88%97"><span class="toc-text"> 3.2 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#321-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-text"> 3.2.1 *单调队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86"><span class="toc-text"> 3.2.2 优先队列&#x2F;堆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text"> 3.3 哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mark34-%E5%B9%B6%E6%9F%A5%E9%9B%86mark"><span class="toc-text"> 3.4 并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#341-%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="toc-text"> 3.4.1 路径压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#342-%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6"><span class="toc-text"> 3.4.2 按秩合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E9%93%BE%E8%A1%A8"><span class="toc-text"> 3.5 链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E6%A0%91"><span class="toc-text"> 3.6 树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#361-bst"><span class="toc-text"> 3.6.1 BST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#362-bb-tree"><span class="toc-text"> 3.6.2 B&#x2F;B+ Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#363-balanced-tree"><span class="toc-text"> 3.6.3 Balanced Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#364-red-black-tree"><span class="toc-text"> 3.6.4 Red Black Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#365-lca"><span class="toc-text"> 3.6.5 LCA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3651-%E9%80%92%E5%BD%92"><span class="toc-text"> 3.6.5.1 递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3652-%E5%80%8D%E5%A2%9E"><span class="toc-text"> 3.6.5.2 倍增</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#366-%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="toc-text"> 3.6.6 最长路径&#x2F;树的直径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3661-%E4%B8%A4%E6%AC%A1bfs"><span class="toc-text"> 3.6.6.1 两次BFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3662-%E6%A0%91%E4%B8%8Adp"><span class="toc-text"> 3.6.6.2 树上DP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-text"> 3.7 *树状数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#371-%E4%B8%80%E7%BB%B4"><span class="toc-text"> 3.7.1 一维</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#372-%E4%BA%8C%E7%BB%B4"><span class="toc-text"> 3.7.2 二维</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-text"> 3.8 *线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-st%E8%A1%A8"><span class="toc-text"> 3.9 ST表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#310-%E5%88%86%E5%9D%97"><span class="toc-text"> 3.10 分块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%8A%80%E5%B7%A7"><span class="toc-text"> 4 技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mark41-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92mark"><span class="toc-text"> 4.1 动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#411-%E4%B8%80%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text"> 4.1.1 一维动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#412-%E4%BA%8C%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text"> 4.1.2 二维动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#413-%E5%88%86%E5%89%B2%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 4.1.3 分割类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#414-%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text"> 4.1.4 子序列与字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#415-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text"> 4.1.5 背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#416-%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text"> 4.1.6 状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#417-%E6%A0%91%E5%BD%A2dp"><span class="toc-text"> 4.1.7 树形dp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#418-%E5%8C%BA%E9%97%B4dp"><span class="toc-text"> 4.1.8 区间dp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#419-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp"><span class="toc-text"> 4.1.9 状态压缩dp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E8%B4%AA%E5%BF%83"><span class="toc-text"> 4.2 贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#421-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="toc-text"> 4.2.1 区间问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E5%A4%9A%E6%8C%87%E9%92%88%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text"> 4.3 多指针与滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#431-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text"> 4.3.1 双指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#432-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text"> 4.3.2 滑动窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-text"> 4.4 二分法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E6%8E%92%E5%BA%8F"><span class="toc-text"> 4.5 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#451-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text"> 4.5.1 归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#452-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text"> 4.5.2 快速排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mark46-%E6%90%9C%E7%B4%A2mark"><span class="toc-text"> 4.6 搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#461-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88bfs"><span class="toc-text"> 4.6.1 广度优先BFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#462-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88dfs"><span class="toc-text"> 4.6.2 深度优先DFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#463-%E5%85%B6%E4%BB%96%E6%90%9C%E7%B4%A2"><span class="toc-text"> 4.6.3 其他搜索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text"> 4.7 位运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="toc-text"> 4.8 前缀和与差分数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#481-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-text"> 4.8.1 前缀和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#482-%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="toc-text"> 4.8.2 差分数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#483-%E5%8C%BA%E9%97%B4%E6%B1%82%E5%80%BC%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-text"> 4.8.3 区间求值问题总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#484-%E5%89%8D%E5%90%8E%E7%BC%80%E5%88%86%E8%A7%A3"><span class="toc-text"> 4.8.4 前后缀分解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E5%9B%9E%E6%BA%AF"><span class="toc-text"> 4.9 回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#410-%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB"><span class="toc-text"> 4.10 曼哈顿距离</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%9B%BE%E8%AE%BA"><span class="toc-text"> 5 图论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-text"> 5.1 图的基本表示方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#511-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-text"> 5.1.1 邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#512-%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F"><span class="toc-text"> 5.1.2 链式前向星</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mark52-%E5%9B%BE%E9%81%8D%E5%8E%86mark"><span class="toc-text"> 5.2 图遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mark53-%E6%9C%80%E7%9F%AD%E8%B7%AFmark"><span class="toc-text"> 5.3 最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#521-floyd"><span class="toc-text"> 5.2.1 floyd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#522-dijkstra"><span class="toc-text"> 5.2.2 dijkstra</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5221-%E6%9C%B4%E7%B4%A0%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 5.2.2.1 朴素实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5222-%E5%A0%86%E4%BC%98%E5%8C%96"><span class="toc-text"> 5.2.2.2 堆优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#523-bellman-ford"><span class="toc-text"> 5.2.3 Bellman-Ford</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5231-%E6%9C%B4%E7%B4%A0%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 5.2.3.1 朴素实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5232-spfa"><span class="toc-text"> 5.2.3.2 spfa</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mark54-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91mark"><span class="toc-text"> 5.4 最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#541-kruskal%E7%AE%97%E6%B3%95"><span class="toc-text"> 5.4.1 Kruskal算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#542-prim%E7%AE%97%E6%B3%95"><span class="toc-text"> 5.4.2 Prim算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-text"> 5.5 二分图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="toc-text"> 5.6 网络流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%95%B0%E5%AD%A6"><span class="toc-text"> 6 数学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E5%B8%A6%E4%BD%99%E9%99%A4%E6%B3%95"><span class="toc-text"> 6.1 带余除法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#611-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="toc-text"> 6.1.1 最大公约数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mark612-%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8Bmark"><span class="toc-text"> 6.1.2 不定方程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E7%B4%A0%E6%95%B0%E8%B4%A8%E6%95%B0"><span class="toc-text"> 6.2 *素数&#x2F;质数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#621-%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3"><span class="toc-text"> 6.2.1 质因数分解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#622-%E7%B4%A0%E6%95%B0%E7%AD%9B"><span class="toc-text"> 6.2.2 素数筛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#623-%E5%88%A4%E6%96%AD%E8%B4%A8%E6%95%B0"><span class="toc-text"> 6.2.3 判断质数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83"><span class="toc-text"> 6.3 乘法逆元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#631-%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86"><span class="toc-text"> 6.3.1 费马小定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#632-%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8"><span class="toc-text"> 6.3.2 线性递推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#633-%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-text"> 6.3.3 快速幂</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97"><span class="toc-text"> 6.4 矩阵计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#641-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83"><span class="toc-text"> 6.4.1 高斯消元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#642-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95"><span class="toc-text"> 6.4.2 矩阵乘法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-%E7%BB%84%E5%90%88%E6%95%B0"><span class="toc-text"> 6.5 组合数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#651-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-text"> 6.5.1 杨辉三角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#652-%E7%BB%84%E5%90%88%E9%98%B6%E4%B9%98"><span class="toc-text"> 6.5.2 组合阶乘</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-%E9%9A%8F%E6%9C%BA"><span class="toc-text"> 6.6 随机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#661-java%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-text"> 6.6.1 java随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#662-c%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-text"> 6.6.2 c++随机数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-%E6%B1%82%E8%A7%A3%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="toc-text"> 6.7 求解平方根</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#671-%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-text"> 6.7.1 二分法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#672-%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-text"> 6.7.2 牛顿迭代法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68-%E5%9B%9E%E6%96%87%E6%95%B0%E5%AD%97"><span class="toc-text"> 6.8 回文数字</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">A.R.L</div><div class="author-info__description text-center">Nothing holds still.</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">28</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">14</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/pics/back1.jpg?raw=true)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">A.R.L's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">算法复习框架</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-01-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Knowledge/">Knowledge</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Knowledge/Algorithm/">Algorithm</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本文档总结了非ACMer应知应会基础算法cpp版本，不涉及算法详解，适合（保研机考/找实习）复习框架使用。</p>
<p>大部分资料来源与互联网各大佬的总结与整理，此处作为复习整合。此外非常感谢学长提供的算法模板手册！</p>
<blockquote>
<p>施工建设中……</p>
</blockquote>
<h1 id="0-program-basic"><a class="markdownIt-Anchor" href="#0-program-basic"></a> 0 program basic</h1>
<p>以下是<code>c++</code>语言基础部分参考复习</p>
<h2 id="01-万能头"><a class="markdownIt-Anchor" href="#01-万能头"></a> 0.1 万能头</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="02-输入输出处理"><a class="markdownIt-Anchor" href="#02-输入输出处理"></a> 0.2 输入输出处理</h2>
<ul>
<li><code>cin/cout</code></li>
<li><code>getline(cin, str, '\n')</code>：默认读入一行，可以更换截断字符<br />
读取不定行数：<code>while(getline(...))</code></li>
</ul>
<h3 id="021-输出保留小数位数"><a class="markdownIt-Anchor" href="#021-输出保留小数位数"></a> 0.2.1 输出保留小数位数</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a=<span class="number">46.21534</span>,b=<span class="number">1.20001</span>;</span><br><span class="line">cout.<span class="built_in">setf</span>(ios::fixed);    <span class="comment">// 打开fixed功能，功能和下一行的fixed功能一样，同时写没关系</span></span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; b &lt;&lt; endl;      <span class="comment">//输出结果为1.20</span></span><br><span class="line">cout.<span class="built_in">unsetf</span>(ios::fixed); <span class="comment">// 关闭fixed功能，如果不关闭会一直保持</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; b &lt;&lt; endl;   <span class="comment">//不含fixed，保持小数点前的位数，输出1.2</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; a &lt;&lt; endl;    <span class="comment">//46.215</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; a &lt;&lt; endl;  <span class="comment">//5e+001</span></span><br></pre></td></tr></table></figure>
<h3 id="022-int-string互转"><a class="markdownIt-Anchor" href="#022-int-string互转"></a> 0.2.2 int string互转</h3>
<p>【int-&gt;string】</p>
<ul>
<li><code>to_string(int)</code></li>
<li><code>ostringstream</code>：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ostringstream ss;</span><br><span class="line">ss &lt;&lt; num;</span><br><span class="line">cout &lt;&lt; ss.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>【string-&gt;int】</p>
<ul>
<li><code>istringstream</code></li>
<li><code>atoi(str)</code></li>
</ul>
<h3 id="023-string操作"><a class="markdownIt-Anchor" href="#023-string操作"></a> 0.2.3 string操作</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">s.<span class="built_in">insert</span>(pos,args); <span class="comment">// 在pos后插入</span></span><br><span class="line">s.<span class="built_in">erase</span>(pos,len); <span class="comment">// 删除pos开始的len个字符，如果没有len删除至末尾</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="03-stdsort踩坑记录"><a class="markdownIt-Anchor" href="#03-stdsort踩坑记录"></a> 0.3 std::sort踩坑记录</h2>
<p>在使用排序的过程中我们通常为了省时省力会选择使用c++库中提供的sort函数，重载compare来进行。众所周知sort底层原理是快速排序，但是实际上的情况不尽如此。</p>
<p>在使用sort排序一个大数组时，我碰到了如下问题：</p>
<blockquote>
<p>AddressSanitizer: heap-buffer-overflow on address 0x7f6fbd3a47e8</p>
</blockquote>
<p>网上查阅<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1877661">相关资料</a>得知，原来是因为compare重载时，两个数出现<code>==</code>的情况也返回了true，这就导致出现循环相等的情况。因此，在大数组排序时，出现相等元素一定不能cmp函数返回true。</p>
<h2 id="04-文件输入输出"><a class="markdownIt-Anchor" href="#04-文件输入输出"></a> 0.4 文件输入输出</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法打开文件：&quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(file, line)) &#123;</span><br><span class="line">        std::cout &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法打开文件：&quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string text = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    file &lt;&lt; text &lt;&lt; std::endl; <span class="comment">// 写入字符串</span></span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="function">std::fstream <span class="title">file</span><span class="params">(filename, std::ios::in | std::ios::out)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法打开文件：&quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入字符串</span></span><br><span class="line">    std::string text = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    file &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动到文件开头</span></span><br><span class="line">    file.<span class="built_in">seekg</span>(<span class="number">0</span>); <span class="comment">// 设置文件读指针位置到文件开头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取字符串</span></span><br><span class="line">    std::string readText;</span><br><span class="line">    std::<span class="built_in">getline</span>(file, readText);</span><br><span class="line">    std::cout &lt;&lt; readText &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="05-java"><a class="markdownIt-Anchor" href="#05-java"></a> 0.5 java</h2>
<p>从以下部分开始是java的基础处理部分</p>
<h3 id="051-输入输出"><a class="markdownIt-Anchor" href="#051-输入输出"></a> 0.5.1 输入输出</h3>
<p>使用scanner可以方便处理命令行输入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> sc.nextFloat();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(sc.hasNextLine())&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>System.out.print</code>或者<code>System.out.println</code>可以输出，输出格式规则和c语言<code>printf</code>相同。</p>
<h3 id="052-文件"><a class="markdownIt-Anchor" href="#052-文件"></a> 0.5.2 文件</h3>
<p><code>File</code>类相关的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">    file.createNewFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="0521-读取文件"><a class="markdownIt-Anchor" href="#0521-读取文件"></a> 0.5.2.1 读取文件</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Scanner</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(file,<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 防止出现中文乱码</span></span><br><span class="line"><span class="comment">// 然后就可以按照scanner的使用方式nextLine等方式使用</span></span><br><span class="line"><span class="keyword">while</span>(in.hasNextLine())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用bufferedReader</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bfReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line = bfReader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="0522-写入文件"><a class="markdownIt-Anchor" href="#0522-写入文件"></a> 0.5.2.2 写入文件</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用PrintWriter</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(file, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// 以下三种方式都是直接覆盖原文件</span></span><br><span class="line">pw.print(...);</span><br><span class="line">pw.append(...);</span><br><span class="line">pw.write(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用FileWriter</span></span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">bw.write(...);</span><br><span class="line">bw.close();</span><br><span class="line">fw.close(); </span><br><span class="line"><span class="comment">// 注意关闭顺序，一定要先关闭输出流再关闭文件，否则文件无法保存</span></span><br></pre></td></tr></table></figure>
<p>以上方法都会重写原文件，即覆盖原文件</p>
<p>【追加写入】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file,<span class="literal">true</span>);</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">osw.write(...);</span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">true</span>); <span class="comment">// 表示追加</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">bw.write(...);</span><br></pre></td></tr></table></figure>
<h4 id="0523-junit相关文件比较"><a class="markdownIt-Anchor" href="#0523-junit相关文件比较"></a> 0.5.2.3 junit相关文件比较</h4>
<h3 id="053-string操作"><a class="markdownIt-Anchor" href="#053-string操作"></a> 0.5.3 string操作</h3>
<h4 id="0531-string和int互转"><a class="markdownIt-Anchor" href="#0531-string和int互转"></a> 0.5.3.1 string和int互转</h4>
<p>string -&gt; int：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(s);</span><br></pre></td></tr></table></figure>
<p>int -&gt; string：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> Integer.toString(a);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(a);</span><br></pre></td></tr></table></figure>
<h4 id="0532"><a class="markdownIt-Anchor" href="#0532"></a> 0.5.3.2</h4>
<h3 id="053-常用数据结构"><a class="markdownIt-Anchor" href="#053-常用数据结构"></a> 0.5.3 常用数据结构</h3>
<h1 id="1-stl速查"><a class="markdownIt-Anchor" href="#1-stl速查"></a> 1 STL速查</h1>
<h2 id="11-常用stl操作"><a class="markdownIt-Anchor" href="#11-常用stl操作"></a> 1.1 常用STL操作</h2>
<ul>
<li><code>reverse(container.begin(), container.end())</code>：反转</li>
<li><code>sort(container.begin(), container.end(), bool cmp)</code>：排序</li>
<li><code>unique(container.begin(), container.end())</code>：先把容器排序，然后去重，返回去重后的结尾迭代器，可以通过<code>.erase()</code>删除结尾部分</li>
<li><code>shuffle(container.begin(), container.end())</code>：随机打乱元素（c++14 以前使用<code>random_shuffle()</code>）</li>
<li><code>lower_bound(a.begin(), a.end(), x)</code>：找到第一个 &gt;= x的数，返回迭代器（找不到返回尾迭代器）【区别于<code>upper_bound</code>，upper返回第一个 &gt; x的数】可以用此迭代器减去<code>a.begin()</code>获取这个数的下标</li>
</ul>
<h2 id="12-vector"><a class="markdownIt-Anchor" href="#12-vector"></a> 1.2 vector</h2>
<ul>
<li>初始化  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(a)</span></span>; <span class="comment">// 将a复制一份为d</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">e</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br></pre></td></tr></table></figure>
</li>
<li><code>push_back</code>：在数组末尾插入，<code>emplace_back</code>更高效</li>
<li><code>pop_back</code>：在数组末尾删除</li>
</ul>
<h2 id="13-map"><a class="markdownIt-Anchor" href="#13-map"></a> 1.3 map</h2>
<p>映射，底层仍然是红黑树</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp；</span><br><span class="line">mp[x] = <span class="number">1</span>; <span class="comment">// 此种写法无论原来是否存在都会分配内存，使用find方法不会</span></span><br><span class="line">mp.<span class="built_in">find</span>(x); <span class="comment">// 返回迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [x,y] : mp)&#123;...&#125; <span class="comment">// c++17开始支持</span></span><br></pre></td></tr></table></figure>
<p>如果要使用hash table，应该使用unordered_map，使用方式与map相同</p>
<h2 id="14-set"><a class="markdownIt-Anchor" href="#14-set"></a> 1.4 set</h2>
<p>底层是红黑树</p>
<ul>
<li><code>insert</code>：插入元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
<li><code>lower_bound(x)</code>：二分查找有序数列，返回大于等于x的最大值（迭代器iterator）</li>
<li><code>erase(x)</code>：删除迭代器对应的元素，如果x是迭代器 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，是元素则会先find后删除 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
<li><code>find(x)</code>：查找 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，返回迭代器</li>
<li><strong>遍历</strong>：使用迭代器</li>
</ul>
<p>multiset可以插入重复元素，使用erase时只删除一个元素，不会把重复的都删除</p>
<blockquote>
<p>利用有序的<code>set/map</code>可以自动实现插入自动排序，即将元素放置到对应位置，辅助<code>lower_bound</code>进行二分查找</p>
</blockquote>
<h2 id="15-stack"><a class="markdownIt-Anchor" href="#15-stack"></a> 1.5 stack</h2>
<ul>
<li><code>push(x)</code>：加入元素</li>
<li><code>pop()</code>：删去栈顶，返回值为void</li>
<li><code>top()</code>：返回栈顶元素</li>
</ul>
<h2 id="16-queue"><a class="markdownIt-Anchor" href="#16-queue"></a> 1.6 queue</h2>
<ul>
<li><code>push(x)</code></li>
<li><code>pop()</code></li>
<li><code>front()</code></li>
</ul>
<h3 id="161-deque"><a class="markdownIt-Anchor" href="#161-deque"></a> 1.6.1 deque</h3>
<p>同时操作头尾，双端队列</p>
<ul>
<li><code>push_back(x)</code>：队尾插入</li>
<li><code>pop_back()</code>：弹出队尾元素</li>
<li><code>push_front(x)</code>：队首插入</li>
<li><code>pop_front()</code>：弹出队首元素</li>
</ul>
<h3 id="162-priority_queue"><a class="markdownIt-Anchor" href="#162-priority_queue"></a> 1.6.2 priority_queue</h3>
<p>通常作为堆使用</p>
<ul>
<li>初始化  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q; <span class="comment">// 默认大根堆（最大堆）</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q; <span class="comment">//使用vector作为底层容器，小根堆</span></span><br></pre></td></tr></table></figure>
</li>
<li><code>top()</code>：访问堆顶元素</li>
<li><code>push(x)</code></li>
<li><code>pop()</code></li>
</ul>
<h2 id="17-pair"><a class="markdownIt-Anchor" href="#17-pair"></a> 1.7 pair</h2>
<p>使用first/second来访问元素</p>
<h1 id="2-字符串"><a class="markdownIt-Anchor" href="#2-字符串"></a> 2 字符串</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串基本操作</span></span><br><span class="line">string s;</span><br><span class="line">s += <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s1 &lt; s2) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">c_str</span>(); <span class="comment">// 将string转化为c风格字符串，返回头指针</span></span><br><span class="line"><span class="type">char</span>[] c_str_ptr;</span><br><span class="line">s = c_str_ptr; <span class="comment">// 直接将char[]转换成string</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">substr</span>(pos,len); <span class="comment">// 截取下标开始处的len长度字串，不写len默认取到结尾</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stoi</span>(s); <span class="comment">// 将字符串表示的数字直接转换为int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>【int与string互转】</p>
<ul>
<li>int转string<br />
c++11中的新特性<code>to_string()</code>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++11</span></span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">long</span> <span class="type">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">unsigned</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">float</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">double</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">long</span> <span class="type">double</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>string转int：使用<code>istringstream</code></li>
</ul>
<h2 id="21-字符串哈希"><a class="markdownIt-Anchor" href="#21-字符串哈希"></a> 2.1 字符串哈希</h2>
<p>基本思想：将字符串通过哈希函数转化为int值，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>s</mi><mi>i</mi></msub><msup><mi>b</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">hash(s) = \Sigma_{i=0}^{n-1} s_i b^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.131103em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></p>
<p>注意点：b是大素数，计算出来的和（很大）需要取模</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B = <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_hash</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        res = (i64)(res*B + s[i]) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> string&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_hash</span>(s) == <span class="built_in">get_hash</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码来自oi-wiki，<code>i64</code>表示<code>int64_t</code>，即c++中的64位带符号整数（头文件写法：<code>using i64 = int64_t;</code>）</p>
</blockquote>
<p>【例题】<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-dna-sequences/description/">leetcode 187.Repeated DNA Sequences</a></p>
<h2 id="22-manacher算法"><a class="markdownIt-Anchor" href="#22-manacher算法"></a> 2.2 Manacher算法</h2>
<p>用于求解字符串中的最大回文串。“abcdsdc&quot;在字符串中加入占位符和开始结束符号，”$#a#b#c#d#s#d#c#^&quot;，然后遍历回文串可能的中心位置c，记录该中心位置对应的最大回文半径r</p>
<p>当中心从c移到i的时候，如果i &lt; r，那么当前i的回文半径至少是r-i和关于c对称的位置回文半径r[2c-i]中的最小值，需要根据i周围情况做进一步调整。如果i &gt; r，那就要从1开始扩展。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">manacher</span><span class="params">(string&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回中心半径数组</span></span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//构造扩充后的字符串</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">expand</span><span class="params">(n+n+<span class="number">1</span>+<span class="number">2</span>)</span></span>;</span><br><span class="line">    expand[<span class="number">0</span>] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    expand[<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        expand[i+i+<span class="number">2</span>] = s[i];</span><br><span class="line">        expand[i+i+<span class="number">3</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    expand[n+n+<span class="number">2</span>] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n+n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">//第一个位置空着不用，从1开始；最后一个位置也不用半径</span></span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; n+n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        p[i] = (i &lt; r)? <span class="built_in">min</span>(r-i,p[c+c-i]):<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(expand[i+p[i]] == expand[i-p[i]])++p[i];</span><br><span class="line">        <span class="keyword">if</span>(i+p[i] &gt; r)&#123;</span><br><span class="line">            c = i;</span><br><span class="line">            r = i+p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算最长回文子串时，需要注意半径中包含<code>#</code>占位符，计算长度和起始位置时需要一些转换。可以参考以下例题的实际代码。</p>
<p>【例题】<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/description/">leetcode 5.Longest Palindromic Substring</a></p>
<h2 id="23-kmp算法"><a class="markdownIt-Anchor" href="#23-kmp算法"></a> 2.3 KMP算法</h2>
<p>不重复匹配已经匹配过的相同前缀</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">(string a, string b, vector&lt;<span class="type">int</span>&gt;&amp; next)</span></span>&#123;</span><br><span class="line">    <span class="comment">//在a中匹配b，n和m分别表示a和b的长度，next数组维护公共前缀</span></span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">length</span>(),m = b.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">-1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; (j == m || a[i] != b[j+<span class="number">1</span>])) j = next[j];</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j+<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == m<span class="number">-1</span>) <span class="comment">// a[i-m+1:i]是b在a中第一次出现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNext</span><span class="params">(string b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m = b.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m+<span class="number">1</span>)</span></span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; b[i] != b[j+<span class="number">1</span>]) j = next[j]; <span class="comment">// 如果下一位不同，往前回溯</span></span><br><span class="line">        <span class="keyword">if</span>(b[i] == b[j+<span class="number">1</span>]) ++j; <span class="comment">// 下一位相同，更新最大前缀</span></span><br><span class="line">        next[i] = j; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例题】<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">leetcode 28.Find the Index of the First Occurrence in a String</a></p>
<h2 id="24-trie"><a class="markdownIt-Anchor" href="#24-trie"></a> 2.4 Trie</h2>
<p>字典树</p>
<p>可以用链表传统树结构实现，也可以用数组的形式简易实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Trie&#123;</span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>, nodeCnt = <span class="number">1</span>, ch[N][<span class="number">26</span>]; <span class="comment">// 根节点从1开始编号</span></span><br><span class="line">    <span class="type">bool</span> flag[N]; <span class="comment">// flag表示第x个节点是否为一个字符串结尾</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!ch[cur][s[i]-<span class="string">&#x27;a&#x27;</span>]) ch[cur][s[i]-<span class="string">&#x27;a&#x27;</span>] = ++nodeCnt;</span><br><span class="line">            cur = ch[cur][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        flag[cur] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cur = ch[cur][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">return</span> flag[cur];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例题】<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/">leetcode 208.Implement Trie Prefix Tree</a></p>
<h1 id="3-常用结构"><a class="markdownIt-Anchor" href="#3-常用结构"></a> 3 常用结构</h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/mOr1u6/">数据结构题单</a></p>
<h2 id="31-栈"><a class="markdownIt-Anchor" href="#31-栈"></a> 3.1 栈</h2>
<blockquote>
<p>First in, Last out.</p>
</blockquote>
<p>STL提供<code>stack&lt;T&gt;</code>，也可以用数组简单实现</p>
<p>经典例题：括号匹配问题 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/description/">leetcode 20.Valid Parentheses</a></p>
<p>【*单调栈】栈中元素保持单调递增性或递减性，例题请查看<a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/9oZFK9/">单调栈题单</a></p>
<p>【例题】</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/description/">leetcode 739.Daily Temperatures</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/description/">leetcode 503.Next Greater Element II</a></li>
</ul>
<h2 id="32-队列"><a class="markdownIt-Anchor" href="#32-队列"></a> 3.2 队列</h2>
<blockquote>
<p>First in, First out.</p>
</blockquote>
<p>STL提供<code>queue&lt;T&gt;</code>，详见1.6节</p>
<p>【经典应用】广度优先搜索BFS（见4.6.1节）</p>
<h3 id="321-单调队列"><a class="markdownIt-Anchor" href="#321-单调队列"></a> 3.2.1 *单调队列</h3>
<p>类似于单调栈，队列中元素保持单调性，通常用于滑动窗口问题。一般多用双端队列<code>deque</code>实现，但是deque常数较大，可以用数组替代。<br />
通常用于<strong>滑动窗口</strong>问题。</p>
<p>【例题】<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">leetcode 239.Sliding Window Maximum</a></p>
<h3 id="322-优先队列堆"><a class="markdownIt-Anchor" href="#322-优先队列堆"></a> 3.2.2 优先队列/堆</h3>
<p>优先队列使用堆实现，STL提供<code>priority_queue</code>（见1.6.2节）</p>
<p>使用数组实现堆（大根堆），元素从1开始</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> heap[<span class="number">1</span>];&#125; <span class="comment">// 返回最值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> k)</span></span>&#123; <span class="comment">// 插入元素</span></span><br><span class="line">    heap.<span class="built_in">push_back</span>(k);</span><br><span class="line">    <span class="built_in">swim</span>(heap.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    heap[<span class="number">0</span>] = heap[heap.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    heap.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">sink</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swim</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123; <span class="comment">// 上浮，用于push情况</span></span><br><span class="line">    <span class="keyword">while</span>(pos &gt; <span class="number">1</span> &amp;&amp; heap[pos/<span class="number">2</span>] &lt; heap[pos])&#123;</span><br><span class="line">        <span class="type">int</span> tmp = heap[pos/<span class="number">2</span>];</span><br><span class="line">        heap[pos/<span class="number">2</span>] = heap[pos];</span><br><span class="line">        heap[pos] = tmp;</span><br><span class="line">        pos = pos/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sink</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123; <span class="comment">// 下沉，用于删除后情况</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span>*pos &lt; heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">2</span>*pos;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &lt; heap.<span class="built_in">size</span>() &amp;&amp; heap[i+<span class="number">1</span>] &gt; heap[i])++i;</span><br><span class="line">        <span class="keyword">if</span>(heap[i] &gt; heap[pos])&#123;</span><br><span class="line">            <span class="type">int</span> tmp = heap[pos];</span><br><span class="line">            heap[pos] = heap[i];</span><br><span class="line">            heap[i] = tmp;</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典应用：求第k大的元素</p>
<p>【例题】<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/the-skyline-problem/description/">leetcode 218.The Skyline Problem</a></p>
<h2 id="33-哈希表"><a class="markdownIt-Anchor" href="#33-哈希表"></a> 3.3 哈希表</h2>
<p>STL提供<code>unordered_set</code>查找元素是否在集合中，用<code>unordered_map</code>存储键值对</p>
<p>【例题】<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/description/">leetcode 128.Longest Consecutive Sequence</a></p>
<blockquote>
<p>一个很妙的原地hash技巧，即利用数组下标的性质，将数组中元素变为<code>-</code>或者插入一个数位，保留原来数据的性质的同时也能标记其他数据，节省空间<br />
查看例题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-missing-positive/description/">leetcode 41.First Missing Positive</a></p>
</blockquote>
<h2 id="mark34-并查集mark"><a class="markdownIt-Anchor" href="#mark34-并查集mark"></a> <mark>3.4 并查集</mark></h2>
<p>基本思想：标记每一个节点的父节点</p>
<p>基本操作：</p>
<ul>
<li>查询根节点（get）</li>
<li>合并树（merge）</li>
</ul>
<p>并查集有两种优化方式，路径压缩和按秩合并</p>
<h3 id="341-路径压缩"><a class="markdownIt-Anchor" href="#341-路径压缩"></a> 3.4.1 路径压缩</h3>
<p>基本思想：每次get(x)后将x的根节点设置为查询到的节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> UFS&#123;</span><br><span class="line">    <span class="type">int</span> ufs[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span></span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) ufs[i] = i;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> ufs[x] == x ? x : ufs[x] = <span class="built_in">get</span>(ufs[x]);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">get</span>(x), fy = <span class="built_in">get</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(fx == fy) <span class="keyword">return</span>;</span><br><span class="line">        ufs[fx] = fy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="342-按秩合并"><a class="markdownIt-Anchor" href="#342-按秩合并"></a> 3.4.2 按秩合并</h3>
<p>按秩合并和路径压缩不能一起使用。</p>
<ul>
<li>按树的节点数量合并</li>
<li>按树的深度（秩）合并</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> UFS&#123;</span><br><span class="line">    <span class="type">int</span> ufs[N],rank[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            ufs[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> ufs[x] == x ? x : <span class="built_in">get</span>(ufs[x]);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">get</span>(x), fy = <span class="built_in">get</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(fx == fy) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[fx] &lt; rank[fy]) ufs[fx] = fy;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ufs[fy] = fx;</span><br><span class="line">            <span class="keyword">if</span>(rank[fx] == rank[fy]) rank[fx]++; <span class="comment">// 高度相同时合并树高要加1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例题】</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/redundant-connection/">leetcode 684.Redundant Connection</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/couples-holding-hands/">leetcode 765.Couples Holding Hands</a></li>
<li>带权并查集 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-division/description/">leetcode 399.Evaluate Division</a></li>
</ul>
<blockquote>
<p>leetcode标签：并查集</p>
</blockquote>
<h2 id="35-链表"><a class="markdownIt-Anchor" href="#35-链表"></a> 3.5 链表</h2>
<h2 id="36-树"><a class="markdownIt-Anchor" href="#36-树"></a> 3.6 树</h2>
<p>【遍历】</p>
<ul>
<li>前序</li>
<li>中序</li>
<li>后序</li>
<li>层次</li>
</ul>
<p>【完全二叉树】</p>
<p>只有叶子层可以有空节点，其他层必须拥有全部节点，且叶子层节点必须从左向右依次排列</p>
<p>【满二叉树】</p>
<p>所有节点如果不是叶子节点必须有两个子结点。</p>
<h3 id="361-bst"><a class="markdownIt-Anchor" href="#361-bst"></a> 3.6.1 BST</h3>
<h3 id="362-bb-tree"><a class="markdownIt-Anchor" href="#362-bb-tree"></a> 3.6.2 B/B+ Tree</h3>
<h3 id="363-balanced-tree"><a class="markdownIt-Anchor" href="#363-balanced-tree"></a> 3.6.3 Balanced Tree</h3>
<h3 id="364-red-black-tree"><a class="markdownIt-Anchor" href="#364-red-black-tree"></a> 3.6.4 Red Black Tree</h3>
<h3 id="365-lca"><a class="markdownIt-Anchor" href="#365-lca"></a> 3.6.5 LCA</h3>
<p>寻找lowest common ancester</p>
<h4 id="3651-递归"><a class="markdownIt-Anchor" href="#3651-递归"></a> 3.6.5.1 递归</h4>
<p>查看左右子树是否包含该节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lca</span><span class="params">(TreeNode* root,TreeNode* l,TreeNode* r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root || root == p || root == q)<span class="keyword">return</span> root;</span><br><span class="line">    TreeNode* left = <span class="built_in">lca</span>(root-&gt;left,p,q);</span><br><span class="line">    TreeNode* right = <span class="built_in">lca</span>(root-&gt;right,p,q);</span><br><span class="line">    <span class="keyword">if</span>(!left)<span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">if</span>(!right) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3652-倍增"><a class="markdownIt-Anchor" href="#3652-倍增"></a> 3.6.5.2 倍增</h4>
<h3 id="366-最长路径树的直径"><a class="markdownIt-Anchor" href="#366-最长路径树的直径"></a> 3.6.6 最长路径/树的直径</h3>
<h4 id="3661-两次bfs"><a class="markdownIt-Anchor" href="#3661-两次bfs"></a> 3.6.6.1 两次BFS</h4>
<ol>
<li>从任意节点p出发，利用广度优先/深度优先找到最长路径x的终点i</li>
<li>从i出发，找到最长路径y</li>
<li>y即树的最长路径</li>
</ol>
<p>任意节点出发寻找的最长路径终点一定是叶子节点，从叶子节点出发寻找的最长路径即为整棵树的最长路径</p>
<h4 id="3662-树上dp"><a class="markdownIt-Anchor" href="#3662-树上dp"></a> 3.6.6.2 树上DP</h4>
<p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>表示到x点最长的叶子节点的距离，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x) = dist(x,y)+f(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的子节点。</p>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y_1,y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的两个不一样的子节点（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>不在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>同一条子节点路上），那么可以把树的直径用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dist(x,y_1)+f(y_1)+dist(x,y_2)+f(y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>更新一下。通过dp可以遍历节点，相当于每次考虑经过一个节点最长路径。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> f[N],ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = head[x];j;j = e[j].nxt)&#123;</span><br><span class="line">        <span class="type">int</span> y = e[j].to;</span><br><span class="line">        <span class="built_in">dp</span>(y,x);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,f[x]+e[j].val+f[y]);</span><br><span class="line">        f[x] = <span class="built_in">max</span>(f[x],e[j].val+f[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="37-树状数组"><a class="markdownIt-Anchor" href="#37-树状数组"></a> 3.7 *树状数组</h2>
<h3 id="371-一维"><a class="markdownIt-Anchor" href="#371-一维"></a> 3.7.1 一维</h3>
<p>用来解决“单点修改，单点查询”，“单点修改，区间查询”，“区间查询，区间修改”这些问题，<a target="_blank" rel="noopener" href="https://blog.csdn.net/TheWayForDream/article/details/118436732">这篇博客</a>详细解释了树状数组的求和原理</p>
<p><strong>lowbit</strong>：数字最低为1位表示的数字大小（例如，<code>lowbit(1) = 1</code>，<code>lowbit(5) = 1</code>，<code>lowbit(6) = 2</code></p>
<p>树状数组中存储的元素，表示区间<code>[i-lowbit[i]+1,i]</code>的区间查询元素</p>
<p>单点修改，区间查询模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Bit&#123;</span><br><span class="line">    <span class="type">int</span> s[N];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; <span class="keyword">return</span> i &amp; (-i);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="comment">//下标为p的元素+v(单点修改)</span></span><br><span class="line">        <span class="keyword">for</span>(;p &lt;= n;p += <span class="built_in">lowbit</span>(p)) s[p] += v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 区间[0,p]的和</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;p &gt; <span class="number">0</span>;p -= <span class="built_in">lowbit</span>(p)) ret += s[p];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="comment">//查询区间[l,r]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(r)-<span class="built_in">query</span>(l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树状数组修改和查询的时间复杂度均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<blockquote>
<p>如何构建树状数组？<br />
使用前缀和之类的手段</p>
</blockquote>
<p>【例题】</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/description/">leetcode 307.Range Sum Query - Mutable</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">leetcode 315.Count Of Smaller Numbers After Self</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-2d-mutable/description/">二维树状数组：leetcode 308.Range Sum Query 2D - Mutable </a></li>
</ul>
<h3 id="372-二维"><a class="markdownIt-Anchor" href="#372-二维"></a> 3.7.2 二维</h3>
<h2 id="38-线段树"><a class="markdownIt-Anchor" href="#38-线段树"></a> 3.8 *线段树</h2>
<p>线段树适合用来解决“区间修改、区间查询”的问题。</p>
<p>将每一段区间按照叶节点记录子区间，父节点记录将子区间合并成一个大区间。修改区间时，针对该节点以下子节点的更新，使用lazy tag标记，访问时将tag下推。</p>
<ul>
<li>区间修改代码（区间和）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SegTree&#123;</span><br><span class="line">    <span class="type">int</span> s[N &lt;&lt; <span class="number">2</span>], t[N &lt;&lt; <span class="number">2</span>]; <span class="comment">//s数组用于存储线段树区间和，t数组用于记录tag</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> lc (p &lt;&lt; 1) <span class="comment">// left child at position [2*p]</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> rc (p &lt;&lt; 1 | 1) <span class="comment">// right child at position [2*p+1]</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> mid ((l+r) &gt;&gt; 1) <span class="comment">// 用于建树</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;s[p] = s[lc]+s[rc];&#125; <span class="comment">// 向上更新</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 使用tag向下更新</span></span><br><span class="line">        <span class="keyword">if</span>(!tag[p]) <span class="keyword">return</span>;</span><br><span class="line">        s[lc] += tag[p]*(mid-l+<span class="number">1</span>);tag[lc] += tag[p];</span><br><span class="line">        s[rc] += tag[p]*(r-mid);  tag[rc] += tag[p];</span><br><span class="line">        tag[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用递归技巧建树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            s[p] = a[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(lc,l,mid);</span><br><span class="line">        <span class="built_in">build</span>(rc,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改某个区间:[x,y]区域内的值+v</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= l &amp;&amp; y &gt;= r)&#123; <span class="comment">// 递归结束，找到包括的全部区间</span></span><br><span class="line">            s[p] += (r-l+<span class="number">1</span>)*v;</span><br><span class="line">            tag[p] += v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">down</span>(p,l,r);</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(lc,l,mid,x,y,v);</span><br><span class="line">        <span class="keyword">if</span>(y &gt; mid) <span class="built_in">modify</span>(rc,mid+<span class="number">1</span>,r,x,y,v);</span><br><span class="line">        <span class="built_in">up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某个区间内的值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= l &amp;&amp; y &gt;= r)&#123;</span><br><span class="line">            <span class="keyword">return</span> s[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">down</span>(p,l,r);</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) ret += <span class="built_in">query</span>(lc,l,mid,x,y);</span><br><span class="line">        <span class="keyword">if</span>(y &gt; mid) ret += <span class="built_in">query</span>(rc,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">        <span class="keyword">return</span> ret; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>单点修改  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        s[p] += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">down</span>(p,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(lc,l,mid,x,v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(rc,mid+<span class="number">1</span>,r,x,v);</span><br><span class="line">    <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>单点查询  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="keyword">return</span> s[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">down</span>(p,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(lc,l,mid,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(rc,mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>线段树的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<blockquote>
<p>如何修改模板以适应不同的问题</p>
</blockquote>
<ul>
<li>区间复合如何实现，即如何实现up函数</li>
<li>区间更新操作如何实现，即如何实现down和modify函数</li>
</ul>
<h2 id="39-st表"><a class="markdownIt-Anchor" href="#39-st表"></a> 3.9 ST表</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a1130683021/article/details/132729361">这篇博客</a>详细解释了ST表的原理。简单解释就是利用了区间可加性的思想，即区间[l,r]的性质可以由[l,s]和[s+1,r]两个区间的相同性质合并而来。例如：max(l,r) = max(max(l,s),max(s+1,r))</p>
<p>在ST表中，我们考察区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mi>j</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i,i+2^j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这个区间，可以发现这个区间可以由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i,i+2^{j-1}-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mi>j</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i+2^{j-1},i+2^j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.019104em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这两个区间，其中，每个子区间包含了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>个元素，总共区间有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>个元素</p>
<p>查询时，区间中有r-l+1个元素，因此取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><mo stretchy="false">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">s = \lfloor log_2(r-l+1) \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">⌋</span></span></span></span>，此时区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>l</mi><mo>+</mo><msup><mn>2</mn><mi>s</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,l+2^s-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>r</mi><mo>−</mo><msup><mn>2</mn><mi>s</mi></msup><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[r-2^s+1,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>可以交叉覆盖整个查询区间。</p>
<p>以下模板以求解区间最大值为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> st[N][M]; <span class="comment">// 数组一共有N个元素，M = log2(N)，可以根据题目范围适当开大一点</span></span><br><span class="line"><span class="type">int</span> log2_[N]; <span class="comment">// 预处理好求解log数组，c++log2库函数常数大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//建表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123; <span class="comment">// 数组从下标为1开始</span></span><br><span class="line">        st[i][<span class="number">0</span>] = a[i]; </span><br><span class="line">        log2_[i] = <span class="built_in">log2</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;(<span class="number">1</span> &lt;&lt; j) &lt;= n;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i+(<span class="number">1</span> &lt;&lt; j)<span class="number">-1</span> &lt;= n;i++)&#123;</span><br><span class="line">            st[i][j] = <span class="built_in">max</span>(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span> &lt;&lt; (j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询区间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = log2_[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(st[l][s],st[r-(<span class="number">1</span> &lt;&lt; s)+<span class="number">1</span>][s])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>区间问题的总结请查看4.8节前缀和与差分数组</p>
<h2 id="310-分块"><a class="markdownIt-Anchor" href="#310-分块"></a> 3.10 分块</h2>
<p>将数组分成几个区间，使用tag标记区间统一操作情况，不在区间中的零散数据直接暴力处理。</p>
<p>可以将区间内的数据进行排序以获得更高的性能。</p>
<p>一般来说还是优先考虑线段树等log数据结构</p>
<h1 id="4-技巧"><a class="markdownIt-Anchor" href="#4-技巧"></a> 4 技巧</h1>
<h2 id="mark41-动态规划mark"><a class="markdownIt-Anchor" href="#mark41-动态规划mark"></a> <mark>4.1 动态规划</mark></h2>
<p>原理：保存子问题的解避免重复计算</p>
<p>核心：找到状态转移方程</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/tXLS3i/">动态规划题单</a></p>
<h3 id="411-一维动态规划"><a class="markdownIt-Anchor" href="#411-一维动态规划"></a> 4.1.1 一维动态规划</h3>
<ul>
<li>
<p>爬楼梯问题：多种传递方式叠加</p>
</li>
<li>
<p>打家劫舍问题：有限制的叠加方式</p>
</li>
<li>
<p>不考虑顺序，即组合类问题：通过枚举可能的选项，固定顺序求解，具体例题请查看<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/description">coin change II</a></p>
</li>
</ul>
<h3 id="412-二维动态规划"><a class="markdownIt-Anchor" href="#412-二维动态规划"></a> 4.1.2 二维动态规划</h3>
<h3 id="413-分割类型"><a class="markdownIt-Anchor" href="#413-分割类型"></a> 4.1.3 分割类型</h3>
<h3 id="414-子序列与字符串"><a class="markdownIt-Anchor" href="#414-子序列与字符串"></a> 4.1.4 子序列与字符串</h3>
<ul>
<li>连续子序列：选定结尾枚举（有些题目可以考虑前缀和方法）</li>
<li>非连续型子序列：
<ul>
<li>【经典问题】最长公共子序列（见题单<strong>线性dp</strong>专题）</li>
<li>【经典问题】最长递增子序列</li>
</ul>
</li>
</ul>
<p>【最长公共子序列的并行计算问题】</p>
<p>所有的并行计算问题都可以使用<strong>拓扑排序</strong>的思想解决</p>
<h3 id="415-背包问题"><a class="markdownIt-Anchor" href="#415-背包问题"></a> 4.1.5 背包问题</h3>
<ul>
<li>0-1背包：每个物体只能选1次或0次，通过限制体积（或其他等价限制）来遍历</li>
<li>完全背包</li>
<li></li>
</ul>
<h3 id="416-状态机"><a class="markdownIt-Anchor" href="#416-状态机"></a> 4.1.6 状态机</h3>
<h3 id="417-树形dp"><a class="markdownIt-Anchor" href="#417-树形dp"></a> 4.1.7 树形dp</h3>
<h3 id="418-区间dp"><a class="markdownIt-Anchor" href="#418-区间dp"></a> 4.1.8 区间dp</h3>
<h3 id="419-状态压缩dp"><a class="markdownIt-Anchor" href="#419-状态压缩dp"></a> 4.1.9 状态压缩dp</h3>
<h2 id="42-贪心"><a class="markdownIt-Anchor" href="#42-贪心"></a> 4.2 贪心</h2>
<h3 id="421-区间问题"><a class="markdownIt-Anchor" href="#421-区间问题"></a> 4.2.1 区间问题</h3>
<h2 id="43-多指针与滑动窗口"><a class="markdownIt-Anchor" href="#43-多指针与滑动窗口"></a> 4.3 多指针与滑动窗口</h2>
<h3 id="431-双指针"><a class="markdownIt-Anchor" href="#431-双指针"></a> 4.3.1 双指针</h3>
<h3 id="432-滑动窗口"><a class="markdownIt-Anchor" href="#432-滑动窗口"></a> 4.3.2 滑动窗口</h3>
<h2 id="44-二分法"><a class="markdownIt-Anchor" href="#44-二分法"></a> 4.4 二分法</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/SqopEo/">二分题单</a></p>
<p>二分查找模板：</p>
<p>找到大于等于/大于/小于等于/小于：</p>
<h2 id="45-排序"><a class="markdownIt-Anchor" href="#45-排序"></a> 4.5 排序</h2>
<h3 id="451-归并排序"><a class="markdownIt-Anchor" href="#451-归并排序"></a> 4.5.1 归并排序</h3>
<p>divide &amp; conquer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> l,<span class="type">int</span> r,vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l+<span class="number">1</span> &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//divide</span></span><br><span class="line">    <span class="type">int</span> m = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">helper</span>(nums,l,m,temp);</span><br><span class="line">    <span class="built_in">helper</span>(nums,m,r,temp);</span><br><span class="line">    <span class="comment">//conquer</span></span><br><span class="line">    <span class="type">int</span> p = l,q = m,i = l;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; m || q &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q &gt;=r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q]))&#123;</span><br><span class="line">            temp[i++] = nums[p++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp[i++] = nums[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = l;i &lt; r;i++)&#123;</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="built_in">helper</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>(),temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例题】很精妙的运用<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/">LCR170. 交易的逆序对总数</a></p>
<h3 id="452-快速排序"><a class="markdownIt-Anchor" href="#452-快速排序"></a> 4.5.2 快速排序</h3>
<h2 id="mark46-搜索mark"><a class="markdownIt-Anchor" href="#mark46-搜索mark"></a> <mark>4.6 搜索</mark></h2>
<h3 id="461-广度优先bfs"><a class="markdownIt-Anchor" href="#461-广度优先bfs"></a> 4.6.1 广度优先BFS</h3>
<p>使用<strong>队列</strong>来存储每一层可以到达的节点</p>
<ul>
<li>树BFS：层次遍历</li>
<li>图BFS</li>
</ul>
<p>BFS可以较为容易的实现计算深度（层数/路径长度），但是难以记录路径</p>
<p>【例题】<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-bridge/description/">leetcode 934.Shortest Bridge</a></p>
<p>【专题】如何在BFS中找到最短路径（记录路径）</p>
<p>访问题目<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-ladder-ii/description/">leetcode 126.Word Ladder II</a></p>
<h3 id="462-深度优先dfs"><a class="markdownIt-Anchor" href="#462-深度优先dfs"></a> 4.6.2 深度优先DFS</h3>
<p>使用栈结构，不要忘记访问过的标记避免重复访问</p>
<p>【例题】</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-provinces/description/">leetcode 547.Friend Circles</a></li>
</ul>
<h3 id="463-其他搜索"><a class="markdownIt-Anchor" href="#463-其他搜索"></a> 4.6.3 其他搜索</h3>
<p>【例题】变形搜索<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/">leetcode 240.Search a 2D Matrix II</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/YiXPXW/">网格搜索专题题单</a></p>
<p>图上BFS/DFS搜索相关题单请查看图论部分总题单</p>
<h2 id="47-位运算"><a class="markdownIt-Anchor" href="#47-位运算"></a> 4.7 位运算</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/dHn9Vk/">位运算题单</a></p>
<p>【常见技巧】</p>
<ul>
<li><code>n&amp;(n-1)</code>：消去n最低位的1</li>
<li><code>n&amp;(-n)</code>：获取最低位的1的大小</li>
<li><code>reverse(lowbit(reverse(x)))</code>：获取最高位1，reverse是把进制位头尾颠倒</li>
</ul>
<p>【解题思想】</p>
<ul>
<li><code>and</code>参与运算的数越多，得到的结果越小；<code>or</code>参与运算的数越多，得到的结果越大</li>
<li><code>and/or</code>运算可以把参与运算的整数<strong>拆分</strong>为二进制32位，按照每一位考虑</li>
</ul>
<h2 id="48-前缀和与差分数组"><a class="markdownIt-Anchor" href="#48-前缀和与差分数组"></a> 4.8 前缀和与差分数组</h2>
<p>前缀是一个能解决很多问题的思想。</p>
<h3 id="481-前缀和"><a class="markdownIt-Anchor" href="#481-前缀和"></a> 4.8.1 前缀和</h3>
<p>对于任意一个数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_0,a_1,...,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>构造前缀和数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><msub><mi>b</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b_i = b_{i-1}+a_{i-1}, b_0 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，求解区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 的和可以用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>复杂度求出</p>
<h3 id="482-差分数组"><a class="markdownIt-Anchor" href="#482-差分数组"></a> 4.8.2 差分数组</h3>
<p>构造差分数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d_i = a_i-a_{i-1}, d_0 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，对区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>做相同操作时（如同时加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>l</mi></msub><mo>+</mo><mo>=</mo><mi>v</mi><mo separator="true">,</mo><msub><mi>d</mi><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><mo>=</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">v, d_l += v, d_{r+1} -= v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>）可以以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>复杂度实现。</p>
<p>【例题】<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/description/">leetcode 560.Subarray Sum Equals K</a></p>
<h3 id="483-区间求值问题总结"><a class="markdownIt-Anchor" href="#483-区间求值问题总结"></a> 4.8.3 区间求值问题总结</h3>
<blockquote>
<p>摘自<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/solutions/632515/guan-yu-ge-lei-qu-jian-he-wen-ti-ru-he-x-41hv">leetcode用户宫水三叶的总结</a></p>
</blockquote>
<ul>
<li>数组不变，求区间和：「前缀和」、「树状数组」、「线段树」</li>
<li>多次修改某个数，求区间和：「树状数组」、「线段树」</li>
<li>多次整体修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间的数据范围）</li>
<li>多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间的数据范围）</li>
</ul>
<p>总而言之，「线段树」的扩展性最佳，树状数组通常可以简化线段树。</p>
<h3 id="484-前后缀分解"><a class="markdownIt-Anchor" href="#484-前后缀分解"></a> 4.8.4 前后缀分解</h3>
<blockquote>
<p>摘自<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i/solutions/2493551/on-zuo-fa-mei-ju-numsjqian-hou-zhui-fen-xweo4/">leetcode用户灵茶山艾府的总结</a></p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">42.接雨水</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-average-difference/">2256.最小平均差</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/description/">1493.删掉一个元素以后全为 1 的最长子数组</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/">2909.元素和最小的山形三元组II</a></li>
</ul>
<ol start="1031">
<li>两个非重叠子数组的最大和 1680</li>
<li>三个无重叠子数组的最大和</li>
<li>找到所有好下标 1695</li>
<li>适合野炊的日子 1702</li>
<li>使字符串平衡的最少删除次数 1794</li>
<li>将字符串翻转到单调递增</li>
<li>找两个和为目标值且不重叠的子数组 1851</li>
<li>得到山形数组的最少删除次数 1913</li>
<li>除自身以外数组的乘积 ~2000</li>
<li>使二进制字符串字符交替的最少反转次数 2006</li>
<li>构造乘积矩阵 2075</li>
<li>移除所有载有违禁货物车厢所需的最少时间 2219</li>
<li>统计回文子序列数目 2223</li>
<li>删除元素后和的最小差值 2225</li>
<li>最少得分子序列 2432</li>
<li>统计上升四元组 2433</li>
<li>执行操作后的最大分割数量 3039</li>
<li>最大连续 1 的个数 II（会员题）</li>
<li>经过一次操作后的最大子数组和（会员题）</li>
</ol>
<h2 id="49-回溯"><a class="markdownIt-Anchor" href="#49-回溯"></a> 4.9 回溯</h2>
<h2 id="410-曼哈顿距离"><a class="markdownIt-Anchor" href="#410-曼哈顿距离"></a> 4.10 曼哈顿距离</h2>
<p>将坐标系顺时针旋转45°并拉伸为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span></span>倍，可以将两点之间的曼哈顿距离转换为在x’轴或者y’轴上的投影（即相对距离）。</p>
<p>坐标转换：(x,y) -&gt; (x+y,x-y)</p>
<h1 id="5-图论"><a class="markdownIt-Anchor" href="#5-图论"></a> 5 图论</h1>
<p>图论系列<a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/01LUak/">题单</a></p>
<h2 id="51-图的基本表示方法"><a class="markdownIt-Anchor" href="#51-图的基本表示方法"></a> 5.1 图的基本表示方法</h2>
<h3 id="511-邻接矩阵"><a class="markdownIt-Anchor" href="#511-邻接矩阵"></a> 5.1.1 邻接矩阵</h3>
<p>邻接矩阵适用于点比较少的情况，用一个二维数组存储相互连接的点之间的权值(<code>d[i][j] = v</code>)</p>
<h3 id="512-链式前向星"><a class="markdownIt-Anchor" href="#512-链式前向星"></a> 5.1.2 链式前向星</h3>
<p>采用与每个点相连的边链表形式存储。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tot, head[N]; <span class="comment">// tot表示当前边的下标（总数），head记录从这个点出发的所有边链表的头节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123; <span class="type">int</span> to, nxt, val;&#125; e[M]; <span class="comment">//每条边节点记录到的点，链表中下一项，以及边的权值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> to, <span class="type">int</span> from, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    e[++tot].to = to;</span><br><span class="line">    e[tot].val = val;</span><br><span class="line">    e[tot].nxt = head[from];</span><br><span class="line">    head[from] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visitEdge</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问从n出发的所有边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[n];i;i = e[i].nxt)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mark52-图遍历mark"><a class="markdownIt-Anchor" href="#mark52-图遍历mark"></a> <mark>5.2 图遍历</mark></h2>
<ul>
<li>DFS</li>
<li>BFS</li>
<li>拓扑排序</li>
</ul>
<h2 id="mark53-最短路mark"><a class="markdownIt-Anchor" href="#mark53-最短路mark"></a> <mark>5.3 最短路</mark></h2>
<h3 id="521-floyd"><a class="markdownIt-Anchor" href="#521-floyd"></a> 5.2.1 floyd</h3>
<p><strong>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></strong></p>
<p>floyd的思想是动态规划，可以视作经过k的i到j最短路径和不经过k的最短路径。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> f[N][N],d[N][N]; <span class="comment">// f存储最短路径，d存储邻接矩阵</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            f[i][j] = d[i][j]; <span class="comment">// 初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        f[i][i] = <span class="number">0</span>; <span class="comment">// 点到自己的距离是0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j],f[i][k]+f[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果i到j不存在路径，可以取无穷，为了防止溢出，可以设d[i][j] = 0x3f3f3f3f</p>
<p>向图中新加一条通路，则需要更新经过此条通路和不经过这条通路的最小路径</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">        f[i][j] = <span class="built_in">min</span>(f[i][j],f[i][x]+d[x][y]+f[y][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="522-dijkstra"><a class="markdownIt-Anchor" href="#522-dijkstra"></a> 5.2.2 dijkstra</h3>
<p>基本思想：S={u}，每次计算到S集合距离最近的点加入集合。（贪心）</p>
<h4 id="5221-朴素实现"><a class="markdownIt-Anchor" href="#5221-朴素实现"></a> 5.2.2.1 朴素实现</h4>
<p><strong>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) d[i] = inf;</span><br><span class="line">    d[u] = <span class="number">0</span>; <span class="comment">// 开始时集合中只有u这一个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123; <span class="comment">// 最多扩展n次（共有n个点）</span></span><br><span class="line">        <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(v == <span class="number">0</span> || d[v] &gt; d[j]) v = j;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = head[v];j;j = e[j].nxt)&#123;</span><br><span class="line">            <span class="type">int</span> w = e[j].to;</span><br><span class="line">            d[w] = <span class="built_in">min</span>(d[w],d[v]+e[j].val); <span class="comment">// 更新到当前w点的最小路径</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5222-堆优化"><a class="markdownIt-Anchor" href="#5222-堆优化"></a> 5.2.2.2 堆优化</h4>
<p>算法瓶颈在于求最小值</p>
<p>经过堆优化后的<strong>时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mlogm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></strong>，m表示边的数量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">int</span> d[N];<span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)d[i] = inf;</span><br><span class="line">    d[u] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pii&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="built_in">pii</span>(d[u],u));</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> w = pq.<span class="built_in">top</span>().second;pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!vis[w])&#123;</span><br><span class="line">            vis[w] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = head[w];j;j = e[j].nxt)&#123;</span><br><span class="line">                <span class="type">int</span> i = e[j].to;</span><br><span class="line">                <span class="keyword">if</span>(d[i] &gt; d[w]+e[j].val)&#123;</span><br><span class="line">                    d[i] = d[w]+e[j].val;</span><br><span class="line">                    pq.<span class="built_in">push</span>(<span class="built_in">pii</span>(-d[i],i)); <span class="comment">// 优先队列默认大根堆，通过取反间接实现小根堆</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="523-bellman-ford"><a class="markdownIt-Anchor" href="#523-bellman-ford"></a> 5.2.3 Bellman-Ford</h3>
<p>用于处理负权边，实现原理：用以下不等式更新dis</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">dis(y) &lt;= dis(x)+w 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></span></p>
<p>经过n轮迭代，可以保证就是最短路。如果n轮迭代后上述等式不成立（即还可以更新），表明图中存在负环。</p>
<p>该算法时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，n为点的数目，m为边的数目。这一时间复杂度是稳定的。</p>
<h4 id="5231-朴素实现"><a class="markdownIt-Anchor" href="#5231-朴素实现"></a> 5.2.3.1 朴素实现</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    d[i] = inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellmanFord</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    d[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">1</span>;r &lt;= n;r++)&#123; <span class="comment">// 最多n轮</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">1</span>;x &lt;= n;x++)&#123; <span class="comment">// 遍历当前与源相连的所有节点</span></span><br><span class="line">            <span class="keyword">if</span>(d[i] == inf)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = head[x];j;j = e[j].nxt)&#123;</span><br><span class="line">                <span class="type">int</span> to = e[j].to,val = e[j].val;</span><br><span class="line">                d[to] = <span class="built_in">min</span>(d[to],d[x]+val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5232-spfa"><a class="markdownIt-Anchor" href="#5232-spfa"></a> 5.2.3.2 spfa</h4>
<p>队列优化的BellmanFord算法：类似bfs的思想，只有x更新，与x相连的点才会发生更新，因此使用队列存储被更新过的节点，然后更新相连的节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    d[i] = inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> visited[N]; <span class="comment">// 是否在队列中</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(u);</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();visited[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = head[t];j;j = e[j].nxt)&#123;</span><br><span class="line">            <span class="type">int</span> to = e[j].to,val = e[j].val;</span><br><span class="line">            <span class="keyword">if</span>(d[to] &gt; d[t]+val)&#123;</span><br><span class="line">                d[to] = d[t]+val;</span><br><span class="line">                <span class="keyword">if</span>(!visited[to])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(to); </span><br><span class="line">                    visited[to] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mark54-最小生成树mark"><a class="markdownIt-Anchor" href="#mark54-最小生成树mark"></a> <mark>5.4 最小生成树</mark></h2>
<p>minimum spanning tree - MST</p>
<h3 id="541-kruskal算法"><a class="markdownIt-Anchor" href="#541-kruskal算法"></a> 5.4.1 Kruskal算法</h3>
<p>基于贪心的思想，每次向kruskcal加入没有联通的最小权值的边。时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mlogm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，主要瓶颈在于给边排序的时间复杂度。</p>
<p>使用<strong>并查集</strong>记录连通块。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> x,y,v;&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Edge&amp; e1,Edge&amp; e2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.v &lt; e2.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruscal</span><span class="params">(vector&lt;Edge&gt; edges)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(),edges.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(Edge e:edges)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(e.x) != <span class="built_in">get</span>(e.y))&#123; <span class="comment">// x，y不在同一个连通块内</span></span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="built_in">merge</span>(e.x,e.y);</span><br><span class="line">            sum += e.v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= n)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="542-prim算法"><a class="markdownIt-Anchor" href="#542-prim算法"></a> 5.4.2 Prim算法</h3>
<p>类似dijkstra算法，每次将到当前连通块中边最小的点加入联通集合。</p>
<p>算法复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，瓶颈主要在找最小值的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> vis[N]; <span class="comment">// 用于记录当前点是否加入生成树</span></span><br><span class="line"><span class="type">int</span> dis[N]; <span class="comment">// 类似dijkstra，记录未加入点到连通块的最小距离</span></span><br><span class="line"><span class="comment">// 使用链式前向星记录边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 把点1先加入连通块</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; dis[x])x = j; <span class="comment">// 找到最小边点</span></span><br><span class="line">        &#125;</span><br><span class="line">        vis[x] = <span class="literal">true</span>;</span><br><span class="line">        sum += dis[x];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = head[x];j;j = e[j].nxt)&#123;</span><br><span class="line">            <span class="type">int</span> y = e[j].to,val = e[j].v;</span><br><span class="line">            <span class="keyword">if</span>(!vis[y])&#123;</span><br><span class="line">                dis[y] = <span class="built_in">min</span>(dis[y],val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="55-二分图"><a class="markdownIt-Anchor" href="#55-二分图"></a> 5.5 二分图</h2>
<h2 id="56-网络流"><a class="markdownIt-Anchor" href="#56-网络流"></a> 5.6 网络流</h2>
<h1 id="6-数学"><a class="markdownIt-Anchor" href="#6-数学"></a> 6 数学</h1>
<h2 id="61-带余除法"><a class="markdownIt-Anchor" href="#61-带余除法"></a> 6.1 带余除法</h2>
<h3 id="611-最大公约数"><a class="markdownIt-Anchor" href="#611-最大公约数"></a> 6.1.1 最大公约数</h3>
<p>辗转相除法（欧几里得法）求解最大公约数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a,b) = gcd(a, b\space mod\space a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span></p>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 【证明：考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&gt;</mo><mfrac><mi>b</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">a&gt;\frac{b}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&lt;</mo><mfrac><mi>b</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">a&lt;\frac{b}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 两种情况，可以证明每次整除会导致规模缩小一半】</p>
<p>实现与使用：</p>
<ul>
<li>c++14：<code>__gcd(int,int)</code> （在<code>&lt;algorithm&gt;</code>库中）</li>
<li>c++17：<code>gcd(int,int)</code> （在<code>&lt;numeric&gt;</code>库中）</li>
</ul>
<p>【例题】<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/simplified-fractions/description/">leetcode 1447.Simplified Fractions</a></p>
<h3 id="mark612-不定方程mark"><a class="markdownIt-Anchor" href="#mark612-不定方程mark"></a> <mark>6.1.2 不定方程</mark></h3>
<p>【定义】未知数个数超过方程数量，典型例子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">ax+by=c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>为未知数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a,b,c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span></span></span></span>为参数</p>
<p>【裴蜀定理】<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>c</mi><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">ax+by=c \iff gcd(a,b)|c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟺</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord mathdefault">c</span></span></span></span></p>
<p>简单证明：假设$a&gt;b, a=b\cdot k+r $ ，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">ax+by=c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 可以写作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>k</mi><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>r</mi><mi>x</mi><mo>=</mo><mi>b</mi><msub><mi>x</mi><mn>0</mn></msub><mo>+</mo><mi>r</mi><msub><mi>y</mi><mn>0</mn></msub><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">b(y+kx)+rx = bx_0+ry_0 = c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span></p>
<p>在上述式子中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>可以写作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>b</mi></mrow><annotation encoding="application/x-tex">a\space mod \space b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">b</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>可以写作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mi>a</mi><mi>b</mi></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor\frac{a}{b}\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>（此处可利用c++中整数相除特性），因此<mark>扩展欧几里得算法</mark>可以写成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">extgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span>&amp; x,<span class="type">int</span>&amp; y)</span></span>&#123; <span class="comment">//此处默认c=gcd(a,b)</span></span><br><span class="line">    <span class="keyword">if</span>(!b)&#123; <span class="comment">// b=0, ax=c, a = gcd(a,b)</span></span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">extgcd</span>(b,a%b,x,y),x0 = x,y0 = y; <span class="comment">// a = a/b * b + r  </span></span><br><span class="line">    x = y0; <span class="comment">// r*x+b*(a/b*x + y) = c, x-&gt;y0</span></span><br><span class="line">    y = x0-(a/b)*y0; </span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例题】<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/water-and-jug-problem/description/">leetcode 365.Water And Jug Problem</a></p>
<h2 id="62-素数质数"><a class="markdownIt-Anchor" href="#62-素数质数"></a> 6.2 *素数/质数</h2>
<h3 id="621-质因数分解"><a class="markdownIt-Anchor" href="#621-质因数分解"></a> 6.2.1 质因数分解</h3>
<p>任何数都可以被写成唯一的质因数分解形式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msubsup><mi>p</mi><mi>i</mi><msub><mi>r</mi><mi>i</mi></msub></msubsup></mrow><annotation encoding="application/x-tex">\prod_{i=1}^k p_i^{r_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.746292em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.1449000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是质数。</p>
<p>推理可知，如果要对一个整数进行质因数分解，只需要枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><msqrt><mi>n</mi></msqrt><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,\sqrt{n}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">]</span></span></span></span>之间的素数（n最多只有一个大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>的质因数），时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msqrt><mi>n</mi></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;pii&gt; <span class="title">getPrimes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = n;</span><br><span class="line">    vector&lt;pii&gt; ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i*i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>( ;tmp%i==<span class="number">0</span>;tmp /= i)count++;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(<span class="built_in">pii</span>(i,count));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在大于根号n的质因数</span></span><br><span class="line">    <span class="keyword">if</span>(tmp != <span class="number">1</span>)&#123;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(<span class="built_in">pii</span>(tmp,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="622-素数筛"><a class="markdownIt-Anchor" href="#622-素数筛"></a> 6.2.2 素数筛</h3>
<ul>
<li><strong>埃氏筛</strong>：枚举过程中将质数的倍数标记置为合数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isPrime</span><span class="params">(n+<span class="number">1</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i+i;j &lt;= n;j+=i)&#123;</span><br><span class="line">                isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
埃氏筛的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nloglogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> ？</li>
<li><strong>欧拉筛</strong>：每个数被严格筛选一次，所以时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primeCnt = <span class="number">0</span>,primes[N];</span><br><span class="line"><span class="type">bool</span> notPrime[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> maxN)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= maxN;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!notPrime[i]) primes[++primeCnt] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= primeCnt &amp;&amp; i*primes[j] &lt;= maxN;j++)&#123;</span><br><span class="line">            notPrime[i*primes[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用合数与该合数的最小质因数构造新的合数，假设a是一个合数，a = p * b，b是合数。假设存在 a = p’ * c，c是另一个合数，不妨设c &gt; b（按照遍历次序），p’ &lt; p，p’和p互质，因此p’|b，即 b%p’== 0，退出循环，不可能再出现p。详细证明请参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qaqwqaqwq/article/details/123587336">这篇博客</a></li>
</ul>
<p>【例题】<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-primes/description/">leetcode 204.Count Primes</a></p>
<p>素数筛的进阶用法：筛选积性函数</p>
<h3 id="623-判断质数"><a class="markdownIt-Anchor" href="#623-判断质数"></a> 6.2.3 判断质数</h3>
<p>【法一】从2到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>遍历，查看是否能被整除</p>
<p>【法二】使用素数筛预处理范围内所有的素数</p>
<h2 id="63-乘法逆元"><a class="markdownIt-Anchor" href="#63-乘法逆元"></a> 6.3 乘法逆元</h2>
<p>乘法逆元：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="0.4444444444444444em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax \equiv 1 \pmod P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span>，x是模P意义下a的乘法逆元，等价于求解<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>P</mi><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ax + Py = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，转换为不定方程使用扩展欧几里得算法求解。因此有解要求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a,P) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<h3 id="631-费马小定理"><a class="markdownIt-Anchor" href="#631-费马小定理"></a> 6.3.1 费马小定理</h3>
<p>费马小定理：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>为质数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>P</mi></msup><mo>≡</mo><mi>a</mi><mspace></mspace><mspace width="0.4444444444444444em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^P \equiv a \pmod P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span></p>
<p>由费马小定理可以推出模P意义下a的乘法逆元特解是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>P</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{P-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<h3 id="632-线性递推"><a class="markdownIt-Anchor" href="#632-线性递推"></a> 6.3.2 线性递推</h3>
<p>线性递推关系可以求解[1,n]每个整数对于P的逆元</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>v</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mspace linebreak="newline"></mspace><mi>i</mi><mi>n</mi><mi>v</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mo stretchy="false">⌊</mo><mfrac><mi>P</mi><mi>n</mi></mfrac><mo stretchy="false">⌋</mo><mo>⋅</mo><mi>i</mi><mi>n</mi><mi>v</mi><mo stretchy="false">(</mo><mi>P</mi><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>n</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">    inv(1) = 1 \\
    inv(n) =  -\lfloor \frac{P}{n}\rfloor \cdot inv(P\bmod n) ,\space n \ge 2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord">−</span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></span></p>
<p>【总结】求解乘法逆元的方法</p>
<ul>
<li>扩展欧几里得算法</li>
<li>费马小定理+快速幂直接求解</li>
<li>线性递推</li>
</ul>
<p>这一部分的参考代码可以看<a target="_blank" rel="noopener" href="https://hwcoder.top/LeetCode-Math#%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83">这篇博客</a></p>
<h3 id="633-快速幂"><a class="markdownIt-Anchor" href="#633-快速幂"></a> 6.3.3 快速幂</h3>
<p>计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">a^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，传统做法是依次乘，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。根据二分法的思想，可以计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mn>2</mn></msup><mo>⋅</mo><msup><mi>a</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">a^2 \cdot a^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>将时间复杂度化为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>递归写法：注意乘方会导致int类型数据溢出，因此使用long long类型并取模</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> (<span class="built_in">qpow</span>(a, n<span class="number">-1</span>) * a) % MOD;</span><br><span class="line">    ll tmp = <span class="built_in">qpow</span>(a,n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> (tmp*tmp) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环写法：节省栈开销。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mn>1001</mn></msup></mrow><annotation encoding="application/x-tex">a^{1001}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>可以写成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mn>1000</mn></msup><mo>⋅</mo><msup><mi>a</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">a^{1000}\cdot a^{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>. 通过把指数转化为二进制进行计算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            ans *= a;</span><br><span class="line">        &#125;</span><br><span class="line">        a *= a;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="64-矩阵计算"><a class="markdownIt-Anchor" href="#64-矩阵计算"></a> 6.4 矩阵计算</h2>
<h3 id="641-高斯消元"><a class="markdownIt-Anchor" href="#641-高斯消元"></a> 6.4.1 高斯消元</h3>
<p>求解<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi><mo separator="true">,</mo><mi>A</mi><mo>∈</mo><msup><mi>R</mi><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow></msup><mo separator="true">,</mo><mi>x</mi><mo>∈</mo><msup><mi>R</mi><mrow><mi>m</mi><mo>×</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><msup><mi>R</mi><mrow><mi>n</mi><mo>×</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">Ax=b, A\in R^{n\times m}, x\in R^{m\times 1}, b\in R^{n\times 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9657709999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">×</span><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">×</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">×</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>基本思想：构造矩阵[A,b]</p>
<ol>
<li>从上往下消元 -&gt; 形成三角矩阵</li>
<li>从下往上消元 -&gt; 形成对角矩阵</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-7</span>;<span class="comment">// 精度值</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123; <span class="comment">// 矩阵从数组的第一行第一列开始</span></span><br><span class="line">        <span class="type">int</span> r = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i]) &gt; <span class="built_in">fabs</span>(a[r][i])) r = j; <span class="comment">// fabs用于计算浮点数的绝对值，找到该列绝对值最大的行，减少浮点计算误差</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[r][i]) &lt; eps)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不存在唯一解</span></span><br><span class="line">        <span class="keyword">if</span>(r != i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i;j &lt; n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[r][j],a[i][j]); <span class="comment">// 交换绝对值最大的值所在行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            <span class="type">double</span> tmp = a[j][i] / a[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i;k &lt;= n+<span class="number">1</span>;k++)a[j][k] -= tmp * a[i][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>; j &lt;= n;j++)a[i][n+<span class="number">1</span>] -= a[j][n+<span class="number">1</span>]*a[i][j];</span><br><span class="line">        a[i][n+<span class="number">1</span>] /= a[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="642-矩阵乘法"><a class="markdownIt-Anchor" href="#642-矩阵乘法"></a> 6.4.2 矩阵乘法</h3>
<p>可以用于处理一些递推关系，比如斐波那契数列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mi>n</mi></msub><mo>=</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">F_n = F_{n-1}+F_{n-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>F</mi><mi>n</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>×</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>F</mi><mi>n</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex"> \begin{bmatrix} F_{n-1} &amp; F_n \end{bmatrix} \times 
\begin{bmatrix} 0 &amp; 1 \\ 1 &amp; 1 \end{bmatrix} = 
\begin{bmatrix} F_n &amp; F_{n+1} \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span></span></span></span></span></p>
<p>【矩阵求幂】<strong>快速幂</strong>优化。下述模板只是矩阵乘法的实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    i64 v[n][m];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="built_in">sizeof</span>(v));&#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> *(<span class="type">const</span> Matrix&amp; x, <span class="type">const</span> Matrix&amp; y)&#123;</span><br><span class="line">        Matrix ret;</span><br><span class="line">        ret.n = x.n;ret.m = y.m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; ret.n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; ret.m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; x.m;x++)&#123;</span><br><span class="line">                    ret.v[i][j] += x.v[i][k]*y.v[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="65-组合数"><a class="markdownIt-Anchor" href="#65-组合数"></a> 6.5 组合数</h2>
<p>求解组合数可以通过递归和阶乘两种方式求解</p>
<h3 id="651-杨辉三角"><a class="markdownIt-Anchor" href="#651-杨辉三角"></a> 6.5.1 杨辉三角</h3>
<p>杨辉三角揭示了组合数的递归规律，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>i</mi><mi>j</mi></msubsup><mo>=</mo><msubsup><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mi>j</mi></msubsup><mo>+</mo><msubsup><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">C_i^j = C_{i-1}^j+C_{i-1}^{j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.219436em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.942572em;"><span style="top:-2.4231360000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2777669999999999em;vertical-align:-0.335195em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.942572em;"><span style="top:-2.423136em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.335195em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2777669999999999em;vertical-align:-0.335195em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.942572em;"><span style="top:-2.423136em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.335195em;"><span></span></span></span></span></span></span></span></span></span>。同时对于任意<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>≥</mo><mn>1</mn><mo separator="true">,</mo><msubsup><mi>C</mi><mi>i</mi><mn>0</mn></msubsup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i \ge 1, C_i^0 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.072772em;vertical-align:-0.258664em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getBinom</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        c[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; i;j++)&#123;</span><br><span class="line">            c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<h3 id="652-组合阶乘"><a class="markdownIt-Anchor" href="#652-组合阶乘"></a> 6.5.2 组合阶乘</h3>
<p>原理：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>i</mi><mi>j</mi></msubsup><mo>=</mo><mfrac><mrow><mi>i</mi><mo stretchy="false">!</mo></mrow><mrow><mi>j</mi><mo stretchy="false">!</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">C_i^j = \frac{i!}{j!(i-j)!}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.219436em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.942572em;"><span style="top:-2.4231360000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.400108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">!</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">)</span><span class="mclose mtight">!</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mclose mtight">!</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，计算阶乘复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，可以直接使用除法，也可以使用前面所说的乘法逆元（当对大数取模且P是质数时）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fac[N], ifac[N]; <span class="comment">// fac记录阶乘，ifac记录阶乘对应模P逆元</span></span><br><span class="line">fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getFac</span><span class="params">(<span class="type">int</span> maxn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= maxn;i++)&#123;</span><br><span class="line">        fac[i] = <span class="number">1LL</span>*fac[i<span class="number">-1</span>]*i % P;</span><br><span class="line">    &#125;</span><br><span class="line">    ifac[maxn] = <span class="built_in">fpow</span>(fac[maxn],P<span class="number">-2</span>); <span class="comment">// 使用费马小定理和快速幂求解逆元</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = maxn<span class="number">-1</span>;i &gt;= <span class="number">1</span>;i--) ifac[i] = <span class="number">1LL</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binom</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[i]*(ifac[j] % P )*(ifac[i-j] % P)*<span class="number">1LL</span> % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="66-随机"><a class="markdownIt-Anchor" href="#66-随机"></a> 6.6 随机</h2>
<ul>
<li>带有权重的随机<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/random-pick-with-weight/description/">leetcode 528.Random Pick with Weight</a></li>
<li>用某个范围随机数生成另一些随机数<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-rand10-using-rand7/description/">leetcode 470.Implement Rand10 Using Rand7</a></li>
<li>使用随机数计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span>：利用面积公式，计算随机点落入圆的概率</li>
</ul>
<h3 id="661-java随机数"><a class="markdownIt-Anchor" href="#661-java随机数"></a> 6.6.1 java随机数</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> rand.nextInt(<span class="number">100</span>)+<span class="number">1</span>; <span class="comment">//生成1-100（包括）的整数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random()*<span class="number">100</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>Math.random()</code>随机生成[0.0,1.0)之间的double类型数据</p>
<h3 id="662-c随机数"><a class="markdownIt-Anchor" href="#662-c随机数"></a> 6.6.2 c++随机数</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> t = <span class="built_in">rand</span>() % num; </span><br></pre></td></tr></table></figure>
<h2 id="67-求解平方根"><a class="markdownIt-Anchor" href="#67-求解平方根"></a> 6.7 求解平方根</h2>
<h3 id="671-二分法"><a class="markdownIt-Anchor" href="#671-二分法"></a> 6.7.1 二分法</h3>
<p>初始化为x/2，然后不断除2逼近</p>
<h3 id="672-牛顿迭代法"><a class="markdownIt-Anchor" href="#672-牛顿迭代法"></a> 6.7.2 牛顿迭代法</h3>
<p>设置一个近似值x（可以是n/2），然后不断用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>x</mi><mo>+</mo><mfrac><mi>a</mi><mi>x</mi></mfrac></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{x+ \frac{a}{x}}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.37988em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.03488em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5508em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>迭代逼近</p>
<p>画图可以得到以下递推关系：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><msub><mi>θ</mi><mi>t</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>θ</mi><mi>t</mi></msub><mo stretchy="false">)</mo><mo>−</mo><mi>n</mi></mrow><mrow><msub><mi>θ</mi><mi>t</mi></msub><mo>−</mo><msub><mi>θ</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">f&#x27;(\theta_t) = \frac{f(\theta_t)-n}{\theta_t - \theta_{t+1}} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.321331em;vertical-align:-0.894331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.894331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h2 id="68-回文数字"><a class="markdownIt-Anchor" href="#68-回文数字"></a> 6.8 回文数字</h2>
<p>从小到大依次生成回文数字，基本思想：固定回文根，如12，那么可以生成奇数位和偶数位两种回文数，121和1221.</p>
<p>算法过程：枚举范围内所有回文根（按照位数枚举）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n表示最大范围数位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> base = <span class="number">1</span>;base &lt; n;base *= <span class="number">10</span>)&#123;</span><br><span class="line">    <span class="comment">// 生成奇数位回文数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = base;i &lt; base*<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i/<span class="number">10</span>;j;j /= <span class="number">10</span>)&#123;</span><br><span class="line">            x = x*<span class="number">10</span>+j % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存储或操作生成的x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(base &lt;= n/<span class="number">2</span>)&#123; <span class="comment">// 不超过最大范围</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = base;i &lt; base*<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i;j;j /= <span class="number">10</span>)&#123;</span><br><span class="line">                x = x*<span class="number">10</span>+j % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//存储或操作生成的x</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article><nav id="pagination"><div class="prev-post pull-left"><a href="/2024/02/26/knowledge/c++/c++%E9%AB%98%E7%A8%8B/"><i class="fa fa-chevron-left">  </i><span>c++复习总结</span></a></div><div class="next-post pull-right"><a href="/2024/01/19/technology/frontend/roadmap/"><span>【前端八股】Roadmap</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/pics/back1.jpg?raw=true)"><div class="layout" id="footer"><div class="copyright">&copy;2023 - 2025 By A.R.L</div><div class="footer_custom_text">本站图片资源托管于Github, 网速限制可能无法正确加载</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>