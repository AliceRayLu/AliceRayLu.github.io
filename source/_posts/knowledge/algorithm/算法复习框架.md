---
title: 算法复习框架
date: 2024-01-19
category: [Knowledge,Algorithm]
toc_number: false
---

本文档总结了非ACMer应知应会基础算法cpp版本，不涉及算法详解，适合（保研机考/找实习）复习框架使用。

> 施工建设中……

# 0 c++ basic

## 0.1 万能头
```cpp
#include<bits/stdc++.h>
```
## 0.2 输入输出处理
- `cin/cout`
- `getline(cin, str, '\n')`：默认读入一行，可以更换截断字符

# 1 STL速查

## 1.1 常用STL操作
- `reverse(container.begin(), container.end())`：反转
- `sort(container.begin(), container.end(), bool cmp)`：排序
- `unique(container.begin(), container.end())`：先把容器排序，然后去重，返回去重后的结尾迭代器，可以通过`.erase()`删除结尾部分
- `shuffle(container.begin(), container.end())`：随机打乱元素（c++14 以前使用`random_shuffle()`）
- `lower_bound(a.begin(), a.end(), x)`：找到第一个 >= x的数，返回迭代器（找不到返回尾迭代器）【区别于`upper_bound`，upper返回第一个 > x的数】


## 1.2 vector
- 初始化
    ```cpp
    vector<int> a(n);
    vector<int> b(n,0);
    vector<int> c = {1,2,3};
    vector<int> d(a); // 将a复制一份为d
    vector<vector<int>> e(n,vector<int>(n));
    ```
- `push_back`：在数组末尾插入
- `pop_back`：在数组末尾删除

## 1.3 map
映射，底层仍然是红黑树

```cpp
map<int,int> mp；
mp[x] = 1; // 此种写法无论原来是否存在都会分配内存，使用find方法不会
mp.find(x); // 返回迭代器

for(auto [x,y] : mp){...} // c++17开始支持
```

如果要使用hash table，应该使用unordered_map，使用方式与map相同

## 1.4 set
底层是红黑树
- `insert`：插入元素 $O(logn)$
- `lower_bound(x)`：二分查找有序数列，返回大于等于x的最大值（迭代器iterator）
- `erase(x)`：删除迭代器对应的元素，如果x是迭代器 $O(1)$，是元素则会先find后删除 $O(logn)$
- `find(x)`：查找 $O(logn)$，返回迭代器
- **遍历**：使用迭代器

multiset可以插入重复元素，使用erase时只删除一个元素，不会把重复的都删除

## 1.5 stack
- `push(x)`：加入元素
- `pop()`：删去栈顶，返回值为void
- `top()`：返回栈顶元素

## 1.6 queue
- `push(x)`
- `pop()`
- `front()`

### 1.6.1 deque
同时操作头尾，双端队列
- `push_back(x)`：队尾插入
- `pop_back()`：弹出队尾元素
- `push_front(x)`：队首插入
- `pop_front()`：弹出队首元素

### 1.6.2 priority_queue
通常作为堆使用
- 初始化
    ```cpp
    priority_queue<int> q; // 默认大根堆（最大堆）
    priority_queue<int, vector<int>, greater<int>> q; //使用vector作为底层容器，小根堆
    ```
- `top()`：访问堆顶元素
- `push(x)`
- `pop()`

## 1.7 pair
使用first/second来访问元素

# 2 字符串

```cpp
// 字符串基本操作
string s;
s += 'a';

if(s1 < s2) {...}

s.c_str(); // 将string转化为c风格字符串，返回头指针
char[] c_str_ptr;
s = c_str_ptr; // 直接将char[]转换成string

s.substr(pos,len); // 截取下标开始处的len长度字串，不写len默认取到结尾

stoi(s); // 将字符串表示的数字直接转换为int

```

## 2.1 字符串哈希
基本思想：将字符串通过哈希函数转化为int值，$hash(s) = \Sigma_{i=0}^{n-1} s_i b^i$

注意点：b是大素数，计算出来的和（很大）需要取模

```cpp
const int M = 1e9+7;
const int B = 233;

int get_hash(const string& s){
    int res = 0;
    for(int i = 0;i < s.size();i++){
        res = (i64)(res*B + s[i]) % M;
    }
    return res;
}

bool cmp(const string& s, const string& t){
    return get_hash(s) == get_hash(t);
}
```

> 代码来自oi-wiki，`i64`表示`int64_t`，即c++中的64位带符号整数（头文件写法：`using i64 = int64_t;`）

【例题】[leetcode 187.Repeated DNA Sequences](https://leetcode.cn/problems/repeated-dna-sequences/description/)

## 2.2 Manacher算法


## 2.3 KMP算法
不重复匹配已经匹配过的相同前缀

```cpp
void kmp(string a, string b, vector<int>& next){
    //在a中匹配b，n和m分别表示a和b的长度，next数组维护公共前缀
    int n = a.length(),m = b.length();
    for(int i = 0,j = -1;i < n;i++){
        while(j > 0 && (j == m || a[i] != b[j+1])) j = next[j];
        if(a[i] == b[j+1]) j++;
        if(j == m-1) // a[i-m+1:i]是b在a中第一次出现
    }
}

vector<int> getNext(string b){
    int m = b.length();
    vector<int> next(m+1);
    next[0] = -1;
    for(int i = 1, j = -1; i < m; i++){
        while(j > 0 && b[i] != b[j+1]) j = next[j]; // 如果下一位不同，往前回溯
        if(b[i] == b[j+1]) ++j; // 下一位相同，更新最大前缀
        next[i] = j; 
    }
    return next;
}
```

【例题】[leetcode 28.Find the Index of the First Occurrence in a String](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

## 2.4 Trie
字典树

可以用链表传统树结构实现，也可以用数组的形式简易实现。

```cpp
namespace Trie{
    int root = 1, nodeCnt = 1, ch[N][26]; // 根节点从1开始编号
    bool flag[N]; // flag表示第x个节点是否为一个字符串结尾
    void insert(char s[], int n){
        int cur = root;
        for(int i = 1;i <= n;i++){
            if(!ch[cur][s[i]-'a']) ch[cur][s[i]-'a'] = ++nodeCnt;
            cur = ch[cur][s[i]-'a'];
        }
        flag[cur] = true;
    }
    bool query(char s[], int n){
        int cur = root;
        for(int i = 1;i <= n;i++) cur = ch[cur][s[i]-'a'];
        return flag[cur];
    }
}
```



# 3 常用结构

## 3.1 栈

## 3.2 队列

## 3.3 哈希表

## 3.4 前缀和

## 3.5 并查集

## 3.6 链表

## 3.7 树

# 4 技巧

## 4.1 动态规划

## 4.2 贪心

## 4.3 双指针

## 4.4 二分法

## 4.5 排序

## 4.6 搜索

## 4.7 位运算

# 5 图论

# 6 数学