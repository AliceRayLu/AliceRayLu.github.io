---
title: 算法复习框架
date: 2024-01-11
category: [Knowledge,Algorithm]
---

本文档总结了非ACMer应知应会基础算法cpp版本，不涉及算法详解，适合（保研机考/找实习）复习框架使用。

# 1 STL速查

## 1.1 vector
- `push_back`：在数组末尾插入
- `pop_back`：在数组末尾删除

## 1.2 map

## 1.3 set
- `insert`：插入元素 $O(logn)$
- `lower_bound(x)`：二分查找有序数列，返回大于等于x的最大值（迭代器iterator）
- `erase(x)`：删除迭代器对应的元素，如果x是迭代器 $O(1)$，是元素则会先find后删除 $O(logn)$
- `find(x)`：查找 $O(logn)$
- **遍历**：使用迭代器

## 1.4 stack

## 1.5 queue


# 2 字符串

## 2.1 字符串哈希
基本思想：将字符串通过哈希函数转化为int值，$hash(s) = \Sigma_{i=0}^{n-1} s_i b^i$

注意点：b是大素数，计算出来的和（很大）需要取模

```cpp
const int M = 1e9+7;
const int B = 233;

int get_hash(const string& s){
    int res = 0;
    for(int i = 0;i < s.size();i++){
        res = (i64)(res*B + s[i]) % M;
    }
    return res;
}

bool cmp(const string& s, const string& t){
    return get_hash(s) == get_hash(t);
}
```

> 代码来自oi-wiki，`i64`表示`int64_t`，即c++中的64位带符号整数（头文件写法：`using i64 = int64_t;`）

【例题】

## 2.2 Manacher算法

## 2.3 KMP算法
不重复匹配已经匹配过的相同前缀

```cpp
void kmp(char a[], int n, char b[], int m, vector<int>& next){
    //在a中匹配b，n和m分别表示a和b的长度，next数组维护公共前缀
    for(int i = 1,j = 0;i <= n;i++){
        while(j > 0 && (j == m || a[i] != b[j+1])) j = next[j];
        if(a[i] == b[j+1]) j++;
        if(j == m) // a[i-m+1:i]是b在a中第一次出现
    }
}

vector<int> getNext(char b[], int m){
    vector<int> next(m+1);
    next[1] = 0;
    for(int i = 2, j = 0; i <= m; i++){
        while(j > 0 && b[i] != b[j+1]) j = next[j];
        if(b[i] == b[j+1]) ++j;
        next[i] = j;
    }
    return next;
}
```

【例题】[Leetcode 28.Find the Index of the First Occurrence in a String](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

## 2.4 Trie
字典树

可以用链表传统树结构实现，也可以用数组的形式简易实现。

```cpp
namespace Trie{
    int root = 1, nodeCnt = 1, ch[N][26]; // 根节点从1开始编号
    bool flag[N]; // flag表示第x个节点是否为一个字符串结尾
    void insert(char s[], int n){
        int cur = root;
        for(int i = 1;i <= n;i++){
            if(!ch[cur][s[i]-'a']) ch[cur][s[i]-'a'] = ++nodeCnt;
            cur = ch[cur][s[i]-'a'];
        }
        flag[cur] = true;
    }
    bool query(char s[], int n){
        int cur = root;
        for(int i = 1;i <= n;i++) cur = ch[cur][s[i]-'a'];
        return flag[cur];
    }
}
```