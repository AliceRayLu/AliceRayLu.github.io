---
title: 算法复习框架
date: 2024-01-19
category: [Knowledge,Algorithm]
toc_number: false
---

本文档总结了非ACMer应知应会基础算法cpp版本，不涉及算法详解，适合（保研机考/找实习）复习框架使用。

> 施工建设中……

# 0 c++ basic

## 0.1 万能头
```cpp
#include<bits/stdc++.h>
```
## 0.2 输入输出处理
- `cin/cout`
- `getline(cin, str, '\n')`：默认读入一行，可以更换截断字符

# 1 STL速查

## 1.1 常用STL操作
- `reverse(container.begin(), container.end())`：反转
- `sort(container.begin(), container.end(), bool cmp)`：排序
- `unique(container.begin(), container.end())`：先把容器排序，然后去重，返回去重后的结尾迭代器，可以通过`.erase()`删除结尾部分
- `shuffle(container.begin(), container.end())`：随机打乱元素（c++14 以前使用`random_shuffle()`）
- `lower_bound(a.begin(), a.end(), x)`：找到第一个 >= x的数，返回迭代器（找不到返回尾迭代器）【区别于`upper_bound`，upper返回第一个 > x的数】


## 1.2 vector
- 初始化
    ```cpp
    vector<int> a(n);
    vector<int> b(n,0);
    vector<int> c = {1,2,3};
    vector<int> d(a); // 将a复制一份为d
    vector<vector<int>> e(n,vector<int>(n));
    ```
- `push_back`：在数组末尾插入
- `pop_back`：在数组末尾删除

## 1.3 map
映射，底层仍然是红黑树

```cpp
map<int,int> mp；
mp[x] = 1; // 此种写法无论原来是否存在都会分配内存，使用find方法不会
mp.find(x); // 返回迭代器

for(auto [x,y] : mp){...} // c++17开始支持
```

如果要使用hash table，应该使用unordered_map，使用方式与map相同

## 1.4 set
底层是红黑树
- `insert`：插入元素 $O(logn)$
- `lower_bound(x)`：二分查找有序数列，返回大于等于x的最大值（迭代器iterator）
- `erase(x)`：删除迭代器对应的元素，如果x是迭代器 $O(1)$，是元素则会先find后删除 $O(logn)$
- `find(x)`：查找 $O(logn)$，返回迭代器
- **遍历**：使用迭代器

multiset可以插入重复元素，使用erase时只删除一个元素，不会把重复的都删除

## 1.5 stack
- `push(x)`：加入元素
- `pop()`：删去栈顶，返回值为void
- `top()`：返回栈顶元素

## 1.6 queue
- `push(x)`
- `pop()`
- `front()`

### 1.6.1 deque
同时操作头尾，双端队列
- `push_back(x)`：队尾插入
- `pop_back()`：弹出队尾元素
- `push_front(x)`：队首插入
- `pop_front()`：弹出队首元素

### 1.6.2 priority_queue
通常作为堆使用
- 初始化
    ```cpp
    priority_queue<int> q; // 默认大根堆（最大堆）
    priority_queue<int, vector<int>, greater<int>> q; //使用vector作为底层容器，小根堆
    ```
- `top()`：访问堆顶元素
- `push(x)`
- `pop()`

## 1.7 pair
使用first/second来访问元素

# 2 字符串

```cpp
// 字符串基本操作
string s;
s += 'a';

if(s1 < s2) {...}

s.c_str(); // 将string转化为c风格字符串，返回头指针
char[] c_str_ptr;
s = c_str_ptr; // 直接将char[]转换成string

s.substr(pos,len); // 截取下标开始处的len长度字串，不写len默认取到结尾

stoi(s); // 将字符串表示的数字直接转换为int

```
【int与string互转】
- int转string
    c++11中的新特性`to_string()`
    ```cpp
    // c++11
    string to_string (int val);
    string to_string (long val);
    string to_string (long long val);
    string to_string (unsigned val);
    string to_string (unsigned long val);
    string to_string (unsigned long long val);
    string to_string (float val);
    string to_string (double val);
    string to_string (long double val);
    ```
- string转int：使用`istringstream`



## 2.1 字符串哈希
基本思想：将字符串通过哈希函数转化为int值，$hash(s) = \Sigma_{i=0}^{n-1} s_i b^i$

注意点：b是大素数，计算出来的和（很大）需要取模

```cpp
const int M = 1e9+7;
const int B = 233;

int get_hash(const string& s){
    int res = 0;
    for(int i = 0;i < s.size();i++){
        res = (i64)(res*B + s[i]) % M;
    }
    return res;
}

bool cmp(const string& s, const string& t){
    return get_hash(s) == get_hash(t);
}
```

> 代码来自oi-wiki，`i64`表示`int64_t`，即c++中的64位带符号整数（头文件写法：`using i64 = int64_t;`）

【例题】[leetcode 187.Repeated DNA Sequences](https://leetcode.cn/problems/repeated-dna-sequences/description/)

## 2.2 Manacher算法


## 2.3 KMP算法
不重复匹配已经匹配过的相同前缀

```cpp
void kmp(string a, string b, vector<int>& next){
    //在a中匹配b，n和m分别表示a和b的长度，next数组维护公共前缀
    int n = a.length(),m = b.length();
    for(int i = 0,j = -1;i < n;i++){
        while(j > 0 && (j == m || a[i] != b[j+1])) j = next[j];
        if(a[i] == b[j+1]) j++;
        if(j == m-1) // a[i-m+1:i]是b在a中第一次出现
    }
}

vector<int> getNext(string b){
    int m = b.length();
    vector<int> next(m+1);
    next[0] = -1;
    for(int i = 1, j = -1; i < m; i++){
        while(j > 0 && b[i] != b[j+1]) j = next[j]; // 如果下一位不同，往前回溯
        if(b[i] == b[j+1]) ++j; // 下一位相同，更新最大前缀
        next[i] = j; 
    }
    return next;
}
```

【例题】[leetcode 28.Find the Index of the First Occurrence in a String](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

## 2.4 Trie
字典树

可以用链表传统树结构实现，也可以用数组的形式简易实现。

```cpp
namespace Trie{
    int root = 1, nodeCnt = 1, ch[N][26]; // 根节点从1开始编号
    bool flag[N]; // flag表示第x个节点是否为一个字符串结尾
    void insert(char s[], int n){
        int cur = root;
        for(int i = 1;i <= n;i++){
            if(!ch[cur][s[i]-'a']) ch[cur][s[i]-'a'] = ++nodeCnt;
            cur = ch[cur][s[i]-'a'];
        }
        flag[cur] = true;
    }
    bool query(char s[], int n){
        int cur = root;
        for(int i = 1;i <= n;i++) cur = ch[cur][s[i]-'a'];
        return flag[cur];
    }
}
```

【例题】[leetcode 208.Implement Trie Prefix Tree](https://leetcode.cn/problems/implement-trie-prefix-tree/description/)


# 3 常用结构

## 3.1 栈
> First in, Last out.

STL提供`stack<T>`，也可以用数组简单实现

经典例题：括号匹配问题 [leetcode 20.Valid Parentheses](https://leetcode.cn/problems/valid-parentheses/description/)

【单调栈】栈中元素保持单调递增性或递减性

【例题】
- [leetcode 739.Daily Temperatures](https://leetcode.cn/problems/daily-temperatures/description/)
- [leetcode 503.Next Greater Element II](https://leetcode.cn/problems/next-greater-element-ii/description/)

## 3.2 队列
> First in, First out.

STL提供`queue<T>`，详见1.6节

【经典应用】广度优先搜索BFS（见4.6.1节）

### 3.2.1 单调队列
类似于单调栈，队列中元素保持单调性，通常用于滑动窗口问题。一般多用双端队列`deque`实现，但是deque常数较大，可以用数组替代。
通常用于**滑动窗口**问题。

【例题】[leetcode 239.Sliding Window Maximum](https://leetcode.cn/problems/sliding-window-maximum/solutions/)

### 3.2.2 优先队列/堆
优先队列使用堆实现，STL提供`priority_queue`（见1.6.2节）


## 3.3 哈希表


## <mark>3.4 并查集</mark>
基本思想：标记每一个节点的父节点

基本操作：
- 查询根节点（get）
- 合并树（merge）

并查集有两种优化方式，路径压缩和按秩合并

### 3.4.1 路径压缩
基本思想：每次get(x)后将x的根节点设置为查询到的节点
```cpp
namespace UFS{
    int ufs[N];
    void initialize(){for(int i = 0;i < n;i++) ufs[i] = i;}
    int get(int x){ return ufs[x] == x ? x : ufs[x] = get(ufs[x]);}
    void merge(int x,int y){
        int fx = get(x), fy = get(y);
        if(fx == fy) return;
        ufs[fx] = fy;
    }
}
```

### 3.4.2 按秩合并
按秩合并和路径压缩不能一起使用。
- 按树的节点数量合并
- 按树的深度（秩）合并

```cpp
namespace UFS{
    int ufs[N],rank[N];
    void initialize(){
        for(int i = 0;i < n;i++){
            ufs[i] = i;
            rank[i] = 1;
        }
    }
    int get(int x){return ufs[x] == x ? x : get(ufs[x]);}
    void merge(int x,int y){
        int fx = get(x), fy = get(y);
        if(fx == fy) return;
        if(rank[fx] < rank[fy]) ufs[fx] = fy;
        else{
            ufs[fy] = fx;
            if(rank[fx] == rank[fy]) rank[fx]++; // 高度相同时合并树高要加1
        }
    }
}
```

【例题】
- [leetcode 684.Redundant Connection](https://leetcode.cn/problems/redundant-connection/)
- [leetcode 765.Couples Holding Hands](https://leetcode.cn/problems/couples-holding-hands/)
- leetcode标签：并查集

## 3.5 链表

## 3.6 树

## 3.7 ST表

# 4 技巧

## <mark>4.1 动态规划</mark>

## 4.2 贪心

## 4.3 双指针

## 4.4 二分法

## 4.5 排序

## <mark>4.6 搜索</mark>

### 4.6.1 广度优先BFS
使用队列来存储每一层可以到达的节点

### 4.6.2 深度优先DFS


【例题】
- 变形搜索[leetcode 240.Search a 2D Matrix II](https://leetcode.cn/problems/search-a-2d-matrix-ii/description/)

## 4.7 位运算

## 4.8 前缀和与差分数组
对于任意一个数组$a_0,a_1,...,a_n$

【前缀和】构造前缀和数组$b_i = b_{i-1}+a_{i-1}, b_0 = 0$，求解区间 $[l,r]$ 的和可以用$O(1)$复杂度求出

【差分】构造差分数组$d_i = a_i-a_{i-1}, d_0 = 0$，对区间$[l,r]$做相同操作时（如同时加上$v, d_l += v, d_{r+1} -= v$）可以以$O(1)$复杂度实现。

【例题】[leetcode 560.Subarray Sum Equals K](https://leetcode.cn/problems/subarray-sum-equals-k/description/)

## 4.9 回溯

# 5 图论

# 6 数学

## 6.1 带余除法

### 6.1.1 最大公约数
辗转相除法（欧几里得法）求解最大公约数，$gcd(a,b) = gcd(a, b\space mod\space a)$ 

时间复杂度：$O(logn)$ 【证明：考虑$a>\frac{b}{2}$ 和$a<\frac{b}{2}$ 两种情况，可以证明每次整除会导致规模缩小一半】

实现与使用：
- c++14：`__gcd(int,int)` （在`<algorithm>`库中）
- c++17：`gcd(int,int)` （在`<numeric>`库中）

【例题】[leetcode 1447.Simplified Fractions](https://leetcode.cn/problems/simplified-fractions/description/)


### 6.1.2 不定方程
【定义】未知数个数超过方程数量，典型例子$ax+by=c$，$x,y$为未知数，$a,b,c$为参数

【裴蜀定理】$ax+by=c \iff gcd(a,b)|c$

简单证明：假设$a>b, a=b\cdot k+r $ ，那么$ax+by=c$ 可以写作 $b(y+kx)+rx = bx_0+ry_0 = c$

在上述式子中，$r$可以写作 $a\space mod \space b$，$k$可以写作 $\lfloor\frac{a}{b}\rfloor$（此处可利用c++中整数相除特性），因此<mark>扩展欧几里得算法</mark>可以写成：

```cpp
int extgcd(int a,int b,int& x,int& y){ //此处默认c=gcd(a,b)
    if(!b){ // b=0, ax=c, a = gcd(a,b)
        x = 1;
        y = 0;
        return a;
    }
    int d = extgcd(b,a%b,x,y),x0 = x,y0 = y;
    x = y0;
    y = x0-(a/b)*y0;
    return d;
}
```


【例题】[leetcode 365.Water And Jug Problem](https://leetcode.cn/problems/water-and-jug-problem/description/)