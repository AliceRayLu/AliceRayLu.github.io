<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A.R.L&#39;s Blog</title>
  
  <subtitle>Nothing holds still.</subtitle>
  <link href="https://aliceraylu.github.io/atom.xml" rel="self"/>
  
  <link href="https://aliceraylu.github.io/"/>
  <updated>2025-07-17T07:32:15.097Z</updated>
  <id>https://aliceraylu.github.io/</id>
  
  <author>
    <name>A.R.L</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMU 10-714 DL System(2024 Fall)</title>
    <link href="https://aliceraylu.github.io/2025/07/14/knowledge/machine%20learning/CMU10-714/"/>
    <id>https://aliceraylu.github.io/2025/07/14/knowledge/machine%20learning/CMU10-714/</id>
    <published>2025-07-13T16:00:00.000Z</published>
    <updated>2025-07-17T07:32:15.097Z</updated>
    
    
    
    
    <category term="Knowledge" scheme="https://aliceraylu.github.io/categories/Knowledge/"/>
    
    <category term="Machine Learning" scheme="https://aliceraylu.github.io/categories/Knowledge/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>解决wsl vscode界面无法使用github copilot问题</title>
    <link href="https://aliceraylu.github.io/2024/12/23/technology/device%20usage/Github%20Copilot%20WSL%E4%BD%BF%E7%94%A8/"/>
    <id>https://aliceraylu.github.io/2024/12/23/technology/device%20usage/Github%20Copilot%20WSL%E4%BD%BF%E7%94%A8/</id>
    <published>2024-12-22T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.491Z</updated>
    
    <content type="html"><![CDATA[<p>安装copilot插件后，在win环境中可以正常使用，但是在wsl中连不上，即使配置了wsl代理也没有用。STFI之后，参考这篇博客，<a href="https://www.cnblogs.com/o2iginal/p/17800963.html">https://www.cnblogs.com/o2iginal/p/17800963.html</a> （github上的issue也没有解决这个问题）但是当给vscode设置代理后，就可以使用了。</p><p>vscode settings -&gt; search ‘proxy’ -&gt; http代理地址设置为本地代理的地址（我的机器上是clash地址）</p><p>然后reload vscode window，就可以正常使用了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;安装copilot插件后，在win环境中可以正常使用，但是在wsl中连不上，即使配置了wsl代理也没有用。STFI之后，参考这篇博客，&lt;a href=&quot;https://www.cnblogs.com/o2iginal/p/17800963.html&quot;&gt;https://www</summary>
      
    
    
    
    <category term="Technology" scheme="https://aliceraylu.github.io/categories/Technology/"/>
    
    <category term="Device Usage" scheme="https://aliceraylu.github.io/categories/Technology/Device-Usage/"/>
    
    
  </entry>
  
  <entry>
    <title>Transformer Learning Materials</title>
    <link href="https://aliceraylu.github.io/2024/09/29/knowledge/machine%20learning/transformer/"/>
    <id>https://aliceraylu.github.io/2024/09/29/knowledge/machine%20learning/transformer/</id>
    <published>2024-09-28T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前置知识-encoderdecoder结构"><a class="markdownIt-Anchor" href="#1-前置知识-encoderdecoder结构"></a> 1 前置知识-Encoder&amp;Decoder结构</h2><p>encoder和decoder是一种模型结构，并不是某一个特定的神经网络模型。整体部分分为encoder编码器，decoder解码器：</p><ul><li>encoder编码器：将文字、图片、音视频转换为向量</li><li>decoder解码器：将向量翻译/恢复为文字、图片、音视频</li></ul><p>我们所熟悉的CNN、RNN、LSTM就可以用来充当encoder、decoder部分。</p><p>这个结构必须保证，encoder和decoder之间使用的向量维度是相同且固定的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-前置知识-encoderdecoder结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-前置知识-encoderdecoder结构&quot;&gt;&lt;/a&gt; 1 前置知识-Encoder&amp;amp;Decoder结构&lt;/h2&gt;
&lt;p&gt;enco</summary>
      
    
    
    
    <category term="Knowledge" scheme="https://aliceraylu.github.io/categories/Knowledge/"/>
    
    <category term="Machine Learning" scheme="https://aliceraylu.github.io/categories/Knowledge/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>CS224n(2024 Spring)</title>
    <link href="https://aliceraylu.github.io/2024/04/29/knowledge/machine%20learning/CS224n/"/>
    <id>https://aliceraylu.github.io/2024/04/29/knowledge/machine%20learning/CS224n/</id>
    <published>2024-04-28T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.452Z</updated>
    
    <content type="html"><![CDATA[<p>所有的作业实现与notes笔记、paper下载都在<a href="">github repository</a></p><p>【个人食用方式】</p><ol><li>阅读课程notes，视需要查看课程视频</li><li>阅读schedule中提供的论文材料</li><li>完成assignment</li></ol><h1 id="assignment-1"><a class="markdownIt-Anchor" href="#assignment-1"></a> Assignment 1</h1><p>按照readme使用conda安装环境完成notebook</p><blockquote><p><strong>环境配置问题：</strong><br />配置过程中遇到报错<code>cannot import name 'triu' from 'scipy.linalg'</code><br />在stackoverflow找到解决办法：使用命令<code>pip install scipy==1.12</code>安装1.12版本即可</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;所有的作业实现与notes笔记、paper下载都在&lt;a href=&quot;&quot;&gt;github repository&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【个人食用方式】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;阅读课程notes，视需要查看课程视频&lt;/li&gt;
&lt;li&gt;阅读schedule中提供的论文材料&lt;/l</summary>
      
    
    
    
    <category term="Knowledge" scheme="https://aliceraylu.github.io/categories/Knowledge/"/>
    
    <category term="Machine Learning" scheme="https://aliceraylu.github.io/categories/Knowledge/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>git命令记忆</title>
    <link href="https://aliceraylu.github.io/2024/03/20/technology/frontend/git/"/>
    <id>https://aliceraylu.github.io/2024/03/20/technology/frontend/git/</id>
    <published>2024-03-19T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.500Z</updated>
    
    <content type="html"><![CDATA[<p>面试的时候被狠狠拷打了一番，发现git有些命令还是没有掌握的很好</p><h2 id="git-reset"><a class="markdownIt-Anchor" href="#git-reset"></a> git reset</h2><p>用于回退版本，遗弃不再需要的提交，通过移动HEAD头实现</p><ul><li><p>–mixed（默认）：默认的时候，只有暂存区变化</p></li><li><p>–hard参数：如果使用 --hard 参数，那么工作区也会变化</p></li><li><p>–soft：如果使用 --soft 参数，那么暂存区和工作区都不会变化</p></li></ul><h2 id="git-revert"><a class="markdownIt-Anchor" href="#git-revert"></a> git revert</h2><p>在现有的版本后面新建一个提交来取消某一次提交，用于安全地取消某一次提交</p><p>revert撤销已经push（公开）的提交，reset用于工作区的修改</p><h2 id="git-merge"><a class="markdownIt-Anchor" href="#git-merge"></a> git merge</h2><p>将当前分支合并到给出的分支</p><h2 id="git-rebase"><a class="markdownIt-Anchor" href="#git-rebase"></a> git rebase</h2><p>将当前分支移植到指定分支或指定commit之上</p><h2 id="git-stash"><a class="markdownIt-Anchor" href="#git-stash"></a> git stash</h2><p>暂存一些代码修改<br />git stash</p><p>git stash save</p><p>git stash list</p><p>git stash pop</p><p>git stash apply</p><p>git stash show</p><p>git stash drop</p><p>git stash clear</p><p>【使用场景】</p><p>使用git pull拉去远程分支的代码到本地，与本地的修改发生冲突，但是并不想提交本地的修改，就需要用暂存命令保存</p><h2 id="git-fetch-pull"><a class="markdownIt-Anchor" href="#git-fetch-pull"></a> git fetch &amp; pull</h2><p>从远程分支拉取最新代码到本地，git fetch不会自动merge，git pull会自动merge</p><h2 id="branch"><a class="markdownIt-Anchor" href="#branch"></a> branch</h2><p>【命名规则】</p><ul><li>只能使用字母、数字、横线、下划线和句点。</li><li>分支名称不能以横线或句点开头或结尾。</li><li>不允许使用的特殊字符：空格，反斜杠、冒号、问号、星号、左右尖括号</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面试的时候被狠狠拷打了一番，发现git有些命令还是没有掌握的很好&lt;/p&gt;
&lt;h2 id=&quot;git-reset&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#git-reset&quot;&gt;&lt;/a&gt; git reset&lt;/h2&gt;
&lt;p&gt;用于回退版本，遗弃不再</summary>
      
    
    
    
    <category term="Technology" scheme="https://aliceraylu.github.io/categories/Technology/"/>
    
    <category term="Frontend" scheme="https://aliceraylu.github.io/categories/Technology/Frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>【前端八股】CSS</title>
    <link href="https://aliceraylu.github.io/2024/03/09/technology/frontend/CSS/"/>
    <id>https://aliceraylu.github.io/2024/03/09/technology/frontend/CSS/</id>
    <published>2024-03-08T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-css选择器"><a class="markdownIt-Anchor" href="#1-css选择器"></a> 1 CSS选择器</h1><p>id选择器（#box），选择id为box的元素</p><p>类选择器（.one），选择类名为one的所有元素</p><p>标签选择器（div），选择标签为div的所有元素</p><p>后代选择器（#box div），选择id为box元素内部所有的div元素</p><p>子选择器（.one&gt;one_1），选择父元素为.one的所有.one_1的元素</p><p>相邻同胞选择器（.one+.two），选择紧接在.one之后的所有.two元素</p><p>群组选择器（div,p），选择div、p的所有元素</p><h2 id="11-选择器优先级"><a class="markdownIt-Anchor" href="#11-选择器优先级"></a> 1.1 选择器优先级</h2><p>内联 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器</p><h2 id="12-复合选择器"><a class="markdownIt-Anchor" href="#12-复合选择器"></a> 1.2 复合选择器</h2><h1 id="2-预处理器"><a class="markdownIt-Anchor" href="#2-预处理器"></a> 2 预处理器</h1><p>less sass</p><h1 id="3-css3新特性"><a class="markdownIt-Anchor" href="#3-css3新特性"></a> 3 CSS3新特性</h1><h1 id="4-盒模型"><a class="markdownIt-Anchor" href="#4-盒模型"></a> 4 盒模型</h1><h2 id="41-标准盒模型与ie盒模型"><a class="markdownIt-Anchor" href="#41-标准盒模型与ie盒模型"></a> 4.1 标准盒模型与IE盒模型</h2><p>标准盒模型的宽度以及高度只计算实际内容content的宽高，IE盒模型的宽高是除了margin之外所有border（包含）以内的元素宽高</p><p>使用box-sizing属性改变盒模型类型，默认为标准</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-sizing</span>: border-box; <span class="comment">/* 使用ie盒模型 */</span></span><br></pre></td></tr></table></figure><h2 id="42-居中对齐"><a class="markdownIt-Anchor" href="#42-居中对齐"></a> 4.2 居中对齐</h2><h3 id="421-水平居中"><a class="markdownIt-Anchor" href="#421-水平居中"></a> 4.2.1 水平居中</h3><h3 id="422-垂直居中"><a class="markdownIt-Anchor" href="#422-垂直居中"></a> 4.2.2 垂直居中</h3><h1 id="5-像素大小"><a class="markdownIt-Anchor" href="#5-像素大小"></a> 5 像素大小</h1><h2 id="51-px"><a class="markdownIt-Anchor" href="#51-px"></a> 5.1 px</h2><h2 id="52-emrem"><a class="markdownIt-Anchor" href="#52-emrem"></a> 5.2 em/rem</h2><h2 id="53-vwvh"><a class="markdownIt-Anchor" href="#53-vwvh"></a> 5.3 vw/vh</h2><h1 id="6-position"><a class="markdownIt-Anchor" href="#6-position"></a> 6 position</h1><ul><li><code>relative</code>：相对于默认位置的偏移</li><li><code>absolute</code>：相对于父级元素的偏移</li><li><code>fixed</code>：相对于浏览器窗口是固定的位置</li></ul><p>absolute和fixed会脱离文档流</p><h1 id="7-布局"><a class="markdownIt-Anchor" href="#7-布局"></a> 7 布局</h1><h2 id="71-两栏布局"><a class="markdownIt-Anchor" href="#71-两栏布局"></a> 7.1 两栏布局</h2><ul><li>设置左侧固定宽度，float:left，右栏使用margin-left撑出空间</li><li>使用flex布局：父元素使用display：flex，左边栏固定宽度，右边栏flex：1</li></ul><h2 id="72-三栏布局"><a class="markdownIt-Anchor" href="#72-三栏布局"></a> 7.2 三栏布局</h2><ul><li>两边使用 float，中间使用 margin</li><li>两边使用 absolute，中间使用 margin</li><li>display: table 实现</li><li>flex实现</li><li>grid网格布局</li></ul><h2 id="73-grid布局"><a class="markdownIt-Anchor" href="#73-grid布局"></a> 7.3 grid布局</h2><h2 id="74-flex"><a class="markdownIt-Anchor" href="#74-flex"></a> 7.4 flex</h2><p>flex-direction</p><h3 id="741-flex1"><a class="markdownIt-Anchor" href="#741-flex1"></a> 7.4.1 flex:1;</h3><ul><li>flex-grow:1; 将该行多余的空间按比例分给这个元素</li><li>flex-shrink:1; 超出部分按比例分配到每个元素进行挤压</li><li>flex-basis: 0%; 计算多余空间</li></ul><h2 id="75-bfc"><a class="markdownIt-Anchor" href="#75-bfc"></a> 7.5 BFC</h2><h2 id="76-文字溢出"><a class="markdownIt-Anchor" href="#76-文字溢出"></a> 7.6 文字溢出</h2><h1 id="8-回流与重绘"><a class="markdownIt-Anchor" href="#8-回流与重绘"></a> 8 回流与重绘</h1><p>回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置</p><p>重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制</p><h1 id="9-动画"><a class="markdownIt-Anchor" href="#9-动画"></a> 9 动画</h1><h2 id="transition"><a class="markdownIt-Anchor" href="#transition"></a> transition</h2><p>【包含属性】</p><ul><li>transition-property</li><li>transition-duration</li><li>transition-timing-function</li><li>transition-delay</li></ul><h2 id="transform"><a class="markdownIt-Anchor" href="#transform"></a> transform</h2><p>使用transform来改变元素位置属性，不会像position那样触发回流（重新布局计算），可以优化性能。</p><h2 id="translate"><a class="markdownIt-Anchor" href="#translate"></a> translate</h2><h2 id="animation"><a class="markdownIt-Anchor" href="#animation"></a> animation</h2><h1 id="10-性能优化"><a class="markdownIt-Anchor" href="#10-性能优化"></a> 10 性能优化</h1><h1 id="11-css兼容不同浏览器"><a class="markdownIt-Anchor" href="#11-css兼容不同浏览器"></a> 11 CSS兼容不同浏览器</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-css选择器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-css选择器&quot;&gt;&lt;/a&gt; 1 CSS选择器&lt;/h1&gt;
&lt;p&gt;id选择器（#box），选择id为box的元素&lt;/p&gt;
&lt;p&gt;类选择器（.one），选择类名为one的所有元</summary>
      
    
    
    
    <category term="Technology" scheme="https://aliceraylu.github.io/categories/Technology/"/>
    
    <category term="Frontend" scheme="https://aliceraylu.github.io/categories/Technology/Frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>【前端八股】HTML</title>
    <link href="https://aliceraylu.github.io/2024/03/09/technology/frontend/HTML/"/>
    <id>https://aliceraylu.github.io/2024/03/09/technology/frontend/HTML/</id>
    <published>2024-03-08T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-html5新特性"><a class="markdownIt-Anchor" href="#1-html5新特性"></a> 1 HTML5新特性</h1><ul><li>加入语义化标签</li><li>加入媒体标签：<code>audio, video</code></li><li>表单form</li><li>dom查询操作：<code>querySelector</code></li><li>web存储:localStorage, sessionStorage</li><li>其他：draggable</li></ul><h1 id="2-语义化标签"><a class="markdownIt-Anchor" href="#2-语义化标签"></a> 2 语义化标签</h1><ul><li><code>&lt;header&gt;&lt;/header&gt;</code>  头部</li><li><code>&lt;nav&gt;&lt;/nav&gt;</code>  导航栏</li><li><code>&lt;section&gt;&lt;/section&gt;</code>  区块（有语义化的div）</li><li><code>&lt;main&gt;&lt;/main&gt;</code>  主要区域</li><li><code>&lt;article&gt;&lt;/article&gt;</code>  主要内容</li><li><code>&lt;aside&gt;&lt;/aside&gt;</code>  侧边栏</li><li><code>&lt;footer&gt;&lt;/footer&gt;</code>  底部</li></ul><h1 id="3-块级元素与行内元素"><a class="markdownIt-Anchor" href="#3-块级元素与行内元素"></a> 3 块级元素与行内元素</h1><h2 id="31-块级元素"><a class="markdownIt-Anchor" href="#31-块级元素"></a> 3.1 块级元素</h2><ul><li>div：容器</li><li>dl：html5之前用于定义列表，与<code>&lt;dt&gt;</code>（子条目标题）和<code>&lt;dd&gt;</code>（子条目内容）嵌套使用  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Beast of Bodmin<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>A large feline inhabiting Bodmin Moor.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Morgawr<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>A sea serpent.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>form</li><li>h1 h2 h3 h4 h5 h6</li><li>hr</li><li>ol li p pre table td tr</li></ul><h2 id="32-行内元素"><a class="markdownIt-Anchor" href="#32-行内元素"></a> 3.2 行内元素</h2><p>a b s i u span br img input textarea sub sup</p><h2 id="33-行内与块级元素的区别"><a class="markdownIt-Anchor" href="#33-行内与块级元素的区别"></a> 3.3 行内与块级元素的区别</h2><p>行内元素：</p><ol><li>无法设置宽高；</li><li>对margin仅设置左右有效，上下无效；</li><li>padding上下左右有效；不会自动换行</li></ol><p>块级元素：</p><ol><li>可以设置宽高</li><li>margin和padding的上下左右均对其有效</li><li>超出当前行会自动换行</li><li>多个块状元素标签写在一起，默认排列方式为从上至下</li></ol><h1 id="4-标签中嵌入"><a class="markdownIt-Anchor" href="#4-标签中嵌入"></a> 4 标签中嵌入</h1><p>使用<code>&amp;lt;</code>在标签中使用尖角符号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 这是被<span class="symbol">&amp;lt;</span>p<span class="symbol">&amp;gt;</span>包含起来的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-html5新特性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-html5新特性&quot;&gt;&lt;/a&gt; 1 HTML5新特性&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;加入语义化标签&lt;/li&gt;
&lt;li&gt;加入媒体标签：&lt;code&gt;audio, video</summary>
      
    
    
    
    <category term="Technology" scheme="https://aliceraylu.github.io/categories/Technology/"/>
    
    <category term="Frontend" scheme="https://aliceraylu.github.io/categories/Technology/Frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>【前端八股】Frameworks</title>
    <link href="https://aliceraylu.github.io/2024/03/05/technology/frontend/Frame/"/>
    <id>https://aliceraylu.github.io/2024/03/05/technology/frontend/Frame/</id>
    <published>2024-03-04T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.493Z</updated>
    
    <content type="html"><![CDATA[<p>面试时经常喜欢提问对比性问题，比如列表元素，在vue中不加key的反应和react中不加key的反应，涉及到框架底层的渲染机制</p><h1 id="vue"><a class="markdownIt-Anchor" href="#vue"></a> Vue</h1><h2 id="渲染流程"><a class="markdownIt-Anchor" href="#渲染流程"></a> 渲染流程</h2><ol><li>解析模板</li><li>生成渲染函数</li><li>执行渲染函数</li><li>对比新旧虚拟dom树：根据diff算法决定需要更新的内容</li><li>更新dom</li></ol><h2 id="生命周期hooks"><a class="markdownIt-Anchor" href="#生命周期hooks"></a> 生命周期hooks</h2><h3 id="常规hooks"><a class="markdownIt-Anchor" href="#常规hooks"></a> 常规hooks</h3><h3 id="父子组件渲染顺序"><a class="markdownIt-Anchor" href="#父子组件渲染顺序"></a> 父子组件渲染顺序</h3><h3 id="keep-alive"><a class="markdownIt-Anchor" href="#keep-alive"></a> keep-alive</h3><p>在<strong>组件切换</strong>过程中，将组件的状态保存在内存中，防止重复渲染dom。</p><p>组件就没有beforeDestroyed和destroyed的生命周期钩子函数，会被替换成activated,beforeactivate</p><h2 id="双向绑定"><a class="markdownIt-Anchor" href="#双向绑定"></a> 双向绑定</h2><p>MVVM原理</p><p>数据劫持（object.defineProperty）+ 发布-订阅模式</p><h3 id="手写发布-订阅模式"><a class="markdownIt-Anchor" href="#手写发布-订阅模式"></a> 手写发布-订阅模式</h3><h3 id="数据劫持"><a class="markdownIt-Anchor" href="#数据劫持"></a> 数据劫持</h3><p>使用object.defineProperty的缺点：通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染。</p><p>vue2解决方案：重写函数；vue3解决方案：使用proxy监听</p><h3 id="mvvmmvcmvp"><a class="markdownIt-Anchor" href="#mvvmmvcmvp"></a> MVVM，MVC，MVP</h3><p><strong>MVVM</strong>：model，view，viewmodel，双向绑定，通过viewmodel进行model和view的更新</p><p><strong>MVC</strong>：model，view， controller。view的交互触发controller调用，修改model，触发view更新【观察者模式】</p><p><strong>MVP</strong>：model，view，presenter。解耦view和model，在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新</p><h3 id="watch"><a class="markdownIt-Anchor" href="#watch"></a> watch</h3><p>支持异步和开销比较大</p><h3 id="computed"><a class="markdownIt-Anchor" href="#computed"></a> computed</h3><p>缓存，不支持异步；更多的是观察作用触发回调函数</p><h3 id="methods"><a class="markdownIt-Anchor" href="#methods"></a> methods</h3><p>每次数据更新都会触发method执行</p><h2 id="语法糖"><a class="markdownIt-Anchor" href="#语法糖"></a> 语法糖</h2><h3 id="指令系统"><a class="markdownIt-Anchor" href="#指令系统"></a> 指令系统</h3><h4 id="v-if-v-show"><a class="markdownIt-Anchor" href="#v-if-v-show"></a> v-if、v-show</h4><p>v-if通过操作dom树，v-show改变css的display属性值</p><h4 id="v-if-v-for优先级"><a class="markdownIt-Anchor" href="#v-if-v-for优先级"></a> v-if、v-for优先级</h4><h3 id="slot"><a class="markdownIt-Anchor" href="#slot"></a> slot</h3><p>获取传进<code>&lt;&gt;&lt;/&gt;</code>之间的值</p><h2 id="axios"><a class="markdownIt-Anchor" href="#axios"></a> axios</h2><h2 id="单屏"><a class="markdownIt-Anchor" href="#单屏"></a> 单屏</h2><h2 id="组件通信方式"><a class="markdownIt-Anchor" href="#组件通信方式"></a> 组件通信方式</h2><h2 id="虚拟dom"><a class="markdownIt-Anchor" href="#虚拟dom"></a> 虚拟dom</h2><h3 id="diff算法"><a class="markdownIt-Anchor" href="#diff算法"></a> diff算法</h3><h3 id="key"><a class="markdownIt-Anchor" href="#key"></a> key</h3><h3 id="vue3优化"><a class="markdownIt-Anchor" href="#vue3优化"></a> vue3优化</h3><p>增加一些静态标记，对静态节点不进行重复的渲染</p><h2 id="vue3和vue2"><a class="markdownIt-Anchor" href="#vue3和vue2"></a> Vue3和Vue2</h2><p>Vue3的优化：</p><ul><li>更小：移除一些不常用api</li><li>更快：编译速度更快</li><li>支持ts</li><li>使用proxy替代defineProperty进行数据劫持</li><li>tree shaking: 只有需要的包才会被打包使用</li></ul><h2 id="vuex"><a class="markdownIt-Anchor" href="#vuex"></a> Vuex</h2><h1 id="react"><a class="markdownIt-Anchor" href="#react"></a> React</h1><h2 id="hooks"><a class="markdownIt-Anchor" href="#hooks"></a> hooks</h2><h3 id="state和props"><a class="markdownIt-Anchor" href="#state和props"></a> state和props</h3><h3 id="usestate-useeffect-usecallback-usememo"><a class="markdownIt-Anchor" href="#usestate-useeffect-usecallback-usememo"></a> useState useEffect useCallback useMemo</h3><h2 id="函数式组件和类式组件"><a class="markdownIt-Anchor" href="#函数式组件和类式组件"></a> 函数式组件和类式组件</h2><h2 id="虚拟dom-2"><a class="markdownIt-Anchor" href="#虚拟dom-2"></a> 虚拟dom</h2><h2 id="组件通信"><a class="markdownIt-Anchor" href="#组件通信"></a> 组件通信</h2><h2 id="diff算法-2"><a class="markdownIt-Anchor" href="#diff算法-2"></a> diff算法</h2><h2 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> 生命周期</h2><h1 id="vue-vs-react"><a class="markdownIt-Anchor" href="#vue-vs-react"></a> Vue VS React</h1><p>React特点总结：</p><ul><li>JSX：使用javascript写html</li><li>functional programming</li><li>lifecycle hooks</li><li>react native for mobile devices</li></ul><p>Vue特性：</p><ul><li>html、js、css集成在一个文件中</li><li>syntatic sugar: v-if v-for</li><li>slot</li></ul><p>【相同点】</p><ul><li>都有组件化思想</li><li>都支持服务器端渲染</li><li>都有Virtual DOM（虚拟dom）</li><li>数据驱动视图</li><li>都有支持native的方案：Vue的weex、React的React native</li><li>都有自己的构建工具：Vue的vue-cli、React的Create React App<br />【区别】</li><li>数据流向的不同。react从诞生开始就推崇单向数据流，而Vue是双向数据流</li><li>数据变化的实现原理不同。react使用的是不可变数据，而Vue使用的是可变的数据</li><li>组件化通信的不同。react中我们通过使用回调函数来进行通信的，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数</li><li>diff算法不同。react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue 使用双向指针，边对比，边更新DOM</li></ul><h1 id="前端性能优化"><a class="markdownIt-Anchor" href="#前端性能优化"></a> 前端性能优化</h1><h2 id="优化思路"><a class="markdownIt-Anchor" href="#优化思路"></a> 优化思路</h2><p>浏览器 -&gt; 资源加载（图片） -&gt; 代码</p><h2 id="评价指标"><a class="markdownIt-Anchor" href="#评价指标"></a> 评价指标</h2><ul><li>白屏时间</li><li>页面渲染时间</li><li>最大内容加载时间</li></ul><h2 id="优化白屏"><a class="markdownIt-Anchor" href="#优化白屏"></a> 优化白屏</h2><ul><li>DNS服务优化</li><li>CDN内容分发网络</li><li>服务端优化（缓存与分包）</li></ul><h2 id="优化渲染"><a class="markdownIt-Anchor" href="#优化渲染"></a> 优化渲染</h2><ul><li>JS：使用防抖优化用户输入</li><li>CSS样式：减少复杂的样式计算和嵌套；避免大的、复杂的布局和布局回流；异步加载非必须css</li></ul><h2 id="最大内容加载"><a class="markdownIt-Anchor" href="#最大内容加载"></a> 最大内容加载</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面试时经常喜欢提问对比性问题，比如列表元素，在vue中不加key的反应和react中不加key的反应，涉及到框架底层的渲染机制&lt;/p&gt;
&lt;h1 id=&quot;vue&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#vue&quot;&gt;&lt;/a&gt; Vue&lt;/h1&gt;
&lt;</summary>
      
    
    
    
    <category term="Technology" scheme="https://aliceraylu.github.io/categories/Technology/"/>
    
    <category term="Frontend" scheme="https://aliceraylu.github.io/categories/Technology/Frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>【前端八股】JavaScript</title>
    <link href="https://aliceraylu.github.io/2024/02/27/technology/frontend/JS/"/>
    <id>https://aliceraylu.github.io/2024/02/27/technology/frontend/JS/</id>
    <published>2024-02-26T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据类型"><a class="markdownIt-Anchor" href="#1-数据类型"></a> 1 数据类型</h1><h2 id="11-letconstvar"><a class="markdownIt-Anchor" href="#11-letconstvar"></a> 1.1 let/const/var</h2><p>用于声明变量</p><ul><li><code>var</code>：函数作用域，存在提升现象，在全局定义时会变成window对象的属性</li><li><code>let</code>：块作用域，作用域更小，不允许冗余（重复）声明</li><li><code>const</code>：const基本与let相同，但是声明时必须初始化且不能修改（如果const指向一个对象，可以修改对象内部属性值）</li></ul><p>【var/let迭代变量现象】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i),<span class="number">0</span>) <span class="comment">// 输出5,5,5,5,5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i),<span class="number">0</span>) <span class="comment">// 输出0,1,2,3,4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-基本数据类型"><a class="markdownIt-Anchor" href="#12-基本数据类型"></a> 1.2 基本数据类型</h2><ul><li><code>Undefined</code></li><li><code>Null</code>：表示一个空对象指针</li><li><code>Boolean</code></li><li><code>Number</code>：8进制-0o______，16进制-0x____，浮点数（IEEE754），科学计数法（e）</li><li><code>String</code>：string类型不可变</li><li><code>Symbol</code>(ES6新增)</li></ul><p>以上是6种基本数据类型，以下是引用数据类型。</p><ul><li><code>Object</code></li><li><code>Array</code></li><li><code>Function</code></li></ul><p>基本数据类型存储在栈中，直接存储对应值，引用数据类型存储在堆中，在栈中存放关于这个对象的引用。</p><h3 id="121-undefined"><a class="markdownIt-Anchor" href="#121-undefined"></a> 1.2.1 undefined</h3><p>声明但是没有初始化</p><p>请注意<strong>未声明报错</strong>和undefined区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mess = <span class="literal">undefined</span> <span class="comment">// 显式undefined初始化（不必要：默认）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mess == <span class="literal">undefined</span>) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(mess)&#123;</span><br><span class="line">    <span class="comment">//不执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!mess) <span class="comment">// 执行</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> === <span class="literal">undefined</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>【null VS undefined】<br />使用null初始化空值，undefined表明未定义。undefined从null中派生，null是指向空对象的引用。</p><h3 id="122-boolean"><a class="markdownIt-Anchor" href="#122-boolean"></a> 1.2.2 boolean</h3><p><code>true</code>和<code>false</code>区分大小写，只有全小写是bool值，其他形式都是标识符。</p><p>【其他类型布尔值等价形式】</p><table><thead><tr><th style="text-align:center">true</th><th style="text-align:center">false</th></tr></thead><tbody><tr><td style="text-align:center">非空string</td><td style="text-align:center">“”(empty string)</td></tr><tr><td style="text-align:center">非零数值</td><td style="text-align:center">0，NaN</td></tr><tr><td style="text-align:center">任意对象</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">N/A(不存在)</td><td style="text-align:center">undefined</td></tr></tbody></table><h3 id="123-nan"><a class="markdownIt-Anchor" href="#123-nan"></a> 1.2.3 NaN</h3><p>Nan任何操作始终返回NaN</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> == <span class="title class_">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">10</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>) <span class="comment">//false，可以转化为数值</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>) <span class="comment">// true 不可以转化为数值</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">true</span>) <span class="comment">// false 可以转化为1</span></span><br></pre></td></tr></table></figure><h3 id="124-string操作"><a class="markdownIt-Anchor" href="#124-string操作"></a> 1.2.4 string操作</h3><h4 id="1241-模板字符串"><a class="markdownIt-Anchor" href="#1241-模板字符串"></a> 1.2.4.1 模板字符串</h4><p>`包括的字符串是模板字符串，允许<strong>换行</strong>，<strong>嵌入变量</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val = <span class="string">`hi</span></span><br><span class="line"><span class="string">hither`</span>;</span><br><span class="line"><span class="keyword">let</span> jas = <span class="string">`<span class="subst">$&#123;val&#125;</span> use`</span></span><br></pre></td></tr></table></figure><h4 id="1242-修改"><a class="markdownIt-Anchor" href="#1242-修改"></a> 1.2.4.2 修改</h4><ul><li><code>+</code>/<code>concat()</code>/<code>$&#123;&#125;</code>都可以用于拼接字符串</li><li><code>slice(start,end)</code>/<code>substring(start,end)</code>：获取[start,end)副本</li><li><code>substr(start,len)</code>：获取从start开始长度为len的字符串副本</li><li><code>trim()</code>/<code>trimLeft()</code>/<code>trimRight()</code>：删除指定位置空格</li><li><code>repeat(n)</code>：字符串重复n次</li><li><code>padStart(len,char)</code>/<code>padEnd(len,char)</code>：当字符串长度不满len时，使用char填充到指定位置</li><li><code>toLowerCase()</code>/<code>toUpperCase()</code>：全小写，全大写</li></ul><h4 id="1243-查询"><a class="markdownIt-Anchor" href="#1243-查询"></a> 1.2.4.3 查询</h4><ul><li><code>charAt(pos)</code></li><li><code>indexOf(string)</code></li><li><code>startWith(string)</code></li><li><code>includes(string)</code></li></ul><h4 id="1244-正则表达式匹配"><a class="markdownIt-Anchor" href="#1244-正则表达式匹配"></a> 1.2.4.4 正则表达式匹配</h4><p>基于正则表达式</p><ul><li><code>match(pattern)</code>：返回一个匹配的字符串数组</li><li><code>search(pattern)</code>：返回找到的位置下标</li><li><code>replace(old,new)</code>：替换字符串中匹配的位置，返回替换后的结果字符串</li></ul><h4 id="1245-转化"><a class="markdownIt-Anchor" href="#1245-转化"></a> 1.2.4.5 转化</h4><ul><li><code>split(char)</code>：按照char分割字符串，返回字符串数组</li></ul><h3 id="125-object常用方法"><a class="markdownIt-Anchor" href="#125-object常用方法"></a> 1.2.5 Object常用方法</h3><ul><li><code>Object.assign(obj,src1,src2,...)</code>：后面的src会覆盖前面src的相同属性</li><li><code>Object.create(proto)</code>：创建一个以proto为原型的对象</li><li><code>Object.entries(obj)</code>：可枚举属性对数组</li><li><code>Object.keys(obj)</code>：自身可枚举属性（不包括原型链）【<code>for...in</code>：全部可枚举属性，包括原型链】</li><li><code>Object.getOwnPropertyNames(obj)</code>：自身所有属性，包括可枚举不可枚举（不包括原型链）</li><li><code>Object.values(obj)</code>：与keys对应</li></ul><h3 id="126-symbol"><a class="markdownIt-Anchor" href="#126-symbol"></a> 1.2.6 Symbol</h3><p>用于标记唯一对象，不可以使用<code>new Symbol()</code></p><p>【创建方法】</p><ul><li><code>const s = Symbol(&quot;foo&quot;)</code>这种方法创建的即便描述一样也会被认为是不同的symbol</li><li><code>const s = Symbol.for(&quot;foo&quot;)</code>这种方法创建的会注册在全局symbol表中，相同的描述会被视为同一个</li></ul><p>【应用】</p><ul><li>程序中的唯一标识符（代替状态常量）</li><li>类中私有属性/方法，不会被外部api访问</li></ul><h2 id="13-类型转换"><a class="markdownIt-Anchor" href="#13-类型转换"></a> 1.3 类型转换</h2><ul><li>Number()</li><li>parseInt() / parseInt(object,base)[指定底数]</li><li>parseFloat()</li><li>toString() / toString(base)[数值转换字符串指定底数]</li><li>valueOf()</li><li>String()</li></ul><h3 id="131-显式类型转换"><a class="markdownIt-Anchor" href="#131-显式类型转换"></a> 1.3.1 显式类型转换</h3><p>明确调用某些方法：</p><ul><li>Number()</li><li>parseInt()</li><li>String()</li><li>Boolean()</li></ul><h3 id="132-隐式类型转换"><a class="markdownIt-Anchor" href="#132-隐式类型转换"></a> 1.3.2 隐式类型转换</h3><ul><li>比较运算（==、!=、&gt;、&lt;）、if、while需要布尔值地方</li><li>算术运算（+、-、*、/、%）</li></ul><h2 id="14-相等性比较与拷贝"><a class="markdownIt-Anchor" href="#14-相等性比较与拷贝"></a> 1.4 相等性比较与拷贝</h2><h3 id="141-与"><a class="markdownIt-Anchor" href="#141-与"></a> 1.4.1 == 与 ===</h3><p>两边类型不同的时候，<code>==</code>会先进行类型转换再进行比较，但是<code>===</code>会同时检查类型和值</p><p><code>Object.is(a,b)</code>行为基本上与<code>===</code>一致，除了正负0判断和NaN判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span>;           <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>)    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>          <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="142-深拷贝和浅拷贝"><a class="markdownIt-Anchor" href="#142-深拷贝和浅拷贝"></a> 1.4.2 深拷贝和浅拷贝</h3><h4 id="1421-浅拷贝"><a class="markdownIt-Anchor" href="#1421-浅拷贝"></a> 1.4.2.1 浅拷贝</h4><p>拷贝时只拷贝一层，即基本类型拷贝一份精确复制，对于引用对象类型拷贝一份内存地址，深层的引用共享相同的内存地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> newobj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(prop))&#123;</span><br><span class="line">            newobj[prop] = obj[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【存在浅拷贝现象的方法】</p><ul><li><code>Object.assign</code>：将源对象赋值合并给目标对象，并返回合并后目标对象的值  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, ...sources)</span><br></pre></td></tr></table></figure></li><li><code>Array.prototype.slice()</code>, <code>Array.prototype.concat()</code></li><li>使用拓展运算符实现的复制  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> narr = [...arr];</span><br><span class="line">narr[<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(narr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure></li></ul><h4 id="1422-深拷贝"><a class="markdownIt-Anchor" href="#1422-深拷贝"></a> 1.4.2.2 深拷贝</h4><p>开辟一个栈，把所有属性都严格拷贝一份。因此改变一个对象的属性值不会影响另一个对象的属性值。</p><p>【实现方式】</p><ul><li><code>_.cloneDeep()</code>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = _.<span class="title function_">cloneDeep</span>(obj1);</span><br></pre></td></tr></table></figure></li><li><code>jQuery.extend()</code></li><li><code>Json.stringify()</code></li><li>手写  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="comment">//只拷贝对象</span></span><br><span class="line">    <span class="keyword">if</span>(!obj || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> newobj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)?[]:&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(prop))&#123;</span><br><span class="line">            newobj = (<span class="keyword">typeof</span> obj[prop] === <span class="string">&#x27;object&#x27;</span>)?<span class="title function_">deepCopy</span>(obj[prop]):obj[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newobj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="15-判断数据类型"><a class="markdownIt-Anchor" href="#15-判断数据类型"></a> 1.5 判断数据类型</h2><h3 id="151-typeof"><a class="markdownIt-Anchor" href="#151-typeof"></a> 1.5.1 typeof</h3><p>typeof会返回以下字符串：</p><ul><li><code>undefined</code></li><li><code>boolean</code></li><li><code>number</code></li><li><code>string</code></li><li><code>object</code></li><li><code>function</code>：函数理论上是一种特殊的对象，但是要区分函数和普通对象，因此有function</li><li><code>symbol</code></li></ul><p><code>typeof null</code>会返回object，认为null是一个对空对象的引用</p><p>typeof是<strong>操作符</strong>而不是函数，不需要参数，可以使用参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;ssss&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> message); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(message)) <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">95</span>) <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>【手写typeof】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">typeof</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>,-<span class="number">1</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="152-instanceof"><a class="markdownIt-Anchor" href="#152-instanceof"></a> 1.5.2 instanceof</h3><p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p><p>一般格式为<code>object instanceof constructor</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Car</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> benz = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line">benz <span class="keyword">instanceof</span> <span class="title class_">Car</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">car <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">str <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>实现原理：在原型链上依次查找是否由该constructor构建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">instanceOf</span>(<span class="params">left,right</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(left === <span class="literal">null</span> || <span class="keyword">typeof</span> left != <span class="string">&quot;object&quot;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left);</span><br><span class="line">    <span class="keyword">while</span>(proto != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(proto == right.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【typeof和instanceof的区别】</p><ul><li>typeof返回字符串，告知对象类型，instanceof返回布尔值</li><li>instanceof用于判断引用对象类型，不能用于判断基础数据类型</li><li>typeof用于判断基础数据类型和function引用对象类型，无法判断具体的复杂引用对象类型</li></ul><h3 id="153-通用检测"><a class="markdownIt-Anchor" href="#153-通用检测"></a> 1.5.3 通用检测</h3><p>通用方法：<code>Object.prototype.toString()</code></p><p>【手写通用检测方法】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line">    <span class="keyword">if</span>(type != <span class="string">&quot;object&quot;</span>)<span class="keyword">return</span> type;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">replace</span>(<span class="regexp">/^\[object (\S+)\]$/</span>,<span class="string">&#x27;$1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-数据结构"><a class="markdownIt-Anchor" href="#2-数据结构"></a> 2 数据结构</h1><h2 id="21-set"><a class="markdownIt-Anchor" href="#21-set"></a> 2.1 set</h2><ul><li><code>add(a)</code></li><li><code>delete(a)</code></li><li><code>has(a)</code></li><li><code>clear()</code><br />keys()：返回键名的遍历器<br />values()：返回键值的遍历器<br />entries()：返回键值对的遍历器<br />forEach()：使用回调函数遍历每个成员</li></ul><h3 id="weakset"><a class="markdownIt-Anchor" href="#weakset"></a> weakset</h3><h2 id="22-map"><a class="markdownIt-Anchor" href="#22-map"></a> 2.2 map</h2><p>size 属性<br />set(key,value)<br />get()<br />has()<br />delete()<br />clear()</p><h3 id="weakmap"><a class="markdownIt-Anchor" href="#weakmap"></a> weakmap</h3><h2 id="23-json"><a class="markdownIt-Anchor" href="#23-json"></a> 2.3 json</h2><h2 id="24-array"><a class="markdownIt-Anchor" href="#24-array"></a> 2.4 array</h2><h3 id="241-数组修改操作"><a class="markdownIt-Anchor" href="#241-数组修改操作"></a> 2.4.1 数组修改操作</h3><ul><li><code>push(a,b,...)</code>：在末尾追加任意多个值</li><li><code>unshift(a,b,...)</code>：在开头插入任意多个值（开头保持unshift参数顺序）</li><li><code>concat(a,b,...)</code>：将数组拼接在一起，返回拼接后的新数组，不影响原来的数组</li><li><code>pop()</code>：删除数组的最后一项</li><li><code>shift()</code>：删除数组的第一项</li></ul><p>【splice和slice】</p><ul><li><code>slice(start,end)</code>：对原数组不产生影响，返回[start,end)这一段的数组，如果不指定end，默认到数组结尾</li><li><code>splice(start,len,a,b,...)</code>：对原数组产生影响，从start位置开始，删除掉len个元素，然后在该位置继续插入后续的元素。返回被移除的元素数组。</li></ul><h3 id="242-数组查询操作"><a class="markdownIt-Anchor" href="#242-数组查询操作"></a> 2.4.2 数组查询操作</h3><ul><li><code>indexOf(a)</code>：返回某个数的下标，如果不存在返回-1</li><li><code>includes(a)</code>：是否包含某个元素，返回true/false</li><li><code>find(func)</code>：返回满足func的第一个元素  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">43</span>,<span class="number">24</span>];</span><br><span class="line">arr.<span class="title function_">find</span>(<span class="function">(<span class="params">el</span>)=&gt;</span>el &gt; <span class="number">28</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="243-排序"><a class="markdownIt-Anchor" href="#243-排序"></a> 2.4.3 排序</h3><ul><li><code>reverse()</code>：对数组进行翻转</li><li><code>sort(func)</code>：按照提供的规则进行函数排序  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cmp</span>(<span class="params">value1,value2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(value1 &lt; value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value1 &gt; value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="244-遍历"><a class="markdownIt-Anchor" href="#244-遍历"></a> 2.4.4 遍历</h3><ul><li><code>some(func)</code>：如果有元素满足func条件，返回true</li><li><code>every(func)</code>：如果所有元素满足func条件，返回true</li><li><code>forEach(func)</code>：对每一个元素运行函数，没有返回值</li><li><code>filter(func)</code>：返回满足筛选函数的数组</li><li><code>map(func)</code>：返回每个函数经过func操作后的数组</li></ul><p>对于数组遍历，<code>for in</code>绑定下标，<code>for of</code>才是绑定元素</p><h3 id="245-arrayprototype方法重写"><a class="markdownIt-Anchor" href="#245-arrayprototype方法重写"></a> 2.4.5 Array.prototype方法重写</h3><h4 id="2451-flat"><a class="markdownIt-Anchor" href="#2451-flat"></a> 2.4.5.1 flat</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">flat</span> = <span class="keyword">function</span>(<span class="params">deep = <span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    deep--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> val <span class="keyword">of</span> <span class="variable language_">this</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(val) &amp;&amp; deep &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            res = res.<span class="title function_">concat</span>(val.<span class="title function_">flat</span>(deep));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.<span class="title function_">push</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2452-map"><a class="markdownIt-Anchor" href="#2452-map"></a> 2.4.5.2 map</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="variable language_">this</span>.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        res.<span class="title function_">push</span>(<span class="title function_">callback</span>(<span class="variable language_">this</span>[i],i,<span class="variable language_">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-control-flow"><a class="markdownIt-Anchor" href="#3-control-flow"></a> 3 control flow</h1><h2 id="31-loops-iterators"><a class="markdownIt-Anchor" href="#31-loops-iterators"></a> 3.1 loops &amp; iterators</h2><h3 id="for-in-vs-for-of"><a class="markdownIt-Anchor" href="#for-in-vs-for-of"></a> for in VS for of</h3><p>for in 遍历对象中所有属性，包括原型属性。如果是数组的话按照index遍历</p><p>for of 遍历数组元素值，不能遍历对象</p><h2 id="32-branches"><a class="markdownIt-Anchor" href="#32-branches"></a> 3.2 branches</h2><h1 id="4-函数"><a class="markdownIt-Anchor" href="#4-函数"></a> 4 函数</h1><h2 id="41-普通函数和箭头函数"><a class="markdownIt-Anchor" href="#41-普通函数和箭头函数"></a> 4.1 普通函数和箭头函数</h2><ul><li>箭头函数都是匿名函数，普通函数可以是匿名函数</li><li>箭头函数不能用于构造器，不能用于new</li><li>箭头函数没有this，箭头函数中的this都指向函数上下文，使用call，bind，apply也没有办法改变指向</li><li>箭头函数中不含有arguments形参数组，但是可以使用上下文中的形参数组</li></ul><h2 id="42-参数"><a class="markdownIt-Anchor" href="#42-参数"></a> 4.2 参数</h2><h3 id="421-剩余参数"><a class="markdownIt-Anchor" href="#421-剩余参数"></a> 4.2.1 剩余参数</h3><p>使用<code>...</code>，将传入不定数量的元素集合成一个数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">v1,v2,...arr</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩余参数必须是最后一个参数。</p><h3 id="422-arguments数组"><a class="markdownIt-Anchor" href="#422-arguments数组"></a> 4.2.2 arguments数组</h3><p>arguments和函数的参数同步，修改函数参数值就是修改arguments对应元素。</p><p>如果不传参，默认为undefined</p><h2 id="43-闭包"><a class="markdownIt-Anchor" href="#43-闭包"></a> 4.3 闭包</h2><p>一个函数被其引用的状态包围在一起，函数被引用包围</p><h3 id="431-优缺点"><a class="markdownIt-Anchor" href="#431-优缺点"></a> 4.3.1 优缺点</h3><p>【优点】保护函数内变量的安全，封装降低耦合</p><p>【缺点】容易造成内存泄漏，内存浪费问题</p><h3 id="432-适用场景"><a class="markdownIt-Anchor" href="#432-适用场景"></a> 4.3.2 适用场景</h3><ul><li>设计一些私有方法和变量</li><li>延长变量的生命周期</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 柯里化函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">width</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">height</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> getAreaByTen = <span class="title function_">getArea</span>(<span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getAreaByTen</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装一个计数器counter</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Counter</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> privateCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">changeBy</span>(<span class="params">val</span>)&#123;</span><br><span class="line">        privateCount += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">increment</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">changeBy</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">decrement</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">changeBy</span>(-<span class="number">1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">value</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> privateCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count1 = <span class="title class_">Counter</span>();</span><br><span class="line">count1.<span class="title function_">increment</span>();</span><br><span class="line">count1.<span class="title function_">increment</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count1.<span class="title function_">value</span>()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="44-作用域"><a class="markdownIt-Anchor" href="#44-作用域"></a> 4.4 作用域</h2><p>块级，函数级，全局作用域级</p><p>【作用域链】<br />从最内部的块级/函数级作用域开始，向外部寻找</p><h1 id="5-事件"><a class="markdownIt-Anchor" href="#5-事件"></a> 5 事件</h1><h2 id="51-事件与事件流"><a class="markdownIt-Anchor" href="#51-事件与事件流"></a> 5.1 事件与事件流</h2><p>javascript中的事件，可以理解就是在HTML文档或者浏览器中发生的一种交互操作，使得网页具备互动性， 常见的有加载事件、鼠标事件、自定义事件等</p><p>包括事件和事件流。事件流的产生是因为父子结点执行事件存在顺序问题。</p><p>【事件流的三个阶段】</p><ol><li>事件捕获阶段(capture phase)</li><li>处于目标阶段(target phase)/事件处理阶段</li><li>事件冒泡阶段(bubbling phase)：从子节点依次上传直到DOM根节点</li></ol><h2 id="52-事件模型"><a class="markdownIt-Anchor" href="#52-事件模型"></a> 5.2 事件模型</h2><ul><li>原始事件模型（DOM0级）：标签/js直接绑定，绑定速度快，支持冒泡不支持捕获，不能重复绑定（只能绑定一次）</li><li>标准事件模型（DOM2级）：事件流  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage, <span class="literal">false</span>);</span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(‘click’, showMessage, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li>允许绑定多个事件处理器</li><li>第三个参数设为true，允许捕获阶段执行，false冒泡阶段执行</li></ul></li><li>IE事件模型（基本不用）：只有事件处理阶段和冒泡阶段</li></ul><h2 id="53-事件循环"><a class="markdownIt-Anchor" href="#53-事件循环"></a> 5.3 事件循环</h2><p>任务分为同步任务和异步任务。</p><p>同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。</p><p><a href="https://juejin.cn/post/7020710294083092493">事件循环详解</a></p><h3 id="531-微任务和宏任务"><a class="markdownIt-Anchor" href="#531-微任务和宏任务"></a> 5.3.1 微任务和宏任务</h3><p>异步任务划分为宏任务和微任务。以下宏任务和微任务的划分是在浏览器中的划分，node.js的划分是不同的。</p><p>【宏任务】</p><ul><li><code>setTimeout()</code></li><li><code>setInterval()</code></li></ul><p>【微任务】</p><ul><li><code>promise.then()</code></li><li><code>async/await</code></li><li><code>new MutationObserver()</code></li></ul><p>同步任务执行完毕后，会先查看微任务队列，当微任务队列执行完毕后才会去查看调用宏任务队列。</p><h3 id="532-async-await"><a class="markdownIt-Anchor" href="#532-async-await"></a> 5.3.2 async &amp; await</h3><p>async就是用来声明一个异步方法，而 await是用来等待异步方法执行</p><p>await相当于生成一个promise，await紧接的内容放入promise中，进入微任务队列，而await语句后的语句被阻塞，相当于放入了promise.then的微任务队列。</p><h4 id="5321-async"><a class="markdownIt-Anchor" href="#5321-async"></a> 5.3.2.1 async</h4><p>async函数返回一个promise对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;TEST&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// asyncF is equivalent to f!</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncF</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;TEST&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5322-await"><a class="markdownIt-Anchor" href="#5322-await"></a> 5.3.2.2 await</h4><p>await后面接一个promise对象，返回这个对象的结果</p><h2 id="54-异步promise"><a class="markdownIt-Anchor" href="#54-异步promise"></a> 5.4 异步&amp;promise</h2><h3 id="541-promise状态"><a class="markdownIt-Anchor" href="#541-promise状态"></a> 5.4.1 promise状态</h3><ul><li>pending（进行中）</li><li>fulfilled（已成功）</li><li>rejected（已失败）</li></ul><h3 id="542-promise方法"><a class="markdownIt-Anchor" href="#542-promise方法"></a> 5.4.2 promise方法</h3><p>【promise.all】</p><p>并发同时开始执行promise序列，只有全部成功返回全部的成功信息数组，否则被catch捕获error</p><p>一些异步的结果输出看<a href="https://juejin.cn/post/6959043611161952269">这篇</a></p><h2 id="55-事件代理"><a class="markdownIt-Anchor" href="#55-事件代理"></a> 5.5 事件代理</h2><p>把一个元素响应事件（click、keydown…）的函数委托到另一个元素，在冒泡阶段完成。事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素</p><h2 id="56-settimeout"><a class="markdownIt-Anchor" href="#56-settimeout"></a> 5.6 setTimeout</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="built_in">setTimeout</span>(func,<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">clearTimeout</span>(id);</span><br></pre></td></tr></table></figure><p>返回一个id标识符，在<strong>大约</strong>1000ms后执行func函数（在全局作用域执行）</p><p>为什么是大约？JS是单线程，其他代码的运行可能会阻塞该进程</p><h2 id="57-setinterval"><a class="markdownIt-Anchor" href="#57-setinterval"></a> 5.7 setInterval</h2><p>每个多少毫秒执行一次。谨慎使用：回调函数进程的阻塞可能导致回调函数堆积</p><p>【使用timeout实现interval】</p><h1 id="6-类"><a class="markdownIt-Anchor" href="#6-类"></a> 6 类</h1><h2 id="61-this"><a class="markdownIt-Anchor" href="#61-this"></a> 6.1 this</h2><h3 id="611-this对象"><a class="markdownIt-Anchor" href="#611-this对象"></a> 6.1.1 this对象</h3><p>this指向函数、类内部对象，运行时自动生成。调用方式决定this对象，谁调用指向谁。</p><p>一旦确定，不能被直接更改。</p><p>【绑定规则】</p><ul><li>默认绑定：函数中调用全局变量</li><li>隐式绑定：作为函数被某个对象调用，绑定到这个对象上</li><li>new绑定：除非函数返回一个对象，否则对函数使用new时将this绑定到赋值对象上</li><li>显式绑定：使用apply\call\bind改变</li></ul><p>new绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级</p><h3 id="612-改变this指向"><a class="markdownIt-Anchor" href="#612-改变this指向"></a> 6.1.2 改变this指向</h3><p>可以使用<code>call</code>, <code>apply</code>, <code>bind</code>方法</p><h4 id="6121-call"><a class="markdownIt-Anchor" href="#6121-call"></a> 6.1.2.1 call</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.<span class="title function_">call</span>(obj,<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>call只生效一次，函数立即执行，传入参数可以不用数组括起来</p><p>【手写call】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>)&#123;</span><br><span class="line">    context = (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) ? <span class="variable language_">window</span> : context;</span><br><span class="line">    context.<span class="property">__fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result = context.<span class="title function_">__fn</span>(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">__fn</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6122-apply"><a class="markdownIt-Anchor" href="#6122-apply"></a> 6.1.2.2 apply</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.<span class="title function_">apply</span>(obj,[<span class="number">1</span>,<span class="number">2</span>]); <span class="comment">// obj是this指向的新对象，传给func的参数必须以数组形式传入</span></span><br></pre></td></tr></table></figure><p>apply只生效一次，且是临时生效，函数立即执行，执行完后绑定失效。</p><p>如果obj传入null,undefined默认指向浏览器window</p><p>【手写apply】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context,args</span>)&#123;</span><br><span class="line">    context = (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>)? <span class="attr">window</span>:context;</span><br><span class="line">    context.<span class="property">__fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result = context.<span class="title function_">__fn</span>(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">__fn</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6123-bind"><a class="markdownIt-Anchor" href="#6123-bind"></a> 6.1.2.3 bind</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = oldfunc.<span class="title function_">bind</span>(obj);</span><br></pre></td></tr></table></figure><p>bind返回一个绑定永久有效的新函数，参数传递给新函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context, ...args1</span>)&#123;</span><br><span class="line">    context = (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>)?<span class="attr">window</span>:context;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args2</span>)&#123;</span><br><span class="line">        context.<span class="property">__fn</span> = _this;</span><br><span class="line">        <span class="keyword">let</span> result = context.<span class="title function_">__fn</span>(...[...args1,...args2]);</span><br><span class="line">        <span class="keyword">delete</span> context.<span class="property">__fn</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="62-new"><a class="markdownIt-Anchor" href="#62-new"></a> 6.2 new</h2><p>new一个类：</p><ol><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象（因此this指向了这个新对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象</li></ol><p>new一个函数：</p><ol><li>创建一个新的对象obj</li><li>将对象与构建函数通过原型链连接起来</li><li>将构建函数中的this绑定到新建的对象obj上</li><li>根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理</li></ol><p>【手写new】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mynew</span>(<span class="params">Func,...args</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">    obj.<span class="property">__proto__</span> = <span class="title class_">Func</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="title class_">Func</span>.<span class="title function_">apply</span>(obj,args);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span>) ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="63-原型"><a class="markdownIt-Anchor" href="#63-原型"></a> 6.3 原型</h2><p>原型模式：设计模式，构建一个prototype负责clone新对象</p><p>每个对象都拥有一个原型，原型对应的也有自己的原型，一层层向上传递构成原型链</p><ul><li>一切对象都是继承自Object对象，Object 对象直接继承根源对象null</li><li>一切的函数对象（包括 Object 对象），都是继承自 Function 对象</li><li>Object 对象直接继承自 Function 对象</li><li>Function对象的__proto__会指向自己的原型对象，最终还是继承自Object对象</li></ul><h2 id="64-继承"><a class="markdownIt-Anchor" href="#64-继承"></a> 6.4 继承</h2><ul><li>原型链继承：将子类的prototype设为父类。问题：创建出的子类共享父类属性，修改一个会导致父类修改</li><li>构造函数继承：使用call将this强行绑定。问题：只能继承父类的实例属性和方法，无法继承prototype方法</li><li>组合以上两种继承：相当于调用了两次父类，解决以上问题但是导致性能下降</li><li>原型式继承：使用<code>Object.create()</code>，相当于浅拷贝了一份（修改属性会导致原始对象的修改）</li><li>寄生式继承：封装一个函数，其中仍然使用<code>Object.create()</code>创建对象，为这个对象添加一些方法</li><li>寄生组合式继承</li></ul><p>ES6：直接用extends</p><h1 id="7-优化"><a class="markdownIt-Anchor" href="#7-优化"></a> 7 优化</h1><h2 id="71-节流"><a class="markdownIt-Anchor" href="#71-节流"></a> 7.1 节流</h2><p>阻止一些回调函数的不断触发。</p><p>定义：<strong>n 秒内</strong>只运行一次，若在 n 秒内重复触发，只有一次生效</p><p>【手写】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn,delay</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">if</span>(now-prev &gt; delay)&#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,args);</span><br><span class="line">            prev = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="72-防抖"><a class="markdownIt-Anchor" href="#72-防抖"></a> 7.2 防抖</h2><p>定义：<strong>n 秒后</strong>在执行该事件，若在 n 秒内被重复触发，则重新计时</p><p>【手写】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">fn,delay</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,args);</span><br><span class="line">        &#125;,delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-es6-新特性"><a class="markdownIt-Anchor" href="#8-es6-新特性"></a> 8 ES6 新特性</h1><p>除了以下罗列的以外，还包括set，map，promise</p><h2 id="81-generator"><a class="markdownIt-Anchor" href="#81-generator"></a> 8.1 Generator</h2><h2 id="82-proxy"><a class="markdownIt-Anchor" href="#82-proxy"></a> 8.2 Proxy</h2><h2 id="83-module"><a class="markdownIt-Anchor" href="#83-module"></a> 8.3 Module</h2><h2 id="84-decorator"><a class="markdownIt-Anchor" href="#84-decorator"></a> 8.4 Decorator</h2><h1 id="9-js内存机制"><a class="markdownIt-Anchor" href="#9-js内存机制"></a> 9 JS内存机制</h1><h2 id="91-引用"><a class="markdownIt-Anchor" href="#91-引用"></a> 9.1 引用</h2><p>每个对象拥有一个关于原型的隐式引用，以及关于属性的显式引用</p><p>如果使用引用计数法无法解决循环引用导致的内存泄漏问题</p><h2 id="92-垃圾回收"><a class="markdownIt-Anchor" href="#92-垃圾回收"></a> 9.2 垃圾回收</h2><p>【引用计数法】</p><p>无法解决循环引用的问题。</p><p>【标记-清除算法】</p><p>从全局根开始，将无法被获取访问到的部分内存清除。</p><p>缺点：开销大，容易产生内存碎片。</p><p>改进：新生代，老生代，使用标记清除算法后把内存归拢到新生代区域</p><h2 id="93-内存泄露"><a class="markdownIt-Anchor" href="#93-内存泄露"></a> 9.3 内存泄露</h2><p>程序未能释放且不能再被使用的内存</p><ul><li>意外的全局变量：在函数中使用全局变量或者用this创建全局变量（解决方案：使用严格模式）  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    bar = <span class="string">&quot;this is a hidden global variable&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">variable</span> = <span class="string">&quot;potential accidental global&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 调用自己，this 指向了全局对象（window）</span></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure></li><li>定时器：获取到的元素在dom中被删除，但是定时器仍然存在，定时器拥有的资源不会被释放  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = <span class="title function_">getData</span>();</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;Node&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        <span class="comment">// 处理 node 和 someResource</span></span><br><span class="line">        node.<span class="property">innerHTML</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(someResource);<span class="comment">// someResource不会被释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li><li>闭包：闭包内使用的引用导致不会释放  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bindEvent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;XXX&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> unused = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj, <span class="string">&#x27;闭包内引用obj obj不会被释放&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    obj = <span class="literal">null</span>; <span class="comment">// 解决方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>没有清理对dom元素的引用：dom元素在被删除后还存在对其的引用  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refA = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;refA&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(refA); <span class="comment">// dom删除了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(refA, <span class="string">&#x27;refA&#x27;</span>); <span class="comment">// 但是还存在引用能console出整个div 没有被回收</span></span><br><span class="line">refA = <span class="literal">null</span>; <span class="comment">// 解决办法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(refA, <span class="string">&#x27;refA&#x27;</span>); <span class="comment">// 解除引用</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="94-存储方式"><a class="markdownIt-Anchor" href="#94-存储方式"></a> 9.4 存储方式</h2><h3 id="941-cookie"><a class="markdownIt-Anchor" href="#941-cookie"></a> 9.4.1 cookie</h3><p>保持登陆状态 =&gt; http无状态</p><p>cookie在每次请求中都会被发送</p><p>每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb</p><p>【cookie安全】</p><p>带有secure属性只能被https协议发送。如果带有httponly属性不能被js操纵，只能是服务端cookie</p><p>【过期时间】</p><p>不设置默认为会话周期，即浏览器关闭后cookie失效</p><p>max-age以秒为单位，区别于http的max-age，http以正负表示</p><p>【总结-cookie字段】</p><h3 id="942-localstorage"><a class="markdownIt-Anchor" href="#942-localstorage"></a> 9.4.2 localStorage</h3><p>不会过期，每个域5MB</p><p>【存满了之后？】</p><ul><li>报错 try-catch</li><li>使用其他域的存储空间</li><li>使用一些淘汰机制？</li></ul><h3 id="943-sessionstorage"><a class="markdownIt-Anchor" href="#943-sessionstorage"></a> 9.4.3 sessionStorage</h3><p>当前会话结束后即被清除，每个域5MB</p><p>【跨标签页同源sessionStorage访问】</p><p>使用localStorage？</p><h3 id="944-变量堆栈存储"><a class="markdownIt-Anchor" href="#944-变量堆栈存储"></a> 9.4.4 变量堆栈存储</h3><ul><li>局部变量存储在栈中，如果是对象，栈中存储对象的引用</li><li>全局变量和被捕获变量都存在堆中</li></ul><p>总结：除了局部变量，其他的都存储在堆中。</p><h1 id="10-严格模式"><a class="markdownIt-Anchor" href="#10-严格模式"></a> 10 严格模式</h1><h2 id="101-设置严格模式的目的"><a class="markdownIt-Anchor" href="#101-设置严格模式的目的"></a> 10.1 设置严格模式的目的</h2><ul><li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的Javascript做好铺垫。</li></ul><h2 id="102-使用方式"><a class="markdownIt-Anchor" href="#102-使用方式"></a> 10.2 使用方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="11-dom"><a class="markdownIt-Anchor" href="#11-dom"></a> 11 DOM</h1><h2 id="111-window"><a class="markdownIt-Anchor" href="#111-window"></a> 11.1 window</h2><p>高度：innerheight, outerheight</p><p><a href="https://zhuanlan.zhihu.com/p/141845423">https://zhuanlan.zhihu.com/p/141845423</a></p><h2 id="112-图片懒加载"><a class="markdownIt-Anchor" href="#112-图片懒加载"></a> 11.2 图片懒加载</h2><h3 id="1121-手动获取图片是否显示"><a class="markdownIt-Anchor" href="#1121-手动获取图片是否显示"></a> 11.2.1 手动获取图片是否显示</h3><h3 id="1122-intersectobservable"><a class="markdownIt-Anchor" href="#1122-intersectobservable"></a> 11.2.2 IntersectObservable</h3><h1 id="q-a"><a class="markdownIt-Anchor" href="#q-a"></a> Q &amp; A</h1><ol><li>let/const/var区别<br />见1.1节</li><li>js有哪些数据类型<br />见1.2节</li><li>数据类型判断<ul><li>1.2.1节typeof</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-数据类型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-数据类型&quot;&gt;&lt;/a&gt; 1 数据类型&lt;/h1&gt;
&lt;h2 id=&quot;11-letconstvar&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11-</summary>
      
    
    
    
    <category term="Technology" scheme="https://aliceraylu.github.io/categories/Technology/"/>
    
    <category term="Frontend" scheme="https://aliceraylu.github.io/categories/Technology/Frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>c++复习总结</title>
    <link href="https://aliceraylu.github.io/2024/02/26/knowledge/c++/c++%E9%AB%98%E7%A8%8B/"/>
    <id>https://aliceraylu.github.io/2024/02/26/knowledge/c++/c++%E9%AB%98%E7%A8%8B/</id>
    <published>2024-02-25T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.447Z</updated>
    
    <content type="html"><![CDATA[<p>原始的课堂笔记丢了，本文档补充记录一些复习重点。</p><h1 id="c981114特性"><a class="markdownIt-Anchor" href="#c981114特性"></a> c++98/11/14特性</h1><ul><li>98：最初版本的c++，包括STL等</li><li>11：重大更新，包括auto/for/lambda/智能指针/nullptr/template等</li><li>14：型 Lambda 表达式、返回类型推导、二进制字面量、数字分隔符、弃用属性</li><li>17：结构化绑定、if constexpr、std::optional、std::variant、std::string_view、并行算法</li></ul><h1 id="difference-between-cc"><a class="markdownIt-Anchor" href="#difference-between-cc"></a> difference between c/c++</h1><ul><li>c++ has OOP &amp; template</li><li>c++ use <code>new</code> &amp; <code>delete</code> instead of <code>malloc</code> and <code>free</code></li><li>c++ has smart pointers which are safer</li><li>c++ allows function overload</li></ul><h1 id="inline-define-template"><a class="markdownIt-Anchor" href="#inline-define-template"></a> inline &amp; define &amp; template</h1><h2 id="inline"><a class="markdownIt-Anchor" href="#inline"></a> inline</h2><p>实际调用的时候，把inline函数放回原来的位置，不会产生参数的传递，在汇编上也不会有其他的冗余操作，编译系统将为inline函数创建一段代码，在调用点，以相应的代码替换</p><p>【作用】</p><ul><li>增加程序<strong>可读性</strong></li><li>提高程序<strong>运行效率</strong></li><li>补充宏定义不能进行<strong>类型检查</strong>的缺陷</li></ul><p>【问题】</p><ul><li>增大目标代码</li><li>病态换页（内存抖动）</li><li>降低指令快取装置的命中率</li></ul><p>【建议】</p><ul><li>使用<strong>频率高的小代码</strong>内联</li><li>内联函数定义放在头文件中</li><li>不含有复杂的结构控制</li><li>不允许递归做内联函数</li></ul><h2 id="宏"><a class="markdownIt-Anchor" href="#宏"></a> 宏</h2><p>宏包括<code>#define</code>，<code>#ifndef ... #endif</code>（避免重复定义头文件）, <code>#ifdef .. #else .. #endif</code>(条件宏)，<code>#undef</code>取消宏</p><p>在编译阶段进行简单的文本替换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXT 999</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> add(x,y) x+y</span></span><br></pre></td></tr></table></figure><h2 id="inline和define"><a class="markdownIt-Anchor" href="#inline和define"></a> inline和define</h2><ul><li>#define没有类型，相当于是泛型，可能导致出现漏洞</li><li>inline类型写死</li></ul><h2 id="template"><a class="markdownIt-Anchor" href="#template"></a> template</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板的实例化：显式实例化、隐式实例化、特化</p><p>【define与template】<br />define仅仅是字符串替换，不含类型检查</p><h1 id="const"><a class="markdownIt-Anchor" href="#const"></a> const</h1><p>参考这篇博客的<a href="https://blog.csdn.net/eric_jo/article/details/4138548">总结</a></p><h2 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h2><p><code>const int t = 1</code>或者<code>int const t = 1</code>是一样的，都表示一个常量，必须声明时赋值</p><p><code>extended const int t = 1</code>使用extended可以不进行初始化，变量作用于扩大至全局,编译时会分配内存</p><h2 id="指针常量和常量指针"><a class="markdownIt-Anchor" href="#指针常量和常量指针"></a> 指针常量和常量指针</h2><p><code>const char* p</code>：指针指向的内容不可变</p><p><code>char* const p</code>：指针本身是常量不可变</p><p><code>const char* const p</code>：指针本身不可变且指向的内容不可变</p><h2 id="函数中使用"><a class="markdownIt-Anchor" href="#函数中使用"></a> 函数中使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// as parameter</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; t)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// as return value</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="title">func</span><span class="params">(<span class="type">int</span> t)</span></span></span><br></pre></td></tr></table></figure><h2 id="类中使用"><a class="markdownIt-Anchor" href="#类中使用"></a> 类中使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const attribute: can&#x27;t change</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x):<span class="built_in">t</span>(x)&#123;</span><br><span class="line">        <span class="comment">// can only be initialized this way</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="type">const</span></span>;<span class="comment">// member function with const: can&#x27;t change any attribute variable &amp; can&#x27;t use non-const function &amp; can access const attribute</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// const class: can&#x27;t use any not const function</span></span><br><span class="line"><span class="type">const</span> A aaa;</span><br><span class="line">aaa.<span class="built_in">func</span>(); <span class="comment">//correct</span></span><br></pre></td></tr></table></figure><h2 id="const转为非const类型"><a class="markdownIt-Anchor" href="#const转为非const类型"></a> const转为非const类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(p);<span class="comment">// 通常用于指针</span></span><br></pre></td></tr></table></figure><h1 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h1><h2 id="指针和引用"><a class="markdownIt-Anchor" href="#指针和引用"></a> 指针和引用</h2><p>the difference between pointer and reference</p><ul><li>pointer is an address, reference is an alias which is the same as the original variable(sizeof)</li><li>pointers can point to pointers, but reference can’t</li><li>pointers can be initialized later, but reference must be initialized while declaring.</li><li>pointers can point to NULL, reference can’t</li><li>pointers can be changed, but reference can’t</li></ul><h2 id="智能指针"><a class="markdownIt-Anchor" href="#智能指针"></a> 智能指针</h2><p>RAII：Resource Acquisition Is Initialization</p><h1 id="左值和右值"><a class="markdownIt-Anchor" href="#左值和右值"></a> 左值和右值</h1><h1 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h1><h2 id="普通继承与虚继承"><a class="markdownIt-Anchor" href="#普通继承与虚继承"></a> 普通继承与虚继承</h2><h2 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h2><h3 id="拷贝构造函数"><a class="markdownIt-Anchor" href="#拷贝构造函数"></a> 拷贝构造函数</h3><h3 id="explicit"><a class="markdownIt-Anchor" href="#explicit"></a> explicit</h3><p>forbid implicit type conversion</p><h2 id="析构函数"><a class="markdownIt-Anchor" href="#析构函数"></a> 析构函数</h2><h2 id="操作符重载"><a class="markdownIt-Anchor" href="#操作符重载"></a> 操作符重载</h2><h2 id="覆盖与重载"><a class="markdownIt-Anchor" href="#覆盖与重载"></a> 覆盖与重载</h2><p>【覆盖】</p><p>子类中重写覆盖父类中的方法，必须严格继承父类方法的名字、参数类型、返回值。</p><p>【重载】</p><p>仅仅函数名相同，参数类型不同。重载的函数必须在同样的范围中。</p><h1 id="c多态"><a class="markdownIt-Anchor" href="#c多态"></a> c++多态</h1><p>分为<strong>静态多态</strong>和<strong>动态多态</strong></p><p>【静态多态】主要表现为<strong>函数重载</strong>，编译时即确定函数类型</p><p>【动态多态】主要表现为<strong>虚函数</strong>，在程序运行时才确定参数类型（相关概念：纯虚函数、抽象类）</p><h1 id="虚函数"><a class="markdownIt-Anchor" href="#虚函数"></a> 虚函数</h1><h2 id="静态动态绑定"><a class="markdownIt-Anchor" href="#静态动态绑定"></a> 静态/动态绑定</h2><p>动态绑定：编译器在编译阶段不知道对象的实际类型，在运行时才能确定</p><h2 id="纯虚函数"><a class="markdownIt-Anchor" href="#纯虚函数"></a> 纯虚函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h2><p>a class that can’t be instantiated. Must include at least <strong>one pure virtual function</strong>.</p><h1 id="stack-heap"><a class="markdownIt-Anchor" href="#stack-heap"></a> stack &amp; heap</h1><p>【栈】</p><p>由编译器自动分配管理释放，用来存储函数参数和局部变量，从高地址向低地址增长。栈的大小是有限的。</p><p>【堆】</p><p>由程序员管理分配和释放，用来存放程序中的动态内存，程序结束由操作系统自动回收，从低地址向高地址生长。堆的大小相对较大，内存分配方式比较灵活。但是容易产生内存碎片。</p><h1 id="struct"><a class="markdownIt-Anchor" href="#struct"></a> struct</h1><h2 id="struct-class"><a class="markdownIt-Anchor" href="#struct-class"></a> struct &amp; class</h2><h2 id="struct内存"><a class="markdownIt-Anchor" href="#struct内存"></a> struct内存</h2><h2 id="struct-union"><a class="markdownIt-Anchor" href="#struct-union"></a> struct &amp; union</h2><h1 id="how-to-optimize-performance"><a class="markdownIt-Anchor" href="#how-to-optimize-performance"></a> how to optimize performance</h1><ul><li>compile options: <code>-O2</code> <code>-O3</code></li><li>avoid useless memory operation like <code>new</code> <code>delete</code></li><li>choose better data structure and algorithm</li><li>use multi-thread</li><li>use inline function and const expression</li><li>use smart pointer</li></ul><h1 id="static"><a class="markdownIt-Anchor" href="#static"></a> static</h1><ul><li>hide global variable or global function：make it only visible in the source file</li><li>keep variable longer</li><li>In Class:<ul><li>static variable: shared among all the instances</li><li>static member function: can be accessed without instanciate a class(can only visit static variables)</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原始的课堂笔记丢了，本文档补充记录一些复习重点。&lt;/p&gt;
&lt;h1 id=&quot;c981114特性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#c981114特性&quot;&gt;&lt;/a&gt; c++98/11/14特性&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;98：最初版本的c</summary>
      
    
    
    
    <category term="Knowledge" scheme="https://aliceraylu.github.io/categories/Knowledge/"/>
    
    <category term="C++" scheme="https://aliceraylu.github.io/categories/Knowledge/C/"/>
    
    
  </entry>
  
  <entry>
    <title>算法复习框架</title>
    <link href="https://aliceraylu.github.io/2024/01/19/knowledge/algorithm/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%E6%A1%86%E6%9E%B6/"/>
    <id>https://aliceraylu.github.io/2024/01/19/knowledge/algorithm/%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0%E6%A1%86%E6%9E%B6/</id>
    <published>2024-01-18T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.445Z</updated>
    
    <content type="html"><![CDATA[<p>本文档总结了非ACMer应知应会基础算法cpp版本，不涉及算法详解，适合（保研机考/找实习）复习框架使用。</p><p>大部分资料来源与互联网各大佬的总结与整理，此处作为复习整合。此外非常感谢学长提供的算法模板手册！</p><blockquote><p>施工建设中……</p></blockquote><h1 id="0-program-basic"><a class="markdownIt-Anchor" href="#0-program-basic"></a> 0 program basic</h1><p>以下是<code>c++</code>语言基础部分参考复习</p><h2 id="01-万能头"><a class="markdownIt-Anchor" href="#01-万能头"></a> 0.1 万能头</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="02-输入输出处理"><a class="markdownIt-Anchor" href="#02-输入输出处理"></a> 0.2 输入输出处理</h2><ul><li><code>cin/cout</code></li><li><code>getline(cin, str, '\n')</code>：默认读入一行，可以更换截断字符<br />读取不定行数：<code>while(getline(...))</code></li></ul><h3 id="021-输出保留小数位数"><a class="markdownIt-Anchor" href="#021-输出保留小数位数"></a> 0.2.1 输出保留小数位数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a=<span class="number">46.21534</span>,b=<span class="number">1.20001</span>;</span><br><span class="line">cout.<span class="built_in">setf</span>(ios::fixed);    <span class="comment">// 打开fixed功能，功能和下一行的fixed功能一样，同时写没关系</span></span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; b &lt;&lt; endl;      <span class="comment">//输出结果为1.20</span></span><br><span class="line">cout.<span class="built_in">unsetf</span>(ios::fixed); <span class="comment">// 关闭fixed功能，如果不关闭会一直保持</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; b &lt;&lt; endl;   <span class="comment">//不含fixed，保持小数点前的位数，输出1.2</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; a &lt;&lt; endl;    <span class="comment">//46.215</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; a &lt;&lt; endl;  <span class="comment">//5e+001</span></span><br></pre></td></tr></table></figure><h3 id="022-int-string互转"><a class="markdownIt-Anchor" href="#022-int-string互转"></a> 0.2.2 int string互转</h3><p>【int-&gt;string】</p><ul><li><code>to_string(int)</code></li><li><code>ostringstream</code>：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ostringstream ss;</span><br><span class="line">ss &lt;&lt; num;</span><br><span class="line">cout &lt;&lt; ss.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure></li></ul><p>【string-&gt;int】</p><ul><li><code>istringstream</code></li><li><code>atoi(str)</code></li></ul><h3 id="023-string操作"><a class="markdownIt-Anchor" href="#023-string操作"></a> 0.2.3 string操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">s.<span class="built_in">insert</span>(pos,args); <span class="comment">// 在pos后插入</span></span><br><span class="line">s.<span class="built_in">erase</span>(pos,len); <span class="comment">// 删除pos开始的len个字符，如果没有len删除至末尾</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="03-stdsort踩坑记录"><a class="markdownIt-Anchor" href="#03-stdsort踩坑记录"></a> 0.3 std::sort踩坑记录</h2><p>在使用排序的过程中我们通常为了省时省力会选择使用c++库中提供的sort函数，重载compare来进行。众所周知sort底层原理是快速排序，但是实际上的情况不尽如此。</p><p>在使用sort排序一个大数组时，我碰到了如下问题：</p><blockquote><p>AddressSanitizer: heap-buffer-overflow on address 0x7f6fbd3a47e8</p></blockquote><p>网上查阅<a href="https://cloud.tencent.com/developer/article/1877661">相关资料</a>得知，原来是因为compare重载时，两个数出现<code>==</code>的情况也返回了true，这就导致出现循环相等的情况。因此，在大数组排序时，出现相等元素一定不能cmp函数返回true。</p><h2 id="04-文件输入输出"><a class="markdownIt-Anchor" href="#04-文件输入输出"></a> 0.4 文件输入输出</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法打开文件：&quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(file, line)) &#123;</span><br><span class="line">        std::cout &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法打开文件：&quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string text = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    file &lt;&lt; text &lt;&lt; std::endl; <span class="comment">// 写入字符串</span></span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="function">std::fstream <span class="title">file</span><span class="params">(filename, std::ios::in | std::ios::out)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法打开文件：&quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入字符串</span></span><br><span class="line">    std::string text = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    file &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动到文件开头</span></span><br><span class="line">    file.<span class="built_in">seekg</span>(<span class="number">0</span>); <span class="comment">// 设置文件读指针位置到文件开头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取字符串</span></span><br><span class="line">    std::string readText;</span><br><span class="line">    std::<span class="built_in">getline</span>(file, readText);</span><br><span class="line">    std::cout &lt;&lt; readText &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="05-java"><a class="markdownIt-Anchor" href="#05-java"></a> 0.5 java</h2><p>从以下部分开始是java的基础处理部分</p><h3 id="051-输入输出"><a class="markdownIt-Anchor" href="#051-输入输出"></a> 0.5.1 输入输出</h3><p>使用scanner可以方便处理命令行输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> sc.nextFloat();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(sc.hasNextLine())&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>System.out.print</code>或者<code>System.out.println</code>可以输出，输出格式规则和c语言<code>printf</code>相同。</p><h3 id="052-文件"><a class="markdownIt-Anchor" href="#052-文件"></a> 0.5.2 文件</h3><p><code>File</code>类相关的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">    file.createNewFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0521-读取文件"><a class="markdownIt-Anchor" href="#0521-读取文件"></a> 0.5.2.1 读取文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Scanner</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(file,<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 防止出现中文乱码</span></span><br><span class="line"><span class="comment">// 然后就可以按照scanner的使用方式nextLine等方式使用</span></span><br><span class="line"><span class="keyword">while</span>(in.hasNextLine())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用bufferedReader</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bfReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line = bfReader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0522-写入文件"><a class="markdownIt-Anchor" href="#0522-写入文件"></a> 0.5.2.2 写入文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用PrintWriter</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(file, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// 以下三种方式都是直接覆盖原文件</span></span><br><span class="line">pw.print(...);</span><br><span class="line">pw.append(...);</span><br><span class="line">pw.write(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用FileWriter</span></span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">bw.write(...);</span><br><span class="line">bw.close();</span><br><span class="line">fw.close(); </span><br><span class="line"><span class="comment">// 注意关闭顺序，一定要先关闭输出流再关闭文件，否则文件无法保存</span></span><br></pre></td></tr></table></figure><p>以上方法都会重写原文件，即覆盖原文件</p><p>【追加写入】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file,<span class="literal">true</span>);</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">osw.write(...);</span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">true</span>); <span class="comment">// 表示追加</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">bw.write(...);</span><br></pre></td></tr></table></figure><h4 id="0523-junit相关文件比较"><a class="markdownIt-Anchor" href="#0523-junit相关文件比较"></a> 0.5.2.3 junit相关文件比较</h4><h3 id="053-string操作"><a class="markdownIt-Anchor" href="#053-string操作"></a> 0.5.3 string操作</h3><h4 id="0531-string和int互转"><a class="markdownIt-Anchor" href="#0531-string和int互转"></a> 0.5.3.1 string和int互转</h4><p>string -&gt; int：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(s);</span><br></pre></td></tr></table></figure><p>int -&gt; string：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> Integer.toString(a);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(a);</span><br></pre></td></tr></table></figure><h4 id="0532"><a class="markdownIt-Anchor" href="#0532"></a> 0.5.3.2</h4><h3 id="053-常用数据结构"><a class="markdownIt-Anchor" href="#053-常用数据结构"></a> 0.5.3 常用数据结构</h3><h1 id="1-stl速查"><a class="markdownIt-Anchor" href="#1-stl速查"></a> 1 STL速查</h1><h2 id="11-常用stl操作"><a class="markdownIt-Anchor" href="#11-常用stl操作"></a> 1.1 常用STL操作</h2><ul><li><code>reverse(container.begin(), container.end())</code>：反转</li><li><code>sort(container.begin(), container.end(), bool cmp)</code>：排序</li><li><code>unique(container.begin(), container.end())</code>：先把容器排序，然后去重，返回去重后的结尾迭代器，可以通过<code>.erase()</code>删除结尾部分</li><li><code>shuffle(container.begin(), container.end())</code>：随机打乱元素（c++14 以前使用<code>random_shuffle()</code>）</li><li><code>lower_bound(a.begin(), a.end(), x)</code>：找到第一个 &gt;= x的数，返回迭代器（找不到返回尾迭代器）【区别于<code>upper_bound</code>，upper返回第一个 &gt; x的数】可以用此迭代器减去<code>a.begin()</code>获取这个数的下标</li></ul><h2 id="12-vector"><a class="markdownIt-Anchor" href="#12-vector"></a> 1.2 vector</h2><ul><li>初始化  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(a)</span></span>; <span class="comment">// 将a复制一份为d</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">e</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br></pre></td></tr></table></figure></li><li><code>push_back</code>：在数组末尾插入，<code>emplace_back</code>更高效</li><li><code>pop_back</code>：在数组末尾删除</li></ul><h2 id="13-map"><a class="markdownIt-Anchor" href="#13-map"></a> 1.3 map</h2><p>映射，底层仍然是红黑树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp；</span><br><span class="line">mp[x] = <span class="number">1</span>; <span class="comment">// 此种写法无论原来是否存在都会分配内存，使用find方法不会</span></span><br><span class="line">mp.<span class="built_in">find</span>(x); <span class="comment">// 返回迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [x,y] : mp)&#123;...&#125; <span class="comment">// c++17开始支持</span></span><br></pre></td></tr></table></figure><p>如果要使用hash table，应该使用unordered_map，使用方式与map相同</p><h2 id="14-set"><a class="markdownIt-Anchor" href="#14-set"></a> 1.4 set</h2><p>底层是红黑树</p><ul><li><code>insert</code>：插入元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><code>lower_bound(x)</code>：二分查找有序数列，返回大于等于x的最大值（迭代器iterator）</li><li><code>erase(x)</code>：删除迭代器对应的元素，如果x是迭代器 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，是元素则会先find后删除 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li><code>find(x)</code>：查找 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，返回迭代器</li><li><strong>遍历</strong>：使用迭代器</li></ul><p>multiset可以插入重复元素，使用erase时只删除一个元素，不会把重复的都删除</p><blockquote><p>利用有序的<code>set/map</code>可以自动实现插入自动排序，即将元素放置到对应位置，辅助<code>lower_bound</code>进行二分查找</p></blockquote><h2 id="15-stack"><a class="markdownIt-Anchor" href="#15-stack"></a> 1.5 stack</h2><ul><li><code>push(x)</code>：加入元素</li><li><code>pop()</code>：删去栈顶，返回值为void</li><li><code>top()</code>：返回栈顶元素</li></ul><h2 id="16-queue"><a class="markdownIt-Anchor" href="#16-queue"></a> 1.6 queue</h2><ul><li><code>push(x)</code></li><li><code>pop()</code></li><li><code>front()</code></li></ul><h3 id="161-deque"><a class="markdownIt-Anchor" href="#161-deque"></a> 1.6.1 deque</h3><p>同时操作头尾，双端队列</p><ul><li><code>push_back(x)</code>：队尾插入</li><li><code>pop_back()</code>：弹出队尾元素</li><li><code>push_front(x)</code>：队首插入</li><li><code>pop_front()</code>：弹出队首元素</li></ul><h3 id="162-priority_queue"><a class="markdownIt-Anchor" href="#162-priority_queue"></a> 1.6.2 priority_queue</h3><p>通常作为堆使用</p><ul><li>初始化  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q; <span class="comment">// 默认大根堆（最大堆）</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q; <span class="comment">//使用vector作为底层容器，小根堆</span></span><br></pre></td></tr></table></figure></li><li><code>top()</code>：访问堆顶元素</li><li><code>push(x)</code></li><li><code>pop()</code></li></ul><h2 id="17-pair"><a class="markdownIt-Anchor" href="#17-pair"></a> 1.7 pair</h2><p>使用first/second来访问元素</p><h1 id="2-字符串"><a class="markdownIt-Anchor" href="#2-字符串"></a> 2 字符串</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串基本操作</span></span><br><span class="line">string s;</span><br><span class="line">s += <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s1 &lt; s2) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">c_str</span>(); <span class="comment">// 将string转化为c风格字符串，返回头指针</span></span><br><span class="line"><span class="type">char</span>[] c_str_ptr;</span><br><span class="line">s = c_str_ptr; <span class="comment">// 直接将char[]转换成string</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">substr</span>(pos,len); <span class="comment">// 截取下标开始处的len长度字串，不写len默认取到结尾</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stoi</span>(s); <span class="comment">// 将字符串表示的数字直接转换为int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>【int与string互转】</p><ul><li>int转string<br />c++11中的新特性<code>to_string()</code>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++11</span></span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">long</span> <span class="type">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">unsigned</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">float</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">double</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">long</span> <span class="type">double</span> val)</span></span>;</span><br></pre></td></tr></table></figure></li><li>string转int：使用<code>istringstream</code></li></ul><h2 id="21-字符串哈希"><a class="markdownIt-Anchor" href="#21-字符串哈希"></a> 2.1 字符串哈希</h2><p>基本思想：将字符串通过哈希函数转化为int值，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>s</mi><mi>i</mi></msub><msup><mi>b</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">hash(s) = \Sigma_{i=0}^{n-1} s_i b^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.131103em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></p><p>注意点：b是大素数，计算出来的和（很大）需要取模</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B = <span class="number">233</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_hash</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        res = (i64)(res*B + s[i]) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> string&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_hash</span>(s) == <span class="built_in">get_hash</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码来自oi-wiki，<code>i64</code>表示<code>int64_t</code>，即c++中的64位带符号整数（头文件写法：<code>using i64 = int64_t;</code>）</p></blockquote><p>【例题】<a href="https://leetcode.cn/problems/repeated-dna-sequences/description/">leetcode 187.Repeated DNA Sequences</a></p><h2 id="22-manacher算法"><a class="markdownIt-Anchor" href="#22-manacher算法"></a> 2.2 Manacher算法</h2><p>用于求解字符串中的最大回文串。“abcdsdc&quot;在字符串中加入占位符和开始结束符号，”$#a#b#c#d#s#d#c#^&quot;，然后遍历回文串可能的中心位置c，记录该中心位置对应的最大回文半径r</p><p>当中心从c移到i的时候，如果i &lt; r，那么当前i的回文半径至少是r-i和关于c对称的位置回文半径r[2c-i]中的最小值，需要根据i周围情况做进一步调整。如果i &gt; r，那就要从1开始扩展。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">manacher</span><span class="params">(string&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//返回中心半径数组</span></span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//构造扩充后的字符串</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">expand</span><span class="params">(n+n+<span class="number">1</span>+<span class="number">2</span>)</span></span>;</span><br><span class="line">    expand[<span class="number">0</span>] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">    expand[<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        expand[i+i+<span class="number">2</span>] = s[i];</span><br><span class="line">        expand[i+i+<span class="number">3</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    expand[n+n+<span class="number">2</span>] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n+n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">//第一个位置空着不用，从1开始；最后一个位置也不用半径</span></span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; n+n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        p[i] = (i &lt; r)? <span class="built_in">min</span>(r-i,p[c+c-i]):<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(expand[i+p[i]] == expand[i-p[i]])++p[i];</span><br><span class="line">        <span class="keyword">if</span>(i+p[i] &gt; r)&#123;</span><br><span class="line">            c = i;</span><br><span class="line">            r = i+p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算最长回文子串时，需要注意半径中包含<code>#</code>占位符，计算长度和起始位置时需要一些转换。可以参考以下例题的实际代码。</p><p>【例题】<a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">leetcode 5.Longest Palindromic Substring</a></p><h2 id="23-kmp算法"><a class="markdownIt-Anchor" href="#23-kmp算法"></a> 2.3 KMP算法</h2><p>不重复匹配已经匹配过的相同前缀</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">(string a, string b, vector&lt;<span class="type">int</span>&gt;&amp; next)</span></span>&#123;</span><br><span class="line">    <span class="comment">//在a中匹配b，n和m分别表示a和b的长度，next数组维护公共前缀</span></span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">length</span>(),m = b.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">-1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; (j == m || a[i] != b[j+<span class="number">1</span>])) j = next[j];</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j+<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == m<span class="number">-1</span>) <span class="comment">// a[i-m+1:i]是b在a中第一次出现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNext</span><span class="params">(string b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m = b.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m+<span class="number">1</span>)</span></span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; b[i] != b[j+<span class="number">1</span>]) j = next[j]; <span class="comment">// 如果下一位不同，往前回溯</span></span><br><span class="line">        <span class="keyword">if</span>(b[i] == b[j+<span class="number">1</span>]) ++j; <span class="comment">// 下一位相同，更新最大前缀</span></span><br><span class="line">        next[i] = j; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例题】<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">leetcode 28.Find the Index of the First Occurrence in a String</a></p><h2 id="24-trie"><a class="markdownIt-Anchor" href="#24-trie"></a> 2.4 Trie</h2><p>字典树</p><p>可以用链表传统树结构实现，也可以用数组的形式简易实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Trie&#123;</span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>, nodeCnt = <span class="number">1</span>, ch[N][<span class="number">26</span>]; <span class="comment">// 根节点从1开始编号</span></span><br><span class="line">    <span class="type">bool</span> flag[N]; <span class="comment">// flag表示第x个节点是否为一个字符串结尾</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!ch[cur][s[i]-<span class="string">&#x27;a&#x27;</span>]) ch[cur][s[i]-<span class="string">&#x27;a&#x27;</span>] = ++nodeCnt;</span><br><span class="line">            cur = ch[cur][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        flag[cur] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cur = ch[cur][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">return</span> flag[cur];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例题】<a href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/">leetcode 208.Implement Trie Prefix Tree</a></p><h1 id="3-常用结构"><a class="markdownIt-Anchor" href="#3-常用结构"></a> 3 常用结构</h1><p><a href="https://leetcode.cn/circle/discuss/mOr1u6/">数据结构题单</a></p><h2 id="31-栈"><a class="markdownIt-Anchor" href="#31-栈"></a> 3.1 栈</h2><blockquote><p>First in, Last out.</p></blockquote><p>STL提供<code>stack&lt;T&gt;</code>，也可以用数组简单实现</p><p>经典例题：括号匹配问题 <a href="https://leetcode.cn/problems/valid-parentheses/description/">leetcode 20.Valid Parentheses</a></p><p>【*单调栈】栈中元素保持单调递增性或递减性，例题请查看<a href="https://leetcode.cn/circle/discuss/9oZFK9/">单调栈题单</a></p><p>【例题】</p><ul><li><a href="https://leetcode.cn/problems/daily-temperatures/description/">leetcode 739.Daily Temperatures</a></li><li><a href="https://leetcode.cn/problems/next-greater-element-ii/description/">leetcode 503.Next Greater Element II</a></li></ul><h2 id="32-队列"><a class="markdownIt-Anchor" href="#32-队列"></a> 3.2 队列</h2><blockquote><p>First in, First out.</p></blockquote><p>STL提供<code>queue&lt;T&gt;</code>，详见1.6节</p><p>【经典应用】广度优先搜索BFS（见4.6.1节）</p><h3 id="321-单调队列"><a class="markdownIt-Anchor" href="#321-单调队列"></a> 3.2.1 *单调队列</h3><p>类似于单调栈，队列中元素保持单调性，通常用于滑动窗口问题。一般多用双端队列<code>deque</code>实现，但是deque常数较大，可以用数组替代。<br />通常用于<strong>滑动窗口</strong>问题。</p><p>【例题】<a href="https://leetcode.cn/problems/sliding-window-maximum/">leetcode 239.Sliding Window Maximum</a></p><h3 id="322-优先队列堆"><a class="markdownIt-Anchor" href="#322-优先队列堆"></a> 3.2.2 优先队列/堆</h3><p>优先队列使用堆实现，STL提供<code>priority_queue</code>（见1.6.2节）</p><p>使用数组实现堆（大根堆），元素从1开始</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> heap[<span class="number">1</span>];&#125; <span class="comment">// 返回最值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> k)</span></span>&#123; <span class="comment">// 插入元素</span></span><br><span class="line">    heap.<span class="built_in">push_back</span>(k);</span><br><span class="line">    <span class="built_in">swim</span>(heap.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    heap[<span class="number">0</span>] = heap[heap.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    heap.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">sink</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swim</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123; <span class="comment">// 上浮，用于push情况</span></span><br><span class="line">    <span class="keyword">while</span>(pos &gt; <span class="number">1</span> &amp;&amp; heap[pos/<span class="number">2</span>] &lt; heap[pos])&#123;</span><br><span class="line">        <span class="type">int</span> tmp = heap[pos/<span class="number">2</span>];</span><br><span class="line">        heap[pos/<span class="number">2</span>] = heap[pos];</span><br><span class="line">        heap[pos] = tmp;</span><br><span class="line">        pos = pos/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sink</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123; <span class="comment">// 下沉，用于删除后情况</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span>*pos &lt; heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">2</span>*pos;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &lt; heap.<span class="built_in">size</span>() &amp;&amp; heap[i+<span class="number">1</span>] &gt; heap[i])++i;</span><br><span class="line">        <span class="keyword">if</span>(heap[i] &gt; heap[pos])&#123;</span><br><span class="line">            <span class="type">int</span> tmp = heap[pos];</span><br><span class="line">            heap[pos] = heap[i];</span><br><span class="line">            heap[i] = tmp;</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典应用：求第k大的元素</p><p>【例题】<a href="https://leetcode.cn/problems/the-skyline-problem/description/">leetcode 218.The Skyline Problem</a></p><h2 id="33-哈希表"><a class="markdownIt-Anchor" href="#33-哈希表"></a> 3.3 哈希表</h2><p>STL提供<code>unordered_set</code>查找元素是否在集合中，用<code>unordered_map</code>存储键值对</p><p>【例题】<a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/">leetcode 128.Longest Consecutive Sequence</a></p><blockquote><p>一个很妙的原地hash技巧，即利用数组下标的性质，将数组中元素变为<code>-</code>或者插入一个数位，保留原来数据的性质的同时也能标记其他数据，节省空间<br />查看例题：<a href="https://leetcode.cn/problems/first-missing-positive/description/">leetcode 41.First Missing Positive</a></p></blockquote><h2 id="mark34-并查集mark"><a class="markdownIt-Anchor" href="#mark34-并查集mark"></a> <mark>3.4 并查集</mark></h2><p>基本思想：标记每一个节点的父节点</p><p>基本操作：</p><ul><li>查询根节点（get）</li><li>合并树（merge）</li></ul><p>并查集有两种优化方式，路径压缩和按秩合并</p><h3 id="341-路径压缩"><a class="markdownIt-Anchor" href="#341-路径压缩"></a> 3.4.1 路径压缩</h3><p>基本思想：每次get(x)后将x的根节点设置为查询到的节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> UFS&#123;</span><br><span class="line">    <span class="type">int</span> ufs[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span></span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) ufs[i] = i;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> ufs[x] == x ? x : ufs[x] = <span class="built_in">get</span>(ufs[x]);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">get</span>(x), fy = <span class="built_in">get</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(fx == fy) <span class="keyword">return</span>;</span><br><span class="line">        ufs[fx] = fy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="342-按秩合并"><a class="markdownIt-Anchor" href="#342-按秩合并"></a> 3.4.2 按秩合并</h3><p>按秩合并和路径压缩不能一起使用。</p><ul><li>按树的节点数量合并</li><li>按树的深度（秩）合并</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> UFS&#123;</span><br><span class="line">    <span class="type">int</span> ufs[N],rank[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            ufs[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> ufs[x] == x ? x : <span class="built_in">get</span>(ufs[x]);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">get</span>(x), fy = <span class="built_in">get</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(fx == fy) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rank[fx] &lt; rank[fy]) ufs[fx] = fy;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ufs[fy] = fx;</span><br><span class="line">            <span class="keyword">if</span>(rank[fx] == rank[fy]) rank[fx]++; <span class="comment">// 高度相同时合并树高要加1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例题】</p><ul><li><a href="https://leetcode.cn/problems/redundant-connection/">leetcode 684.Redundant Connection</a></li><li><a href="https://leetcode.cn/problems/couples-holding-hands/">leetcode 765.Couples Holding Hands</a></li><li>带权并查集 <a href="https://leetcode.cn/problems/evaluate-division/description/">leetcode 399.Evaluate Division</a></li></ul><blockquote><p>leetcode标签：并查集</p></blockquote><h2 id="35-链表"><a class="markdownIt-Anchor" href="#35-链表"></a> 3.5 链表</h2><h2 id="36-树"><a class="markdownIt-Anchor" href="#36-树"></a> 3.6 树</h2><p>【遍历】</p><ul><li>前序</li><li>中序</li><li>后序</li><li>层次</li></ul><p>【完全二叉树】</p><p>只有叶子层可以有空节点，其他层必须拥有全部节点，且叶子层节点必须从左向右依次排列</p><p>【满二叉树】</p><p>所有节点如果不是叶子节点必须有两个子结点。</p><h3 id="361-bst"><a class="markdownIt-Anchor" href="#361-bst"></a> 3.6.1 BST</h3><h3 id="362-bb-tree"><a class="markdownIt-Anchor" href="#362-bb-tree"></a> 3.6.2 B/B+ Tree</h3><h3 id="363-balanced-tree"><a class="markdownIt-Anchor" href="#363-balanced-tree"></a> 3.6.3 Balanced Tree</h3><h3 id="364-red-black-tree"><a class="markdownIt-Anchor" href="#364-red-black-tree"></a> 3.6.4 Red Black Tree</h3><h3 id="365-lca"><a class="markdownIt-Anchor" href="#365-lca"></a> 3.6.5 LCA</h3><p>寻找lowest common ancester</p><h4 id="3651-递归"><a class="markdownIt-Anchor" href="#3651-递归"></a> 3.6.5.1 递归</h4><p>查看左右子树是否包含该节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lca</span><span class="params">(TreeNode* root,TreeNode* l,TreeNode* r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root || root == p || root == q)<span class="keyword">return</span> root;</span><br><span class="line">    TreeNode* left = <span class="built_in">lca</span>(root-&gt;left,p,q);</span><br><span class="line">    TreeNode* right = <span class="built_in">lca</span>(root-&gt;right,p,q);</span><br><span class="line">    <span class="keyword">if</span>(!left)<span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">if</span>(!right) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3652-倍增"><a class="markdownIt-Anchor" href="#3652-倍增"></a> 3.6.5.2 倍增</h4><h3 id="366-最长路径树的直径"><a class="markdownIt-Anchor" href="#366-最长路径树的直径"></a> 3.6.6 最长路径/树的直径</h3><h4 id="3661-两次bfs"><a class="markdownIt-Anchor" href="#3661-两次bfs"></a> 3.6.6.1 两次BFS</h4><ol><li>从任意节点p出发，利用广度优先/深度优先找到最长路径x的终点i</li><li>从i出发，找到最长路径y</li><li>y即树的最长路径</li></ol><p>任意节点出发寻找的最长路径终点一定是叶子节点，从叶子节点出发寻找的最长路径即为整棵树的最长路径</p><h4 id="3662-树上dp"><a class="markdownIt-Anchor" href="#3662-树上dp"></a> 3.6.6.2 树上DP</h4><p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>表示到x点最长的叶子节点的距离，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x) = dist(x,y)+f(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的子节点。</p><p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y_1,y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的两个不一样的子节点（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>不在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>同一条子节点路上），那么可以把树的直径用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dist(x,y_1)+f(y_1)+dist(x,y_2)+f(y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>更新一下。通过dp可以遍历节点，相当于每次考虑经过一个节点最长路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> f[N],ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = head[x];j;j = e[j].nxt)&#123;</span><br><span class="line">        <span class="type">int</span> y = e[j].to;</span><br><span class="line">        <span class="built_in">dp</span>(y,x);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,f[x]+e[j].val+f[y]);</span><br><span class="line">        f[x] = <span class="built_in">max</span>(f[x],e[j].val+f[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="37-树状数组"><a class="markdownIt-Anchor" href="#37-树状数组"></a> 3.7 *树状数组</h2><h3 id="371-一维"><a class="markdownIt-Anchor" href="#371-一维"></a> 3.7.1 一维</h3><p>用来解决“单点修改，单点查询”，“单点修改，区间查询”，“区间查询，区间修改”这些问题，<a href="https://blog.csdn.net/TheWayForDream/article/details/118436732">这篇博客</a>详细解释了树状数组的求和原理</p><p><strong>lowbit</strong>：数字最低为1位表示的数字大小（例如，<code>lowbit(1) = 1</code>，<code>lowbit(5) = 1</code>，<code>lowbit(6) = 2</code></p><p>树状数组中存储的元素，表示区间<code>[i-lowbit[i]+1,i]</code>的区间查询元素</p><p>单点修改，区间查询模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Bit&#123;</span><br><span class="line">    <span class="type">int</span> s[N];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span>&#123; <span class="keyword">return</span> i &amp; (-i);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="comment">//下标为p的元素+v(单点修改)</span></span><br><span class="line">        <span class="keyword">for</span>(;p &lt;= n;p += <span class="built_in">lowbit</span>(p)) s[p] += v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 区间[0,p]的和</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;p &gt; <span class="number">0</span>;p -= <span class="built_in">lowbit</span>(p)) ret += s[p];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="comment">//查询区间[l,r]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(r)-<span class="built_in">query</span>(l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树状数组修改和查询的时间复杂度均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>如何构建树状数组？<br />使用前缀和之类的手段</p></blockquote><p>【例题】</p><ul><li><a href="https://leetcode.cn/problems/range-sum-query-mutable/description/">leetcode 307.Range Sum Query - Mutable</a></li><li><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">leetcode 315.Count Of Smaller Numbers After Self</a></li><li><a href="https://leetcode.cn/problems/range-sum-query-2d-mutable/description/">二维树状数组：leetcode 308.Range Sum Query 2D - Mutable </a></li></ul><h3 id="372-二维"><a class="markdownIt-Anchor" href="#372-二维"></a> 3.7.2 二维</h3><h2 id="38-线段树"><a class="markdownIt-Anchor" href="#38-线段树"></a> 3.8 *线段树</h2><p>线段树适合用来解决“区间修改、区间查询”的问题。</p><p>将每一段区间按照叶节点记录子区间，父节点记录将子区间合并成一个大区间。修改区间时，针对该节点以下子节点的更新，使用lazy tag标记，访问时将tag下推。</p><ul><li>区间修改代码（区间和）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SegTree&#123;</span><br><span class="line">    <span class="type">int</span> s[N &lt;&lt; <span class="number">2</span>], t[N &lt;&lt; <span class="number">2</span>]; <span class="comment">//s数组用于存储线段树区间和，t数组用于记录tag</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> lc (p &lt;&lt; 1) <span class="comment">// left child at position [2*p]</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> rc (p &lt;&lt; 1 | 1) <span class="comment">// right child at position [2*p+1]</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> mid ((l+r) &gt;&gt; 1) <span class="comment">// 用于建树</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;s[p] = s[lc]+s[rc];&#125; <span class="comment">// 向上更新</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 使用tag向下更新</span></span><br><span class="line">        <span class="keyword">if</span>(!tag[p]) <span class="keyword">return</span>;</span><br><span class="line">        s[lc] += tag[p]*(mid-l+<span class="number">1</span>);tag[lc] += tag[p];</span><br><span class="line">        s[rc] += tag[p]*(r-mid);  tag[rc] += tag[p];</span><br><span class="line">        tag[p] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用递归技巧建树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            s[p] = a[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>(lc,l,mid);</span><br><span class="line">        <span class="built_in">build</span>(rc,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改某个区间:[x,y]区域内的值+v</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= l &amp;&amp; y &gt;= r)&#123; <span class="comment">// 递归结束，找到包括的全部区间</span></span><br><span class="line">            s[p] += (r-l+<span class="number">1</span>)*v;</span><br><span class="line">            tag[p] += v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">down</span>(p,l,r);</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(lc,l,mid,x,y,v);</span><br><span class="line">        <span class="keyword">if</span>(y &gt; mid) <span class="built_in">modify</span>(rc,mid+<span class="number">1</span>,r,x,y,v);</span><br><span class="line">        <span class="built_in">up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询某个区间内的值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= l &amp;&amp; y &gt;= r)&#123;</span><br><span class="line">            <span class="keyword">return</span> s[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">down</span>(p,l,r);</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) ret += <span class="built_in">query</span>(lc,l,mid,x,y);</span><br><span class="line">        <span class="keyword">if</span>(y &gt; mid) ret += <span class="built_in">query</span>(rc,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">        <span class="keyword">return</span> ret; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>单点修改  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        s[p] += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">down</span>(p,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(lc,l,mid,x,v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(rc,mid+<span class="number">1</span>,r,x,v);</span><br><span class="line">    <span class="built_in">up</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>单点查询  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="keyword">return</span> s[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">down</span>(p,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(lc,l,mid,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(rc,mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>线段树的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>如何修改模板以适应不同的问题</p></blockquote><ul><li>区间复合如何实现，即如何实现up函数</li><li>区间更新操作如何实现，即如何实现down和modify函数</li></ul><h2 id="39-st表"><a class="markdownIt-Anchor" href="#39-st表"></a> 3.9 ST表</h2><p><a href="https://blog.csdn.net/a1130683021/article/details/132729361">这篇博客</a>详细解释了ST表的原理。简单解释就是利用了区间可加性的思想，即区间[l,r]的性质可以由[l,s]和[s+1,r]两个区间的相同性质合并而来。例如：max(l,r) = max(max(l,s),max(s+1,r))</p><p>在ST表中，我们考察区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mi>j</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i,i+2^j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这个区间，可以发现这个区间可以由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i,i+2^{j-1}-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mi>j</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i+2^{j-1},i+2^j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.019104em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这两个区间，其中，每个子区间包含了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>个元素，总共区间有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>个元素</p><p>查询时，区间中有r-l+1个元素，因此取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><mo stretchy="false">⌊</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">s = \lfloor log_2(r-l+1) \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">⌋</span></span></span></span>，此时区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>l</mi><mo>+</mo><msup><mn>2</mn><mi>s</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,l+2^s-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>r</mi><mo>−</mo><msup><mn>2</mn><mi>s</mi></msup><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[r-2^s+1,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>可以交叉覆盖整个查询区间。</p><p>以下模板以求解区间最大值为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> st[N][M]; <span class="comment">// 数组一共有N个元素，M = log2(N)，可以根据题目范围适当开大一点</span></span><br><span class="line"><span class="type">int</span> log2_[N]; <span class="comment">// 预处理好求解log数组，c++log2库函数常数大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//建表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123; <span class="comment">// 数组从下标为1开始</span></span><br><span class="line">        st[i][<span class="number">0</span>] = a[i]; </span><br><span class="line">        log2_[i] = <span class="built_in">log2</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;(<span class="number">1</span> &lt;&lt; j) &lt;= n;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i+(<span class="number">1</span> &lt;&lt; j)<span class="number">-1</span> &lt;= n;i++)&#123;</span><br><span class="line">            st[i][j] = <span class="built_in">max</span>(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span> &lt;&lt; (j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询区间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = log2_[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(st[l][s],st[r-(<span class="number">1</span> &lt;&lt; s)+<span class="number">1</span>][s])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>区间问题的总结请查看4.8节前缀和与差分数组</p><h2 id="310-分块"><a class="markdownIt-Anchor" href="#310-分块"></a> 3.10 分块</h2><p>将数组分成几个区间，使用tag标记区间统一操作情况，不在区间中的零散数据直接暴力处理。</p><p>可以将区间内的数据进行排序以获得更高的性能。</p><p>一般来说还是优先考虑线段树等log数据结构</p><h1 id="4-技巧"><a class="markdownIt-Anchor" href="#4-技巧"></a> 4 技巧</h1><h2 id="mark41-动态规划mark"><a class="markdownIt-Anchor" href="#mark41-动态规划mark"></a> <mark>4.1 动态规划</mark></h2><p>原理：保存子问题的解避免重复计算</p><p>核心：找到状态转移方程</p><p><a href="https://leetcode.cn/circle/discuss/tXLS3i/">动态规划题单</a></p><h3 id="411-一维动态规划"><a class="markdownIt-Anchor" href="#411-一维动态规划"></a> 4.1.1 一维动态规划</h3><ul><li><p>爬楼梯问题：多种传递方式叠加</p></li><li><p>打家劫舍问题：有限制的叠加方式</p></li><li><p>不考虑顺序，即组合类问题：通过枚举可能的选项，固定顺序求解，具体例题请查看<a href="https://leetcode.cn/problems/coin-change-ii/description">coin change II</a></p></li></ul><h3 id="412-二维动态规划"><a class="markdownIt-Anchor" href="#412-二维动态规划"></a> 4.1.2 二维动态规划</h3><h3 id="413-分割类型"><a class="markdownIt-Anchor" href="#413-分割类型"></a> 4.1.3 分割类型</h3><h3 id="414-子序列与字符串"><a class="markdownIt-Anchor" href="#414-子序列与字符串"></a> 4.1.4 子序列与字符串</h3><ul><li>连续子序列：选定结尾枚举（有些题目可以考虑前缀和方法）</li><li>非连续型子序列：<ul><li>【经典问题】最长公共子序列（见题单<strong>线性dp</strong>专题）</li><li>【经典问题】最长递增子序列</li></ul></li></ul><p>【最长公共子序列的并行计算问题】</p><p>所有的并行计算问题都可以使用<strong>拓扑排序</strong>的思想解决</p><h3 id="415-背包问题"><a class="markdownIt-Anchor" href="#415-背包问题"></a> 4.1.5 背包问题</h3><ul><li>0-1背包：每个物体只能选1次或0次，通过限制体积（或其他等价限制）来遍历</li><li>完全背包</li><li></li></ul><h3 id="416-状态机"><a class="markdownIt-Anchor" href="#416-状态机"></a> 4.1.6 状态机</h3><h3 id="417-树形dp"><a class="markdownIt-Anchor" href="#417-树形dp"></a> 4.1.7 树形dp</h3><h3 id="418-区间dp"><a class="markdownIt-Anchor" href="#418-区间dp"></a> 4.1.8 区间dp</h3><h3 id="419-状态压缩dp"><a class="markdownIt-Anchor" href="#419-状态压缩dp"></a> 4.1.9 状态压缩dp</h3><h2 id="42-贪心"><a class="markdownIt-Anchor" href="#42-贪心"></a> 4.2 贪心</h2><h3 id="421-区间问题"><a class="markdownIt-Anchor" href="#421-区间问题"></a> 4.2.1 区间问题</h3><h2 id="43-多指针与滑动窗口"><a class="markdownIt-Anchor" href="#43-多指针与滑动窗口"></a> 4.3 多指针与滑动窗口</h2><h3 id="431-双指针"><a class="markdownIt-Anchor" href="#431-双指针"></a> 4.3.1 双指针</h3><h3 id="432-滑动窗口"><a class="markdownIt-Anchor" href="#432-滑动窗口"></a> 4.3.2 滑动窗口</h3><h2 id="44-二分法"><a class="markdownIt-Anchor" href="#44-二分法"></a> 4.4 二分法</h2><p><a href="https://leetcode.cn/circle/discuss/SqopEo/">二分题单</a></p><p>二分查找模板：</p><p>找到大于等于/大于/小于等于/小于：</p><h2 id="45-排序"><a class="markdownIt-Anchor" href="#45-排序"></a> 4.5 排序</h2><h3 id="451-归并排序"><a class="markdownIt-Anchor" href="#451-归并排序"></a> 4.5.1 归并排序</h3><p>divide &amp; conquer</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> l,<span class="type">int</span> r,vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l+<span class="number">1</span> &gt;= r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//divide</span></span><br><span class="line">    <span class="type">int</span> m = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">helper</span>(nums,l,m,temp);</span><br><span class="line">    <span class="built_in">helper</span>(nums,m,r,temp);</span><br><span class="line">    <span class="comment">//conquer</span></span><br><span class="line">    <span class="type">int</span> p = l,q = m,i = l;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; m || q &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q &gt;=r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q]))&#123;</span><br><span class="line">            temp[i++] = nums[p++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp[i++] = nums[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = l;i &lt; r;i++)&#123;</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="built_in">helper</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>(),temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例题】很精妙的运用<a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/">LCR170. 交易的逆序对总数</a></p><h3 id="452-快速排序"><a class="markdownIt-Anchor" href="#452-快速排序"></a> 4.5.2 快速排序</h3><h2 id="mark46-搜索mark"><a class="markdownIt-Anchor" href="#mark46-搜索mark"></a> <mark>4.6 搜索</mark></h2><h3 id="461-广度优先bfs"><a class="markdownIt-Anchor" href="#461-广度优先bfs"></a> 4.6.1 广度优先BFS</h3><p>使用<strong>队列</strong>来存储每一层可以到达的节点</p><ul><li>树BFS：层次遍历</li><li>图BFS</li></ul><p>BFS可以较为容易的实现计算深度（层数/路径长度），但是难以记录路径</p><p>【例题】<a href="https://leetcode.cn/problems/shortest-bridge/description/">leetcode 934.Shortest Bridge</a></p><p>【专题】如何在BFS中找到最短路径（记录路径）</p><p>访问题目<a href="https://leetcode.cn/problems/word-ladder-ii/description/">leetcode 126.Word Ladder II</a></p><h3 id="462-深度优先dfs"><a class="markdownIt-Anchor" href="#462-深度优先dfs"></a> 4.6.2 深度优先DFS</h3><p>使用栈结构，不要忘记访问过的标记避免重复访问</p><p>【例题】</p><ul><li><a href="https://leetcode.cn/problems/number-of-provinces/description/">leetcode 547.Friend Circles</a></li></ul><h3 id="463-其他搜索"><a class="markdownIt-Anchor" href="#463-其他搜索"></a> 4.6.3 其他搜索</h3><p>【例题】变形搜索<a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/">leetcode 240.Search a 2D Matrix II</a></p><p><a href="https://leetcode.cn/circle/discuss/YiXPXW/">网格搜索专题题单</a></p><p>图上BFS/DFS搜索相关题单请查看图论部分总题单</p><h2 id="47-位运算"><a class="markdownIt-Anchor" href="#47-位运算"></a> 4.7 位运算</h2><p><a href="https://leetcode.cn/circle/discuss/dHn9Vk/">位运算题单</a></p><p>【常见技巧】</p><ul><li><code>n&amp;(n-1)</code>：消去n最低位的1</li><li><code>n&amp;(-n)</code>：获取最低位的1的大小</li><li><code>reverse(lowbit(reverse(x)))</code>：获取最高位1，reverse是把进制位头尾颠倒</li></ul><p>【解题思想】</p><ul><li><code>and</code>参与运算的数越多，得到的结果越小；<code>or</code>参与运算的数越多，得到的结果越大</li><li><code>and/or</code>运算可以把参与运算的整数<strong>拆分</strong>为二进制32位，按照每一位考虑</li></ul><h2 id="48-前缀和与差分数组"><a class="markdownIt-Anchor" href="#48-前缀和与差分数组"></a> 4.8 前缀和与差分数组</h2><p>前缀是一个能解决很多问题的思想。</p><h3 id="481-前缀和"><a class="markdownIt-Anchor" href="#481-前缀和"></a> 4.8.1 前缀和</h3><p>对于任意一个数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_0,a_1,...,a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>构造前缀和数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><msub><mi>b</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b_i = b_{i-1}+a_{i-1}, b_0 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，求解区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 的和可以用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>复杂度求出</p><h3 id="482-差分数组"><a class="markdownIt-Anchor" href="#482-差分数组"></a> 4.8.2 差分数组</h3><p>构造差分数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d_i = a_i-a_{i-1}, d_0 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，对区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>做相同操作时（如同时加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>l</mi></msub><mo>+</mo><mo>=</mo><mi>v</mi><mo separator="true">,</mo><msub><mi>d</mi><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><mo>=</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">v, d_l += v, d_{r+1} -= v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>）可以以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>复杂度实现。</p><p>【例题】<a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/">leetcode 560.Subarray Sum Equals K</a></p><h3 id="483-区间求值问题总结"><a class="markdownIt-Anchor" href="#483-区间求值问题总结"></a> 4.8.3 区间求值问题总结</h3><blockquote><p>摘自<a href="https://leetcode.cn/problems/range-sum-query-mutable/solutions/632515/guan-yu-ge-lei-qu-jian-he-wen-ti-ru-he-x-41hv">leetcode用户宫水三叶的总结</a></p></blockquote><ul><li>数组不变，求区间和：「前缀和」、「树状数组」、「线段树」</li><li>多次修改某个数，求区间和：「树状数组」、「线段树」</li><li>多次整体修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间的数据范围）</li><li>多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间的数据范围）</li></ul><p>总而言之，「线段树」的扩展性最佳，树状数组通常可以简化线段树。</p><h3 id="484-前后缀分解"><a class="markdownIt-Anchor" href="#484-前后缀分解"></a> 4.8.4 前后缀分解</h3><blockquote><p>摘自<a href="https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i/solutions/2493551/on-zuo-fa-mei-ju-numsjqian-hou-zhui-fen-xweo4/">leetcode用户灵茶山艾府的总结</a></p></blockquote><ul><li><a href="https://leetcode.cn/problems/trapping-rain-water/">42.接雨水</a></li><li><a href="https://leetcode.cn/problems/minimum-average-difference/">2256.最小平均差</a></li><li><a href="https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/description/">1493.删掉一个元素以后全为 1 的最长子数组</a></li><li><a href="https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/">2909.元素和最小的山形三元组II</a></li></ul><ol start="1031"><li>两个非重叠子数组的最大和 1680</li><li>三个无重叠子数组的最大和</li><li>找到所有好下标 1695</li><li>适合野炊的日子 1702</li><li>使字符串平衡的最少删除次数 1794</li><li>将字符串翻转到单调递增</li><li>找两个和为目标值且不重叠的子数组 1851</li><li>得到山形数组的最少删除次数 1913</li><li>除自身以外数组的乘积 ~2000</li><li>使二进制字符串字符交替的最少反转次数 2006</li><li>构造乘积矩阵 2075</li><li>移除所有载有违禁货物车厢所需的最少时间 2219</li><li>统计回文子序列数目 2223</li><li>删除元素后和的最小差值 2225</li><li>最少得分子序列 2432</li><li>统计上升四元组 2433</li><li>执行操作后的最大分割数量 3039</li><li>最大连续 1 的个数 II（会员题）</li><li>经过一次操作后的最大子数组和（会员题）</li></ol><h2 id="49-回溯"><a class="markdownIt-Anchor" href="#49-回溯"></a> 4.9 回溯</h2><h2 id="410-曼哈顿距离"><a class="markdownIt-Anchor" href="#410-曼哈顿距离"></a> 4.10 曼哈顿距离</h2><p>将坐标系顺时针旋转45°并拉伸为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span></span>倍，可以将两点之间的曼哈顿距离转换为在x’轴或者y’轴上的投影（即相对距离）。</p><p>坐标转换：(x,y) -&gt; (x+y,x-y)</p><h1 id="5-图论"><a class="markdownIt-Anchor" href="#5-图论"></a> 5 图论</h1><p>图论系列<a href="https://leetcode.cn/circle/discuss/01LUak/">题单</a></p><h2 id="51-图的基本表示方法"><a class="markdownIt-Anchor" href="#51-图的基本表示方法"></a> 5.1 图的基本表示方法</h2><h3 id="511-邻接矩阵"><a class="markdownIt-Anchor" href="#511-邻接矩阵"></a> 5.1.1 邻接矩阵</h3><p>邻接矩阵适用于点比较少的情况，用一个二维数组存储相互连接的点之间的权值(<code>d[i][j] = v</code>)</p><h3 id="512-链式前向星"><a class="markdownIt-Anchor" href="#512-链式前向星"></a> 5.1.2 链式前向星</h3><p>采用与每个点相连的边链表形式存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tot, head[N]; <span class="comment">// tot表示当前边的下标（总数），head记录从这个点出发的所有边链表的头节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123; <span class="type">int</span> to, nxt, val;&#125; e[M]; <span class="comment">//每条边节点记录到的点，链表中下一项，以及边的权值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> to, <span class="type">int</span> from, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    e[++tot].to = to;</span><br><span class="line">    e[tot].val = val;</span><br><span class="line">    e[tot].nxt = head[from];</span><br><span class="line">    head[from] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visitEdge</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问从n出发的所有边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[n];i;i = e[i].nxt)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mark52-图遍历mark"><a class="markdownIt-Anchor" href="#mark52-图遍历mark"></a> <mark>5.2 图遍历</mark></h2><ul><li>DFS</li><li>BFS</li><li>拓扑排序</li></ul><h2 id="mark53-最短路mark"><a class="markdownIt-Anchor" href="#mark53-最短路mark"></a> <mark>5.3 最短路</mark></h2><h3 id="521-floyd"><a class="markdownIt-Anchor" href="#521-floyd"></a> 5.2.1 floyd</h3><p><strong>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></strong></p><p>floyd的思想是动态规划，可以视作经过k的i到j最短路径和不经过k的最短路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> f[N][N],d[N][N]; <span class="comment">// f存储最短路径，d存储邻接矩阵</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            f[i][j] = d[i][j]; <span class="comment">// 初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        f[i][i] = <span class="number">0</span>; <span class="comment">// 点到自己的距离是0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j],f[i][k]+f[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果i到j不存在路径，可以取无穷，为了防止溢出，可以设d[i][j] = 0x3f3f3f3f</p><p>向图中新加一条通路，则需要更新经过此条通路和不经过这条通路的最小路径</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">        f[i][j] = <span class="built_in">min</span>(f[i][j],f[i][x]+d[x][y]+f[y][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="522-dijkstra"><a class="markdownIt-Anchor" href="#522-dijkstra"></a> 5.2.2 dijkstra</h3><p>基本思想：S={u}，每次计算到S集合距离最近的点加入集合。（贪心）</p><h4 id="5221-朴素实现"><a class="markdownIt-Anchor" href="#5221-朴素实现"></a> 5.2.2.1 朴素实现</h4><p><strong>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) d[i] = inf;</span><br><span class="line">    d[u] = <span class="number">0</span>; <span class="comment">// 开始时集合中只有u这一个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123; <span class="comment">// 最多扩展n次（共有n个点）</span></span><br><span class="line">        <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(v == <span class="number">0</span> || d[v] &gt; d[j]) v = j;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = head[v];j;j = e[j].nxt)&#123;</span><br><span class="line">            <span class="type">int</span> w = e[j].to;</span><br><span class="line">            d[w] = <span class="built_in">min</span>(d[w],d[v]+e[j].val); <span class="comment">// 更新到当前w点的最小路径</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5222-堆优化"><a class="markdownIt-Anchor" href="#5222-堆优化"></a> 5.2.2.2 堆优化</h4><p>算法瓶颈在于求最小值</p><p>经过堆优化后的<strong>时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mlogm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></strong>，m表示边的数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">int</span> d[N];<span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)d[i] = inf;</span><br><span class="line">    d[u] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pii&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="built_in">pii</span>(d[u],u));</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> w = pq.<span class="built_in">top</span>().second;pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!vis[w])&#123;</span><br><span class="line">            vis[w] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = head[w];j;j = e[j].nxt)&#123;</span><br><span class="line">                <span class="type">int</span> i = e[j].to;</span><br><span class="line">                <span class="keyword">if</span>(d[i] &gt; d[w]+e[j].val)&#123;</span><br><span class="line">                    d[i] = d[w]+e[j].val;</span><br><span class="line">                    pq.<span class="built_in">push</span>(<span class="built_in">pii</span>(-d[i],i)); <span class="comment">// 优先队列默认大根堆，通过取反间接实现小根堆</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="523-bellman-ford"><a class="markdownIt-Anchor" href="#523-bellman-ford"></a> 5.2.3 Bellman-Ford</h3><p>用于处理负权边，实现原理：用以下不等式更新dis</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">dis(y) &lt;= dis(x)+w </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></span></p><p>经过n轮迭代，可以保证就是最短路。如果n轮迭代后上述等式不成立（即还可以更新），表明图中存在负环。</p><p>该算法时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，n为点的数目，m为边的数目。这一时间复杂度是稳定的。</p><h4 id="5231-朴素实现"><a class="markdownIt-Anchor" href="#5231-朴素实现"></a> 5.2.3.1 朴素实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    d[i] = inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellmanFord</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    d[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">1</span>;r &lt;= n;r++)&#123; <span class="comment">// 最多n轮</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">1</span>;x &lt;= n;x++)&#123; <span class="comment">// 遍历当前与源相连的所有节点</span></span><br><span class="line">            <span class="keyword">if</span>(d[i] == inf)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = head[x];j;j = e[j].nxt)&#123;</span><br><span class="line">                <span class="type">int</span> to = e[j].to,val = e[j].val;</span><br><span class="line">                d[to] = <span class="built_in">min</span>(d[to],d[x]+val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5232-spfa"><a class="markdownIt-Anchor" href="#5232-spfa"></a> 5.2.3.2 spfa</h4><p>队列优化的BellmanFord算法：类似bfs的思想，只有x更新，与x相连的点才会发生更新，因此使用队列存储被更新过的节点，然后更新相连的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    d[i] = inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> visited[N]; <span class="comment">// 是否在队列中</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(u);</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();visited[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = head[t];j;j = e[j].nxt)&#123;</span><br><span class="line">            <span class="type">int</span> to = e[j].to,val = e[j].val;</span><br><span class="line">            <span class="keyword">if</span>(d[to] &gt; d[t]+val)&#123;</span><br><span class="line">                d[to] = d[t]+val;</span><br><span class="line">                <span class="keyword">if</span>(!visited[to])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(to); </span><br><span class="line">                    visited[to] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mark54-最小生成树mark"><a class="markdownIt-Anchor" href="#mark54-最小生成树mark"></a> <mark>5.4 最小生成树</mark></h2><p>minimum spanning tree - MST</p><h3 id="541-kruskal算法"><a class="markdownIt-Anchor" href="#541-kruskal算法"></a> 5.4.1 Kruskal算法</h3><p>基于贪心的思想，每次向kruskcal加入没有联通的最小权值的边。时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mlogm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，主要瓶颈在于给边排序的时间复杂度。</p><p>使用<strong>并查集</strong>记录连通块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="type">int</span> x,y,v;&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Edge&amp; e1,Edge&amp; e2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.v &lt; e2.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruscal</span><span class="params">(vector&lt;Edge&gt; edges)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(),edges.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(Edge e:edges)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(e.x) != <span class="built_in">get</span>(e.y))&#123; <span class="comment">// x，y不在同一个连通块内</span></span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="built_in">merge</span>(e.x,e.y);</span><br><span class="line">            sum += e.v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= n)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="542-prim算法"><a class="markdownIt-Anchor" href="#542-prim算法"></a> 5.4.2 Prim算法</h3><p>类似dijkstra算法，每次将到当前连通块中边最小的点加入联通集合。</p><p>算法复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，瓶颈主要在找最小值的过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> vis[N]; <span class="comment">// 用于记录当前点是否加入生成树</span></span><br><span class="line"><span class="type">int</span> dis[N]; <span class="comment">// 类似dijkstra，记录未加入点到连通块的最小距离</span></span><br><span class="line"><span class="comment">// 使用链式前向星记录边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 把点1先加入连通块</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; dis[x])x = j; <span class="comment">// 找到最小边点</span></span><br><span class="line">        &#125;</span><br><span class="line">        vis[x] = <span class="literal">true</span>;</span><br><span class="line">        sum += dis[x];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = head[x];j;j = e[j].nxt)&#123;</span><br><span class="line">            <span class="type">int</span> y = e[j].to,val = e[j].v;</span><br><span class="line">            <span class="keyword">if</span>(!vis[y])&#123;</span><br><span class="line">                dis[y] = <span class="built_in">min</span>(dis[y],val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="55-二分图"><a class="markdownIt-Anchor" href="#55-二分图"></a> 5.5 二分图</h2><h2 id="56-网络流"><a class="markdownIt-Anchor" href="#56-网络流"></a> 5.6 网络流</h2><h1 id="6-数学"><a class="markdownIt-Anchor" href="#6-数学"></a> 6 数学</h1><h2 id="61-带余除法"><a class="markdownIt-Anchor" href="#61-带余除法"></a> 6.1 带余除法</h2><h3 id="611-最大公约数"><a class="markdownIt-Anchor" href="#611-最大公约数"></a> 6.1.1 最大公约数</h3><p>辗转相除法（欧几里得法）求解最大公约数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a,b) = gcd(a, b\space mod\space a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span></p><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 【证明：考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&gt;</mo><mfrac><mi>b</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">a&gt;\frac{b}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&lt;</mo><mfrac><mi>b</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">a&lt;\frac{b}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 两种情况，可以证明每次整除会导致规模缩小一半】</p><p>实现与使用：</p><ul><li>c++14：<code>__gcd(int,int)</code> （在<code>&lt;algorithm&gt;</code>库中）</li><li>c++17：<code>gcd(int,int)</code> （在<code>&lt;numeric&gt;</code>库中）</li></ul><p>【例题】<a href="https://leetcode.cn/problems/simplified-fractions/description/">leetcode 1447.Simplified Fractions</a></p><h3 id="mark612-不定方程mark"><a class="markdownIt-Anchor" href="#mark612-不定方程mark"></a> <mark>6.1.2 不定方程</mark></h3><p>【定义】未知数个数超过方程数量，典型例子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">ax+by=c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>为未知数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a,b,c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span></span></span></span>为参数</p><p>【裴蜀定理】<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>c</mi><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">ax+by=c \iff gcd(a,b)|c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.549em;vertical-align:-0.024em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⟺</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord mathdefault">c</span></span></span></span></p><p>简单证明：假设$a&gt;b, a=b\cdot k+r $ ，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">ax+by=c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 可以写作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>k</mi><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>r</mi><mi>x</mi><mo>=</mo><mi>b</mi><msub><mi>x</mi><mn>0</mn></msub><mo>+</mo><mi>r</mi><msub><mi>y</mi><mn>0</mn></msub><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">b(y+kx)+rx = bx_0+ry_0 = c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span></p><p>在上述式子中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>可以写作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>b</mi></mrow><annotation encoding="application/x-tex">a\space mod \space b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace"> </span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault">b</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>可以写作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mi>a</mi><mi>b</mi></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor\frac{a}{b}\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>（此处可利用c++中整数相除特性），因此<mark>扩展欧几里得算法</mark>可以写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">extgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span>&amp; x,<span class="type">int</span>&amp; y)</span></span>&#123; <span class="comment">//此处默认c=gcd(a,b)</span></span><br><span class="line">    <span class="keyword">if</span>(!b)&#123; <span class="comment">// b=0, ax=c, a = gcd(a,b)</span></span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">extgcd</span>(b,a%b,x,y),x0 = x,y0 = y; <span class="comment">// a = a/b * b + r  </span></span><br><span class="line">    x = y0; <span class="comment">// r*x+b*(a/b*x + y) = c, x-&gt;y0</span></span><br><span class="line">    y = x0-(a/b)*y0; </span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例题】<a href="https://leetcode.cn/problems/water-and-jug-problem/description/">leetcode 365.Water And Jug Problem</a></p><h2 id="62-素数质数"><a class="markdownIt-Anchor" href="#62-素数质数"></a> 6.2 *素数/质数</h2><h3 id="621-质因数分解"><a class="markdownIt-Anchor" href="#621-质因数分解"></a> 6.2.1 质因数分解</h3><p>任何数都可以被写成唯一的质因数分解形式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msubsup><mi>p</mi><mi>i</mi><msub><mi>r</mi><mi>i</mi></msub></msubsup></mrow><annotation encoding="application/x-tex">\prod_{i=1}^k p_i^{r_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.746292em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.1449000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是质数。</p><p>推理可知，如果要对一个整数进行质因数分解，只需要枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><msqrt><mi>n</mi></msqrt><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,\sqrt{n}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">]</span></span></span></span>之间的素数（n最多只有一个大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>的质因数），时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msqrt><mi>n</mi></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;pii&gt; <span class="title">getPrimes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = n;</span><br><span class="line">    vector&lt;pii&gt; ret;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i*i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>( ;tmp%i==<span class="number">0</span>;tmp /= i)count++;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(<span class="built_in">pii</span>(i,count));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在大于根号n的质因数</span></span><br><span class="line">    <span class="keyword">if</span>(tmp != <span class="number">1</span>)&#123;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(<span class="built_in">pii</span>(tmp,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="622-素数筛"><a class="markdownIt-Anchor" href="#622-素数筛"></a> 6.2.2 素数筛</h3><ul><li><strong>埃氏筛</strong>：枚举过程中将质数的倍数标记置为合数  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isPrime</span><span class="params">(n+<span class="number">1</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i+i;j &lt;= n;j+=i)&#123;</span><br><span class="line">                isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>埃氏筛的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nloglogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> ？</li><li><strong>欧拉筛</strong>：每个数被严格筛选一次，所以时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primeCnt = <span class="number">0</span>,primes[N];</span><br><span class="line"><span class="type">bool</span> notPrime[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> maxN)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= maxN;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!notPrime[i]) primes[++primeCnt] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= primeCnt &amp;&amp; i*primes[j] &lt;= maxN;j++)&#123;</span><br><span class="line">            notPrime[i*primes[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>使用合数与该合数的最小质因数构造新的合数，假设a是一个合数，a = p * b，b是合数。假设存在 a = p’ * c，c是另一个合数，不妨设c &gt; b（按照遍历次序），p’ &lt; p，p’和p互质，因此p’|b，即 b%p’== 0，退出循环，不可能再出现p。详细证明请参考<a href="https://blog.csdn.net/qaqwqaqwq/article/details/123587336">这篇博客</a></li></ul><p>【例题】<a href="https://leetcode.cn/problems/count-primes/description/">leetcode 204.Count Primes</a></p><p>素数筛的进阶用法：筛选积性函数</p><h3 id="623-判断质数"><a class="markdownIt-Anchor" href="#623-判断质数"></a> 6.2.3 判断质数</h3><p>【法一】从2到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span>遍历，查看是否能被整除</p><p>【法二】使用素数筛预处理范围内所有的素数</p><h2 id="63-乘法逆元"><a class="markdownIt-Anchor" href="#63-乘法逆元"></a> 6.3 乘法逆元</h2><p>乘法逆元：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="0.4444444444444444em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax \equiv 1 \pmod P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span>，x是模P意义下a的乘法逆元，等价于求解<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>P</mi><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ax + Py = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，转换为不定方程使用扩展欧几里得算法求解。因此有解要求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a,P) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><h3 id="631-费马小定理"><a class="markdownIt-Anchor" href="#631-费马小定理"></a> 6.3.1 费马小定理</h3><p>费马小定理：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>为质数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>P</mi></msup><mo>≡</mo><mi>a</mi><mspace></mspace><mspace width="0.4444444444444444em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a^P \equiv a \pmod P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span></p><p>由费马小定理可以推出模P意义下a的乘法逆元特解是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mrow><mi>P</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">a^{P-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><h3 id="632-线性递推"><a class="markdownIt-Anchor" href="#632-线性递推"></a> 6.3.2 线性递推</h3><p>线性递推关系可以求解[1,n]每个整数对于P的逆元</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>v</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mspace linebreak="newline"></mspace><mi>i</mi><mi>n</mi><mi>v</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mo stretchy="false">⌊</mo><mfrac><mi>P</mi><mi>n</mi></mfrac><mo stretchy="false">⌋</mo><mo>⋅</mo><mi>i</mi><mi>n</mi><mi>v</mi><mo stretchy="false">(</mo><mi>P</mi><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>n</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">    inv(1) = 1 \\    inv(n) =  -\lfloor \frac{P}{n}\rfloor \cdot inv(P\bmod n) ,\space n \ge 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord">−</span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></span></p><p>【总结】求解乘法逆元的方法</p><ul><li>扩展欧几里得算法</li><li>费马小定理+快速幂直接求解</li><li>线性递推</li></ul><p>这一部分的参考代码可以看<a href="https://hwcoder.top/LeetCode-Math#%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83">这篇博客</a></p><h3 id="633-快速幂"><a class="markdownIt-Anchor" href="#633-快速幂"></a> 6.3.3 快速幂</h3><p>计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">a^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，传统做法是依次乘，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。根据二分法的思想，可以计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mn>2</mn></msup><mo>⋅</mo><msup><mi>a</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">a^2 \cdot a^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>将时间复杂度化为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><p>递归写法：注意乘方会导致int类型数据溢出，因此使用long long类型并取模</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> (<span class="built_in">qpow</span>(a, n<span class="number">-1</span>) * a) % MOD;</span><br><span class="line">    ll tmp = <span class="built_in">qpow</span>(a,n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> (tmp*tmp) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环写法：节省栈开销。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mn>1001</mn></msup></mrow><annotation encoding="application/x-tex">a^{1001}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>可以写成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mn>1000</mn></msup><mo>⋅</mo><msup><mi>a</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">a^{1000}\cdot a^{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>. 通过把指数转化为二进制进行计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            ans *= a;</span><br><span class="line">        &#125;</span><br><span class="line">        a *= a;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="64-矩阵计算"><a class="markdownIt-Anchor" href="#64-矩阵计算"></a> 6.4 矩阵计算</h2><h3 id="641-高斯消元"><a class="markdownIt-Anchor" href="#641-高斯消元"></a> 6.4.1 高斯消元</h3><p>求解<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi><mo separator="true">,</mo><mi>A</mi><mo>∈</mo><msup><mi>R</mi><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow></msup><mo separator="true">,</mo><mi>x</mi><mo>∈</mo><msup><mi>R</mi><mrow><mi>m</mi><mo>×</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><msup><mi>R</mi><mrow><mi>n</mi><mo>×</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">Ax=b, A\in R^{n\times m}, x\in R^{m\times 1}, b\in R^{n\times 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9657709999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">×</span><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">×</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">×</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p><p>基本思想：构造矩阵[A,b]</p><ol><li>从上往下消元 -&gt; 形成三角矩阵</li><li>从下往上消元 -&gt; 形成对角矩阵</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-7</span>;<span class="comment">// 精度值</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123; <span class="comment">// 矩阵从数组的第一行第一列开始</span></span><br><span class="line">        <span class="type">int</span> r = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i]) &gt; <span class="built_in">fabs</span>(a[r][i])) r = j; <span class="comment">// fabs用于计算浮点数的绝对值，找到该列绝对值最大的行，减少浮点计算误差</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[r][i]) &lt; eps)<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不存在唯一解</span></span><br><span class="line">        <span class="keyword">if</span>(r != i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i;j &lt; n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[r][j],a[i][j]); <span class="comment">// 交换绝对值最大的值所在行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt;= n;j++)&#123;</span><br><span class="line">            <span class="type">double</span> tmp = a[j][i] / a[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i;k &lt;= n+<span class="number">1</span>;k++)a[j][k] -= tmp * a[i][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>; j &lt;= n;j++)a[i][n+<span class="number">1</span>] -= a[j][n+<span class="number">1</span>]*a[i][j];</span><br><span class="line">        a[i][n+<span class="number">1</span>] /= a[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="642-矩阵乘法"><a class="markdownIt-Anchor" href="#642-矩阵乘法"></a> 6.4.2 矩阵乘法</h3><p>可以用于处理一些递推关系，比如斐波那契数列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mi>n</mi></msub><mo>=</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">F_n = F_{n-1}+F_{n-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>F</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>F</mi><mi>n</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>×</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>F</mi><mi>n</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex"> \begin{bmatrix} F_{n-1} &amp; F_n \end{bmatrix} \times \begin{bmatrix} 0 &amp; 1 \\ 1 &amp; 1 \end{bmatrix} = \begin{bmatrix} F_n &amp; F_{n+1} \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span></span></span></span></span></p><p>【矩阵求幂】<strong>快速幂</strong>优化。下述模板只是矩阵乘法的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    i64 v[n][m];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="built_in">sizeof</span>(v));&#125;</span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> *(<span class="type">const</span> Matrix&amp; x, <span class="type">const</span> Matrix&amp; y)&#123;</span><br><span class="line">        Matrix ret;</span><br><span class="line">        ret.n = x.n;ret.m = y.m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; ret.n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; ret.m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; x.m;x++)&#123;</span><br><span class="line">                    ret.v[i][j] += x.v[i][k]*y.v[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="65-组合数"><a class="markdownIt-Anchor" href="#65-组合数"></a> 6.5 组合数</h2><p>求解组合数可以通过递归和阶乘两种方式求解</p><h3 id="651-杨辉三角"><a class="markdownIt-Anchor" href="#651-杨辉三角"></a> 6.5.1 杨辉三角</h3><p>杨辉三角揭示了组合数的递归规律，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>i</mi><mi>j</mi></msubsup><mo>=</mo><msubsup><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mi>j</mi></msubsup><mo>+</mo><msubsup><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">C_i^j = C_{i-1}^j+C_{i-1}^{j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.219436em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.942572em;"><span style="top:-2.4231360000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2777669999999999em;vertical-align:-0.335195em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.942572em;"><span style="top:-2.423136em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.335195em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2777669999999999em;vertical-align:-0.335195em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.942572em;"><span style="top:-2.423136em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.335195em;"><span></span></span></span></span></span></span></span></span></span>。同时对于任意<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>≥</mo><mn>1</mn><mo separator="true">,</mo><msubsup><mi>C</mi><mi>i</mi><mn>0</mn></msubsup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i \ge 1, C_i^0 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.072772em;vertical-align:-0.258664em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getBinom</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        c[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; i;j++)&#123;</span><br><span class="line">            c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h3 id="652-组合阶乘"><a class="markdownIt-Anchor" href="#652-组合阶乘"></a> 6.5.2 组合阶乘</h3><p>原理：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>i</mi><mi>j</mi></msubsup><mo>=</mo><mfrac><mrow><mi>i</mi><mo stretchy="false">!</mo></mrow><mrow><mi>j</mi><mo stretchy="false">!</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">C_i^j = \frac{i!}{j!(i-j)!}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.219436em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.942572em;"><span style="top:-2.4231360000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.1809080000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.400108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">!</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">)</span><span class="mclose mtight">!</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mclose mtight">!</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，计算阶乘复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，可以直接使用除法，也可以使用前面所说的乘法逆元（当对大数取模且P是质数时）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fac[N], ifac[N]; <span class="comment">// fac记录阶乘，ifac记录阶乘对应模P逆元</span></span><br><span class="line">fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getFac</span><span class="params">(<span class="type">int</span> maxn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= maxn;i++)&#123;</span><br><span class="line">        fac[i] = <span class="number">1LL</span>*fac[i<span class="number">-1</span>]*i % P;</span><br><span class="line">    &#125;</span><br><span class="line">    ifac[maxn] = <span class="built_in">fpow</span>(fac[maxn],P<span class="number">-2</span>); <span class="comment">// 使用费马小定理和快速幂求解逆元</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = maxn<span class="number">-1</span>;i &gt;= <span class="number">1</span>;i--) ifac[i] = <span class="number">1LL</span>*ifac[i+<span class="number">1</span>]*(i+<span class="number">1</span>) % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binom</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[i]*(ifac[j] % P )*(ifac[i-j] % P)*<span class="number">1LL</span> % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="66-随机"><a class="markdownIt-Anchor" href="#66-随机"></a> 6.6 随机</h2><ul><li>带有权重的随机<a href="https://leetcode.cn/problems/random-pick-with-weight/description/">leetcode 528.Random Pick with Weight</a></li><li>用某个范围随机数生成另一些随机数<a href="https://leetcode.cn/problems/implement-rand10-using-rand7/description/">leetcode 470.Implement Rand10 Using Rand7</a></li><li>使用随机数计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span>：利用面积公式，计算随机点落入圆的概率</li></ul><h3 id="661-java随机数"><a class="markdownIt-Anchor" href="#661-java随机数"></a> 6.6.1 java随机数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> rand.nextInt(<span class="number">100</span>)+<span class="number">1</span>; <span class="comment">//生成1-100（包括）的整数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random()*<span class="number">100</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Math.random()</code>随机生成[0.0,1.0)之间的double类型数据</p><h3 id="662-c随机数"><a class="markdownIt-Anchor" href="#662-c随机数"></a> 6.6.2 c++随机数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> t = <span class="built_in">rand</span>() % num; </span><br></pre></td></tr></table></figure><h2 id="67-求解平方根"><a class="markdownIt-Anchor" href="#67-求解平方根"></a> 6.7 求解平方根</h2><h3 id="671-二分法"><a class="markdownIt-Anchor" href="#671-二分法"></a> 6.7.1 二分法</h3><p>初始化为x/2，然后不断除2逼近</p><h3 id="672-牛顿迭代法"><a class="markdownIt-Anchor" href="#672-牛顿迭代法"></a> 6.7.2 牛顿迭代法</h3><p>设置一个近似值x（可以是n/2），然后不断用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>x</mi><mo>+</mo><mfrac><mi>a</mi><mi>x</mi></mfrac></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{x+ \frac{a}{x}}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.37988em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.03488em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5508em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>迭代逼近</p><p>画图可以得到以下递推关系：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><msub><mi>θ</mi><mi>t</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>θ</mi><mi>t</mi></msub><mo stretchy="false">)</mo><mo>−</mo><mi>n</mi></mrow><mrow><msub><mi>θ</mi><mi>t</mi></msub><mo>−</mo><msub><mi>θ</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">f&#x27;(\theta_t) = \frac{f(\theta_t)-n}{\theta_t - \theta_{t+1}} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.321331em;vertical-align:-0.894331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.894331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h2 id="68-回文数字"><a class="markdownIt-Anchor" href="#68-回文数字"></a> 6.8 回文数字</h2><p>从小到大依次生成回文数字，基本思想：固定回文根，如12，那么可以生成奇数位和偶数位两种回文数，121和1221.</p><p>算法过程：枚举范围内所有回文根（按照位数枚举）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n表示最大范围数位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> base = <span class="number">1</span>;base &lt; n;base *= <span class="number">10</span>)&#123;</span><br><span class="line">    <span class="comment">// 生成奇数位回文数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = base;i &lt; base*<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i/<span class="number">10</span>;j;j /= <span class="number">10</span>)&#123;</span><br><span class="line">            x = x*<span class="number">10</span>+j % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存储或操作生成的x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(base &lt;= n/<span class="number">2</span>)&#123; <span class="comment">// 不超过最大范围</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = base;i &lt; base*<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i;j;j /= <span class="number">10</span>)&#123;</span><br><span class="line">                x = x*<span class="number">10</span>+j % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//存储或操作生成的x</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文档总结了非ACMer应知应会基础算法cpp版本，不涉及算法详解，适合（保研机考/找实习）复习框架使用。&lt;/p&gt;
&lt;p&gt;大部分资料来源与互联网各大佬的总结与整理，此处作为复习整合。此外非常感谢学长提供的算法模板手册！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;施工建设中……</summary>
      
    
    
    
    <category term="Knowledge" scheme="https://aliceraylu.github.io/categories/Knowledge/"/>
    
    <category term="Algorithm" scheme="https://aliceraylu.github.io/categories/Knowledge/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>【前端八股】Roadmap</title>
    <link href="https://aliceraylu.github.io/2024/01/19/technology/frontend/roadmap/"/>
    <id>https://aliceraylu.github.io/2024/01/19/technology/frontend/roadmap/</id>
    <published>2024-01-18T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.500Z</updated>
    
    <content type="html"><![CDATA[<p>参考与详细的路线图：<a href="https://roadmap.sh/frontend">🔗frontend roadmap</a></p><ul><li><a href="https://aliceraylu.github.io/2024/01/14/technology/frontend/HTTPbasic/">Internet &amp; browser</a></li><li><a href="">HTML</a></li><li><a href="">CSS</a></li><li><a href="">JavaScript</a></li><li><a href="">Frameworks</a></li><li><a href="">git</a></li></ul><p>以上是本人整理的部分材料，也参考了很多网上的资料，以下是完整的参考资料：</p><ul><li><a href="https://vue3js.cn/interview/">前端八股大全</a>：这一份比较粗浅，适合快速阅读理清关键知识点主干，建议前期上手时阅读</li><li><a href="https://juejin.cn/post/6959043611161952269">详细八股</a>：这位作者的全系列非常详细，特别是手写题和浏览器原理题写的特别好</li><li><a href="https://juejin.cn/post/7029973323475845150">前端性能优化</a>：问项目的时候很喜欢问一些可以优化的点以及复盘</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考与详细的路线图：&lt;a href=&quot;https://roadmap.sh/frontend&quot;&gt;🔗frontend roadmap&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://aliceraylu.github.io/2024/01/14/tech</summary>
      
    
    
    
    <category term="Technology" scheme="https://aliceraylu.github.io/categories/Technology/"/>
    
    <category term="Frontend" scheme="https://aliceraylu.github.io/categories/Technology/Frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>24 Summer Intern 面试记录</title>
    <link href="https://aliceraylu.github.io/2024/01/14/stories/24SummerIntern/"/>
    <id>https://aliceraylu.github.io/2024/01/14/stories/24SummerIntern/</id>
    <published>2024-01-13T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="timeline"><a class="markdownIt-Anchor" href="#timeline"></a> Timeline</h1><table><thead><tr><th style="text-align:left">公司/职位/base</th><th style="text-align:center">投递时间</th><th style="text-align:center">通知时间</th><th style="text-align:center">一面时间</th><th style="text-align:center">二面时间</th><th style="text-align:center">offer</th></tr></thead><tbody><tr><td style="text-align:left">Google / SE summer intern / Shanghai</td><td style="text-align:center">12.16</td><td style="text-align:center">12.19（补充学历成绩等信息，面试时间）12.26（收到recruiter邮件）</td><td style="text-align:center">1.15</td><td style="text-align:center">1.17</td><td style="text-align:center">1.24挂</td></tr><tr><td style="text-align:left">Microsoft / SWE intern / Shanghai or Beijing</td><td style="text-align:center">2.2</td><td style="text-align:center">2.14（填写问卷）</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">vivo / frontend intern / Nanjing</td><td style="text-align:center">2.21</td><td style="text-align:center">2.25（填写测评）</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">美团 / 前端实习 / Shanghai or Beijing</td><td style="text-align:center">2.26</td><td style="text-align:center">3.8（参与3.9笔试）</td><td style="text-align:center">3.25（美团平台）4.2（美团到店）</td><td style="text-align:center">3.26（美团平台）4.10（美团到店）</td><td style="text-align:center">3.27美团平台挂 4.11 offer</td></tr><tr><td style="text-align:left">网易雷火 / web前端实习 / Hangzhou</td><td style="text-align:center">2.27</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">腾讯 / web前端 / ？</td><td style="text-align:center">2.28</td><td style="text-align:center">3.11（腾讯云捞）</td><td style="text-align:center">3.12（腾讯云）3.25（信息安全）4.18（企业微信-放弃）</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Morgan Stanley/ IT技术部实习 / Shanghai</td><td style="text-align:center">2.29</td><td style="text-align:center">3.1（fast track预约面试时间）3.8（online assessment）</td><td style="text-align:center">3.6电面</td><td style="text-align:center">4.15（AC面）</td><td style="text-align:center">4.24（oc）</td></tr><tr><td style="text-align:left">Mihoyo / 前端 / Shanghai</td><td style="text-align:center">2.29</td><td style="text-align:center">3.17笔试</td><td style="text-align:center">4.1(本来约3.27，面试官有事改时间)</td><td style="text-align:center">4.10</td><td style="text-align:center">4.11挂</td></tr><tr><td style="text-align:left">小米 / 前端开发 / Nanjing</td><td style="text-align:center">3.4</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">4.12简历挂</td></tr><tr><td style="text-align:left">拼多多 / 前端 / Shanghai</td><td style="text-align:center">3.4</td><td style="text-align:center">3.24笔试</td><td style="text-align:center">4.7</td><td style="text-align:center">4.14（拒绝二面）</td><td style="text-align:center">据说有四面？</td></tr><tr><td style="text-align:left">京东 / 前端 / Shanghai or Beijing</td><td style="text-align:center">3.4</td><td style="text-align:center">4.2</td><td style="text-align:center">4.8</td><td style="text-align:center"></td><td style="text-align:center">日常实习拒</td></tr><tr><td style="text-align:left">携程 / 前端 / Shanghai</td><td style="text-align:center">3.4</td><td style="text-align:center">3.11（3.13笔试）</td><td style="text-align:center">3.20</td><td style="text-align:center">3.27</td><td style="text-align:center">默拒</td></tr><tr><td style="text-align:left">蚂蚁 / 前端 / Shanghai</td><td style="text-align:center">3.8</td><td style="text-align:center">3.14简历挂</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">恒生 / 前端 / Hangzhou</td><td style="text-align:center">3.8</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">华为 / 终端云服务部 / Shanghai or Nanjing</td><td style="text-align:center">3.17</td><td style="text-align:center">4.10笔试</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">淘天 / 前端 / Hangzhou</td><td style="text-align:center">3.18</td><td style="text-align:center"></td><td style="text-align:center">4.10</td><td style="text-align:center">4.18</td><td style="text-align:center">4.23hr面</td></tr><tr><td style="text-align:left">SAP / developer intern / Shanghai</td><td style="text-align:center">3.18</td><td style="text-align:center">4.1笔试</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">hr面拒</td></tr></tbody></table><h1 id="信息来源"><a class="markdownIt-Anchor" href="#信息来源"></a> 信息来源</h1><p>大部分企业都会在官方“xx招聘”公众号上发布暑期实习的相关内容，对于国内的一些企业辅导员或校方也会发布信息，及时关注这些信息，注意截止的一些时间点，越早投递越好。</p><h1 id="简历内容"><a class="markdownIt-Anchor" href="#简历内容"></a> 简历内容</h1><p>个人简历是23暑期就准备好的，内容：华五本+较高GPA以及排名+一些比赛/大作业项目+一些水奖项和奖学金。没有托福雅思，但是有较高（630+）四六级，尚不清楚英语水平是否在简历筛选范围内。</p><h1 id="google"><a class="markdownIt-Anchor" href="#google"></a> Google</h1><p>google一般都是最早开始暑期实习招聘的，2023年是12月14号开始暑期实习的招聘的。我通过关注官方微信公众号&quot;google招聘包打听&quot;看到的职位信息，因此很早就开始投递了。同时本人没有找内推，在等待面试通知时花了较长时间，一度以为简历就挂了（也有可能外企要放圣诞假期？）。总之收到recruiter邮件时还是很开心的。</p><p>一面二面都是45min，在google meet里面视频，另外开一个google doc类似于共享文档的记事本写代码。</p><h2 id="google一面"><a class="markdownIt-Anchor" href="#google一面"></a> Google一面</h2><p>英文面，上来先是打印二叉树，需要打印成&quot;human can understand&quot;。。。然后在那边空格对齐写了老半天，感觉浪费了太多的时间。</p><p>第二题是数组里面找出最大的奇数，变形题是找到第k大的奇数。直接回答了一下用堆，由于二叉树写太久了没来得及写完堆。</p><h2 id="google二面"><a class="markdownIt-Anchor" href="#google二面"></a> Google二面</h2><p>中文面，又是类似二叉树，把一个字符串分到了各个叶子节点，父节点保存子节点的长度和。第一个问题让设计了一个结构来表示这个树，我定义了一个结构体同时保存string和len。没有想出可以在父节点不用string来节省空间的方法，后来想想也许用继承？（很久没有用c++写面向对象了）</p><p>第二个问题是查询字符串中第k个字符所在的位置。这个按照传统的递归做法即可。然后需要自己设计测试用例，考虑一些边界情况，来验证和修改自己的代码。最后是说一下自己写的时间复杂度和空间复杂度。</p><p>整体感觉难度好像还行，没有想象中那么难，但是让我写打印二叉树是属实没有想到的，大概率最后挂是挂在了一面，写打印二叉树花了太久的时间在计算对齐的空格个数上，还是学艺不精吧 :==(</p><h1 id="morgan-stanley"><a class="markdownIt-Anchor" href="#morgan-stanley"></a> Morgan Stanley</h1><h2 id="online-assessment"><a class="markdownIt-Anchor" href="#online-assessment"></a> online assessment</h2><p>包括选择和编程题。选择题大部分是计算机基础，包括数据库操作系统之类的问题。</p><p>编程题2道都不难，但是第二道有3个隐藏用例没过，不知道是什么细节出错了。</p><h2 id="电面"><a class="markdownIt-Anchor" href="#电面"></a> 电面</h2><p>涉及的方面比较多，包括c++，Java，OS，DB以及数据结构。但是内容相对固定，就是传统的一些问题。算法题刚好问到了数据流的中位数，前两天刚做过印象深刻。（主要是看微软面经看到了这道题，就去做了一下，没想到外企题库出奇地一致啊）</p><p>internet: TCP/UDP<br />c++：stack/heap，abstract class (example), smart pointer<br />java：garbage collection(advantage / disadvantage)<br />os：process/threads, dead lock, starving<br />db: index, primary key, foreign key, inner/outer join<br />Algorithm：linked list(head node), BST, time complexity of operations</p><h2 id="ac面"><a class="markdownIt-Anchor" href="#ac面"></a> AC面</h2><p>30min编程+45min技术面一+45min技术面二，一下午结束</p><p>两道很难的编程题，合起来就做出来一道，一下子心凉了。。。</p><p>后续两轮面试问题中规中矩</p><h1 id="美团"><a class="markdownIt-Anchor" href="#美团"></a> 美团</h1><h2 id="笔试"><a class="markdownIt-Anchor" href="#笔试"></a> 笔试</h2><p>实习生笔试分为两部分，一部分是选择题，包括很多基础知识，数据库、编译原理、os、计组、设计模式以及一些数学题，主要是找规律和鸡兔同笼类似的简单计算题。</p><p>另一部分是两道easy级别的算法题，没想到算法题那么简单，一个小时就提交了前面的选择题，不能回去改了，早知道多花点时间好好考虑选择题了呜呜。</p><h2 id="美团平台一面"><a class="markdownIt-Anchor" href="#美团平台一面"></a> 美团平台一面</h2><p>根据简历侃大山，聊了一堆无关前端的内容。为什么选前端，简历写包括其他语言。</p><p>然后先开始问项目，说了微信小程序，就开始问微信小程序的生命周期函数。然后使用vue做过的项目？最有意义的项目？深度参与的项目？</p><p>有关生命周期，vue生命周期，react生命周期，父子组件的生命周期函数执行顺序；axios封装。</p><p>computed&amp;watch</p><p>js基础，promise解决什么问题，有哪些方法，浏览器轮询event loop。</p><p>有关组件通信，父子组件，子组件向父组件传递。</p><p>计算机网络相关：网络模型，网络协议，三次握手，四次挥手</p><p>学的最好的专业课？</p><p>用js写快速排序，冒泡排序</p><h2 id="美团平台二面"><a class="markdownIt-Anchor" href="#美团平台二面"></a> 美团平台二面</h2><p>上来聊了很久的项目，问了些关于协作沟通性能优化的思考。</p><p>然后写了一道算法题<a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/description/">最小栈</a>（结果我f**ked in my head没写出来蠢哭了）</p><p>面试官看我用c++考了一道指针题，结果还答错了，属实是自己给自己挖坑跳了。。。</p><p>总结：美团的两位面试官还是很nice的，面试体验也很好，（下次还来 x）</p><h1 id="腾讯"><a class="markdownIt-Anchor" href="#腾讯"></a> 腾讯</h1><h2 id="腾讯云"><a class="markdownIt-Anchor" href="#腾讯云"></a> 腾讯云</h2><p>上来先写两个题：一个题在原型上重写数组的find方法，使用一个滑动窗口求一个特殊规则形成数组的值</p><p>什么是http？http报文格式？什么是闭包？闭包的优缺点。</p><p>有没有使用过异步，有哪些异步方法</p><p>为什么选择前端？</p><h2 id="腾讯信息安全"><a class="markdownIt-Anchor" href="#腾讯信息安全"></a> 腾讯信息安全</h2><p>讲一讲印象最深的项目，难点，解决方案</p><p>http和https，追问非对称加密，每个过程？</p><p>vuex的使用？没用过：讲父子组件和子组件通信</p><p>做题：LRU cache 允许用别的语言，就用c<ins>了笑。（面试官绷不住了，说前两天面了一个也是用c</ins>的，笑死）双链表+哈希表</p><h2 id="笔试-2"><a class="markdownIt-Anchor" href="#笔试-2"></a> 笔试</h2><p>腾讯前端笔试不考算法，一些有关界面和js操作的代码填空题，允许使用本地ide，现场提交直接能看到成绩，因此可以慢慢改到100分，相对比较简单</p><h2 id="wxg"><a class="markdownIt-Anchor" href="#wxg"></a> WXG</h2><p>后来经过笔试又被wxg捞起来了，但是一是不太想去sh以外的城市，二是面试太多了太累了，因此彻底放弃面试机会了</p><h1 id="携程"><a class="markdownIt-Anchor" href="#携程"></a> 携程</h1><h2 id="笔试-3"><a class="markdownIt-Anchor" href="#笔试-3"></a> 笔试</h2><p>4道编程，1道签到题，1道前缀和优化题（脑子抽了最后才想出来，有个小bug没来得及修好），1道模拟题（好好处理爆int型数据即可通过），1道比较难的题目（没来得及做）</p><p>最后通过了2.5/4（其实可以3/4的），拿到第一批面试机会</p><h2 id="一面复盘"><a class="markdownIt-Anchor" href="#一面复盘"></a> 一面复盘</h2><ol><li>什么是事件循环？</li><li>宏任务，微任务分别是哪些</li><li>promise是什么，解决什么问题，怎么解决回调地狱的问题？.then有返回值吗？</li><li>普通函数和箭头函数区别</li><li>闭包，使用时要注意什么</li><li>什么是防抖，什么是节流</li><li>react虚拟dom</li><li>react diff算法</li><li>vue的key</li><li>git reset revert，reset soft和hard区别，有三次提交，要删除第一次，保持第二次和第三次</li><li>两栏布局：左边栏固定，右栏填满</li><li>margin重叠</li><li>从输入url到浏览器展示的过程，js线程，渲染线程</li><li>xss攻击，csrf</li><li>typescript工具</li><li>interface和type</li></ol><p>感觉大多数答得都一知半解，这样很不好，一旦被追问就露馅了。。。</p><h2 id="二面复盘"><a class="markdownIt-Anchor" href="#二面复盘"></a> 二面复盘</h2><p>没想到一面面的那么烂还是有二面邀请，但是二面更烂捏。。。</p><p>开始聊项目，然后问了项目里面vue组件通信的问题。</p><p>接下来问有关vue框架的一些八股：</p><ul><li>vue生命周期（项目里面怎么用，用哪些函数）</li><li>watch，computed（computed的危害？）</li><li>v-if和v-show区别</li><li>有没有用过nexttick</li><li>有没有用过keep-alive</li><li>知不知道vue的底层原理</li><li>vue3有什么特性</li></ul><p>框架了解的确实不多，然后开始做基础手写题</p><ul><li>布局：上中下三栏布局，上下固定宽高，中间自适应（使用flex，由于样式直接写在html标签里面被狠狠批评了www；然后看我用了html5的语义化标签，问了一下html5的特性，哪些语义化标签，想不起来了之后问了localstorage,sessionstorage这两个）</li><li>js操作dom：随机生成50个50*50的小方块，然后隐藏</li></ul><p>基础不牢，地动山摇！！！</p><h1 id="米哈游"><a class="markdownIt-Anchor" href="#米哈游"></a> 米哈游</h1><h2 id="笔试-4"><a class="markdownIt-Anchor" href="#笔试-4"></a> 笔试</h2><p>10道单选，10道不定项选择，3道编程</p><p>单选和不定项包括了操作系统、前端基础、计算机网络等一些杂糅的内容。编程题1道签到题，1道贪心，1道简易数学题枚举？</p><p>最后提前交卷了。。。</p><h2 id="一面"><a class="markdownIt-Anchor" href="#一面"></a> 一面</h2><ol><li>基础数据结构知识<ul><li>队列、栈，使用队列实现栈，使用栈实现队列</li><li>哈希表和数组的区别，哈希表冲突如何解决</li></ul></li><li>计算机网络：http原理；如何保持长连接</li><li>计算机操作系统：进程和线程，死锁，资源，如何解决死锁</li><li>js相关<ul><li>js基本数据类型，symbol有什么用；</li><li>如何用堆栈存储变量；垃圾清除算法（循环引用的解决方案？）</li><li>数组常用的方法有哪些，手写reduce</li></ul></li><li>css：flex:1缩写原理</li><li>最长无重复字符的算法题</li></ol><h2 id="二面"><a class="markdownIt-Anchor" href="#二面"></a> 二面</h2><p>不太记得了，似乎面试官对大模型很感兴趣一直在问我对大模型的相关看法，感觉像是，招满人之后被kpi面了，最后不出意外挂掉了，但是同一天收到了团子的offer，对冲悲伤~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;timeline&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#timeline&quot;&gt;&lt;/a&gt; Timeline&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;公司/职位/ba</summary>
      
    
    
    
    <category term="Stories" scheme="https://aliceraylu.github.io/categories/Stories/"/>
    
    
  </entry>
  
  <entry>
    <title>【前端八股】计算机网络</title>
    <link href="https://aliceraylu.github.io/2024/01/14/technology/frontend/HTTP/"/>
    <id>https://aliceraylu.github.io/2024/01/14/technology/frontend/HTTP/</id>
    <published>2024-01-13T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-网络工作原理"><a class="markdownIt-Anchor" href="#1-网络工作原理"></a> 1 网络工作原理</h1><h2 id="11-网络模型"><a class="markdownIt-Anchor" href="#11-网络模型"></a> 1.1 网络模型</h2><p>网络模型共有两种，OSI七层模型和TCP/IP四层模型</p><table>    <tr>        <th>OSI七层模型</th>        <th>TCP/IP四层模型</th>    </tr>    <tr>        <td> application (应用层) </td>        <td rowspan=3> application (应用层) </td>    </tr>    <tr>        <td> presentation (展示层) </td>    </tr>    <tr>        <td> session (会话层) </td>    </tr>    <tr>        <td> transport (传输层) </td>        <td>  transport (传输层) </td>    </tr>    <tr>        <td> network (网络层) </td>        <td> network (网络层) </td>    </tr>    <tr>        <td> data link (数据链路层) </td>        <td rowspan=2> link (链路层) </td>    </tr>    <tr>        <td> physical (物理层) </td>    </tr></table><h2 id="12-传输层"><a class="markdownIt-Anchor" href="#12-传输层"></a> 1.2 传输层</h2><ul><li>传输层提供<strong>端到端</strong>的通信，即进程和进程之间的通信。（端口标识进程）</li><li>传输层需要对报文进行差错检测</li><li>提供TCP和UDP两种不同的传输协议</li></ul><p>【端口】<br />端口号长度为16bit，范围0-65535，熟知端口号0-1023</p><p>FTP-21，TELNET-23，SMTP-25，DNS-53，HTTP-80，HTTPS-443</p><p>【套接字】IP:Port<br />ip地址和端口号唯一确定网络中的通信进程</p><h3 id="121-udp"><a class="markdownIt-Anchor" href="#121-udp"></a> 1.2.1 UDP</h3><p>user data protocol-无连接的非可靠传输协议，仅提供多路复用和对数据的错误检查两种服务。</p><p>主要用于对实时性有高要求的应用，包括<strong>DNS</strong>、TFTP、SNMP、RTP(实时传输协议)</p><p>UDP首部为固定的8B，包括源端口号、目的端口号、长度、校验和（校验和的计算请查看计网部分内容复习）</p><p><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/technology/frontend/assets/udp.png?raw=true" alt="UDP数据报格式" /></p><p>请注意，真实情况下UDP首部还会包括一个12B伪首部，所以udp数据报的真实结构：伪首部+首部+数据，这个伪首部实际上是ip数据报的首部</p><h3 id="122-tcp"><a class="markdownIt-Anchor" href="#122-tcp"></a> 1.2.2 TCP</h3><p>transmission control protocol-面向连接的可靠服务，不提供广播或者组播服务，包括确认、流量控制、拥塞管理等。</p><p>常见应用：FTP、<strong>HTTP</strong>、TELNET</p><p>TCP首部包含固定20B和可变部分</p><p><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/technology/frontend/assets/tcp.png?raw=true" alt="TCP数据报格式" /></p><h4 id="1221-建立连接-三次握手"><a class="markdownIt-Anchor" href="#1221-建立连接-三次握手"></a> 1.2.2.1 建立连接-三次握手</h4><p><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/technology/frontend/assets/3shake.png?raw=true" alt="三次握手" /></p><ol><li>客户端发送带SYN标志的数据包，发送一个随机序列号</li><li>接收端/服务端收到后返回带有SYN和ACK标志的数据包，确认收到的序列号(ack=x+1)并发送自己的SYN包(seq=y)</li><li>客户端向服务端发送确认包，两者都进入established状态开始传输数据</li></ol><h4 id="1222-释放连接-四次挥手"><a class="markdownIt-Anchor" href="#1222-释放连接-四次挥手"></a> 1.2.2.2 释放连接-四次挥手</h4><p><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/technology/frontend/assets/4shake.png?raw=true" alt="四次挥手" /></p><ol><li>客户端发送带FIN标志的数据包以及当前传输数据序列号</li><li>服务端向客户端发送ACK确认数据包，并将剩余数据继续传输</li><li>服务端将所有数据传输完毕后，向客户端发送FIN和ACK数据包</li><li>客户端收到报文后发送确认数据报，服务端接收后进入closed状态，客户端在等待2*MSL（最长报文段寿命）后进入closed状态</li></ol><p>客户端和服务端的任何一方都可以主动发起释放连接的请求</p><h4 id="1223-重传"><a class="markdownIt-Anchor" href="#1223-重传"></a> 1.2.2.3 重传</h4><p>超时和冗余ACK会触发TCP重传</p><ul><li><strong>超时</strong>：对每个发送报文段设置一个计时器，重传时间到期但是未收到确认就要自动重传。</li><li><strong>冗余ACK</strong>：发送方收到了两次某个报文段的ACK，通常在比当前期望的序号大的报文到达时，再次发送前面已经接收到的报文序列ACK</li></ul><h4 id="1224-流量控制"><a class="markdownIt-Anchor" href="#1224-流量控制"></a> 1.2.2.4 流量控制</h4><p>基于滑动窗口协议控制流量，确认报文携带允许传输的窗口大小，进行端到端的调整</p><h4 id="1225-拥塞控制"><a class="markdownIt-Anchor" href="#1225-拥塞控制"></a> 1.2.2.5 拥塞控制</h4><p>拥塞控制一共有4种算法：</p><ul><li><strong>慢开始</strong>：将发送方的拥塞窗口先置为1（一个最大报文段长度），收到确认后逐步增大拥塞窗口（加倍：1-&gt;2, 2-&gt;4）<br />在慢开始达到了规定阈值后，改用拥塞避免算法</li><li><strong>拥塞避免</strong>：每经过一个往返时延RTT将拥塞窗口加1，出现拥塞时（未按时收到确认），将拥塞窗口重新设为1，重新执行慢开始算法（慢开始阈值改为一半？）</li><li><strong>快重传</strong>：通过发送冗余ACK包的方式来触发重传</li><li><strong>快恢复</strong>：把慢开始的阈值设为当前窗口大小的一半，然后使用拥塞避免算法将窗口缓慢增大（逐步加1）。【相当于跳过了窗口降为1的过程】</li></ul><h4 id="1225-粘包问题"><a class="markdownIt-Anchor" href="#1225-粘包问题"></a> 1.2.2.5 粘包问题</h4><p>数据包头尾相连</p><h4 id="1226-客户端与服务端建立长连接的方式"><a class="markdownIt-Anchor" href="#1226-客户端与服务端建立长连接的方式"></a> 1.2.2.6 客户端与服务端建立长连接的方式</h4><p>websocket：一次握手建立连接，全双工通信，服务器可以主动发送信息</p><h4 id="1227-通过socket建立连接"><a class="markdownIt-Anchor" href="#1227-通过socket建立连接"></a> 1.2.2.7 通过socket建立连接</h4><h1 id="2-httphttps"><a class="markdownIt-Anchor" href="#2-httphttps"></a> 2 HTTP/HTTPS</h1><p>超文本传输协议，用于从服务器传输超文本内容给客户端浏览器</p><p>更加详细内容参考<a href="https://blog.csdn.net/renxingzhadan/article/details/118946176">这篇博客</a></p><h2 id="21-http请求和响应步骤"><a class="markdownIt-Anchor" href="#21-http请求和响应步骤"></a> 2.1 HTTP请求和响应步骤</h2><ol><li>客户端和服务端之间建立TCP连接</li><li>客户端发送http请求（POST方法需要带上请求体）</li><li>服务端接受请求并返回对应状态信息和数据</li><li>释放TCP连接，除非要求connection keep alive</li><li>浏览器解析并渲染</li></ol><h2 id="22-http请求类型"><a class="markdownIt-Anchor" href="#22-http请求类型"></a> 2.2 HTTP请求类型</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">GET</td><td style="text-align:left">请求指定页面信息，返回实体</td></tr><tr><td style="text-align:left">POST</td><td style="text-align:left">向指定资源提交数据处理请求，需要携带请求体</td></tr><tr><td style="text-align:left">HEAD</td><td style="text-align:left">类似get请求，返回响应中没有具体内容，通常用于获取报头</td></tr><tr><td style="text-align:left">DELETE</td><td style="text-align:left">请求服务器删除指定资源</td></tr><tr><td style="text-align:left">PUT</td><td style="text-align:left">从客户端向服务器传送数据取代指定的内容</td></tr><tr><td style="text-align:left">TRACE</td><td style="text-align:left">回显服务器收到请求，用于测试或者诊断</td></tr><tr><td style="text-align:left">OPTIONS</td><td style="text-align:left">允许客户端查看服务器性能</td></tr><tr><td style="text-align:left">CONNECT</td><td style="text-align:left">将连接改为管道方式的代理服务器</td></tr></tbody></table><p>【GET和POST的区别】</p><ol><li>浏览器回退表现不同：GET在浏览器回退时是无害的，而POST会再次提交请求（如表单等数据）</li><li>浏览器对请求地址的处理不同：GET请求地址会被浏览器主动缓存，而POST不会，除非手动设置</li><li>浏览器对响应的处理不同：GET请求参数会被完整的保留在浏览器<strong>历史记录</strong>里，而POST中的参数不会被保留；GET请求获取的资源可以作为书签保存，POST不可以</li><li><strong>参数大小</strong>不同：GET请求在URL中传送的参数是有长度的限制，而POST没有限制</li><li><strong>安全性</strong>不同. GET参数通过URL传递，会暴露，不安全；POST放在Request Body中，相对更安全</li><li>针对<strong>数据操作</strong>的类型不同：GET对数据进行查询，POST主要对数据进行增删改！简单说，GET是只读，POST是写。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li></ol><h2 id="23-http报文"><a class="markdownIt-Anchor" href="#23-http报文"></a> 2.3 HTTP报文</h2><h3 id="231-请求报文"><a class="markdownIt-Anchor" href="#231-请求报文"></a> 2.3.1 请求报文</h3><ul><li>请求行：方法+URL+HTTP协议版本</li><li>请求头：每一行：一个头部字段名+值</li><li>空行</li><li>请求体：post携带的数据</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /sample.Jsp HTTP/1.1                               //请求行</span><br><span class="line">Host  www.uuid.online/                                 //请求的目标域名和端口号</span><br><span class="line">Origin  http://localhost:8081/                         //请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）</span><br><span class="line">Referer  https://localhost:8081/link?query=xxxxx       //请求资源的完整URI</span><br><span class="line">User-Agent  Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36       //浏览器信息</span><br><span class="line">Cookie  BAIDUID=FA89F036:FG=1; BD_HOME=1; sugstore=0   //当前域名下的Cookie</span><br><span class="line">Accept  text/html,image/apng                           //代表客户端希望接受的数据类型是html或者是png图片类型 </span><br><span class="line">Accept-Encoding  gzip, deflate                         //代表客户端能支持gzip和deflate格式的压缩</span><br><span class="line">Accept-Language  zh-CN,zh;q=0.9                        //代表客户端可以支持语言zh-CN或者zh(q(0~1)是优先级权重的意思，不写默认1，这里zh-CN是1，zh是0.9)</span><br><span class="line">Connection  keep-alive                                 //告诉服务器，客户端需要的tcp连接是一个长连接</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP1.1</span><br><span class="line">Host  www.wrox.com</span><br><span class="line">User-Agent  Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class="line">Content-Type  application/x-www-form-urlencoded</span><br><span class="line">Content-Length  40</span><br><span class="line">Connection  Keep-Alive</span><br><span class="line"> </span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley           //请求体数据行</span><br></pre></td></tr></table></figure><h3 id="232-响应报文"><a class="markdownIt-Anchor" href="#232-响应报文"></a> 2.3.2 响应报文</h3><ul><li>状态行</li><li>响应头</li><li>空行</li><li>响应体</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK                             //状态行</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT         //响应头</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line"> </span><br><span class="line">&lt;html&gt;                                      //响应体（响应正文）</span><br><span class="line">      &lt;head&gt;&lt;/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">            &lt;!--body goes here--&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="24-http常见返回状态码"><a class="markdownIt-Anchor" href="#24-http常见返回状态码"></a> 2.4 HTTP常见返回状态码</h2><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:left">含义</th><th style="text-align:left">典型例子</th></tr></thead><tbody><tr><td style="text-align:center">1xx</td><td style="text-align:left">指示信息类，表示请求已接受，继续处理</td><td style="text-align:left"><strong>100</strong>：继续请求 <strong>101</strong>：准备切换协议</td></tr><tr><td style="text-align:center">2xx</td><td style="text-align:left">指示成功类，表示请求已成功接受</td><td style="text-align:left"><strong>200</strong>：请求成功 <strong>201</strong>: 成功创建资源  <strong>204</strong>: 成功处理请求但是没有返回</td></tr><tr><td style="text-align:center">3xx</td><td style="text-align:left">指示重定向，表示要完成请求必须进行更近一步的操作</td><td style="text-align:left"><strong>301</strong>：请求页面永久移动到新url <strong>302</strong>：请求页面临时移动</td></tr><tr><td style="text-align:center">4xx</td><td style="text-align:left">指示客户端错误，请求有语法错误或请求无法实现</td><td style="text-align:left"><strong>403</strong>：禁止，服务器拒绝请求  <strong>404</strong>：服务器找不到请求的网页</td></tr><tr><td style="text-align:center">5xx</td><td style="text-align:left">指示服务器错误，服务器未能实现合法的请求</td><td style="text-align:left"><strong>500</strong>：服务器内部错误 <strong>502</strong>：错误网关  <strong>503</strong>：服务器不可用</td></tr></tbody></table><h2 id="25-http跨域问题"><a class="markdownIt-Anchor" href="#25-http跨域问题"></a> 2.5 HTTP跨域问题</h2><h3 id="251-基本概念"><a class="markdownIt-Anchor" href="#251-基本概念"></a> 2.5.1 基本概念</h3><p><strong>【跨域】</strong> 只要<em><strong>协议</strong>（http/https）</em>、<em><strong>域名</strong>（domin）</em>、<em><strong>端口</strong>（port）</em> 有任意一个不同就认为发生了跨域</p><p><strong>【浏览器同源策略】</strong></p><p>阻止一个域的javascript脚本和另外一个域的内容进行交互，具体表现为：</p><ol><li>无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</li><li>无法接触非同源网页的 DOM</li><li>无法向非同源地址发送 AJAX 请求</li></ol><h3 id="252-解决方案"><a class="markdownIt-Anchor" href="#252-解决方案"></a> 2.5.2 解决方案</h3><p>避开浏览器的安全限制，参考<a href="https://blog.csdn.net/qq_38128179/article/details/84956552">这篇博客</a></p><ul><li><code>JSONP</code>：通过<code>&lt;script src&gt;</code>标签发送请求</li><li><code>document.domin</code>：当主域名相同子域名不同时，可以通过设置两个页面相同的<code>document.domin</code>来实现两个页面共享cookie</li><li><code>window.name</code>：</li><li><code>window.postMessage()</code>：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父窗口打开一个子窗口</span></span><br><span class="line"><span class="keyword">var</span> openWindow = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;http://test2.com&#x27;</span>, <span class="string">&#x27;title&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 父窗口向子窗口发消息(第一个参数代表发送的内容，第二个参数代表接收消息窗口的url)</span></span><br><span class="line">openWindow.<span class="title function_">postMessage</span>(<span class="string">&#x27;Nice to meet you!&#x27;</span>, <span class="string">&#x27;http://test2.com&#x27;</span>);</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子窗口监听 message 消息</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">source</span>); <span class="comment">// e.source 发送消息的窗口</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">origin</span>); <span class="comment">// e.origin 消息发向的网址</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);   <span class="comment">// e.data   发送的消息</span></span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li><li><code>CORS</code>：开启跨域资源共享，允许通过的url（使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源）</li><li><code>proxy</code>：nginx配置反向代理。原理：浏览器有同源策略，使用服务器向另一个服务器发送请求，然后将另一个服务器的响应返回客户端</li><li><code>websocket</code>：一种双向通信协议，允许客户端和服务器主动发送或接受数据（html5持久化协议）</li></ul><h2 id="26-http和https联系与区别"><a class="markdownIt-Anchor" href="#26-http和https联系与区别"></a> 2.6 HTTP和HTTPS联系与区别</h2><ul><li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的<strong>ssl加密传输</strong>协议。</li><li>https 协议需要 ca 证书，费用较高。</li><li>使用不同的链接方式，端口也不同，一般，http 协议的端口为 80，https 的端口为 443。</li><li>http 的连接很简单，是无状态的；https有状态存储</li></ul><h2 id="27-https安全传输原理"><a class="markdownIt-Anchor" href="#27-https安全传输原理"></a> 2.7 HTTPS安全传输原理</h2><ul><li>收方能够证实发送方的真实身份</li><li>发送方事后不能否认所发送过的报文</li><li>收方或非法者不能伪造、篡改报文</li></ul><h3 id="271-非对称加密算法rsa"><a class="markdownIt-Anchor" href="#271-非对称加密算法rsa"></a> 2.7.1 非对称加密算法RSA</h3><p>如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密。</p><p>公钥包括在数字证书中</p><h3 id="272-ssl建立连接"><a class="markdownIt-Anchor" href="#272-ssl建立连接"></a> 2.7.2 SSL建立连接</h3><p>正常三次握手的过程中发送：</p><ol><li>支持的加密算法</li><li>SSL协议版本和需要访问的域名</li><li>一个随机数</li></ol><p>服务器返回：</p><ol><li>选中的加密算法</li><li>SSL、TLS协议版本</li><li>第二个随机数</li></ol><p>【证书验证阶段-使用非对称加密】</p><p>服务器端发送证书和公钥</p><p>【后续数据传输过程持续使用对称加密】</p><h2 id="28-http各版本特性"><a class="markdownIt-Anchor" href="#28-http各版本特性"></a> 2.8 HTTP各版本特性</h2><h3 id="281-http-1x"><a class="markdownIt-Anchor" href="#281-http-1x"></a> 2.8.1 HTTP 1.x</h3><p>【1.0】</p><p>无状态，无连接</p><p>容易发生<strong>队头阻塞</strong>：下一个请求必须在前一个请求响应之后才能发送</p><p>使用头部的协商缓存、强缓存作为缓存的判断机制</p><p>不支持断点续传，每次都会传送完整的页面</p><p>明文传输，不安全</p><p>【1.1】<br />提供长连接</p><p>引入etag增强缓存机制</p><p>改进队头阻塞，使用管道机制，允许不受到应答就继续发送请求（没有解决发送方队头阻塞）</p><p>支持断点续传</p><h3 id="282-http-2x"><a class="markdownIt-Anchor" href="#282-http-2x"></a> 2.8.2 HTTP 2.x</h3><p>使用https协议，提高安全性</p><p>对头部进行压缩，采用二进制传输，实现多路复用</p><p>允许服务端主动推送</p><h3 id="283-http-3x"><a class="markdownIt-Anchor" href="#283-http-3x"></a> 2.8.3 HTTP 3.x</h3><p>使用基于 UDP 的 QUIC 协议解决队头阻塞的问题</p><h1 id="3-dns-cdn"><a class="markdownIt-Anchor" href="#3-dns-cdn"></a> 3 DNS &amp; CDN</h1><p>domin name system，域名解析系统，通过该系统将域名和ip地址一一对应</p><h2 id="31-查询方式"><a class="markdownIt-Anchor" href="#31-查询方式"></a> 3.1 查询方式</h2><p>本地域名服务器，根域名服务器，顶级域名服务器，权威域名服务器</p><ul><li>递归查询：如果自己不知道，就自己发送一个请求到其他服务器，得到返回后再返回给请求的服务器</li><li>迭代查询：如果自己不知道，告诉请求的服务器如何去查找（向谁查找）</li></ul><h2 id="32-dns缓存"><a class="markdownIt-Anchor" href="#32-dns缓存"></a> 3.2 DNS缓存</h2><ul><li>浏览器缓存</li><li>操作系统缓存：存储在host文件中</li></ul><h2 id="33-从输入url到浏览器展示界面的过程"><a class="markdownIt-Anchor" href="#33-从输入url到浏览器展示界面的过程"></a> 3.3 从输入url到浏览器展示界面的过程</h2><ol><li>url解析</li><li>DNS查询</li><li>建立tcp连接</li><li>Http请求&amp;响应</li><li>渲染页面:DOM树+CSS树 =&gt; render树</li></ol><h2 id="34-cdn"><a class="markdownIt-Anchor" href="#34-cdn"></a> 3.4 CDN</h2><p>内容分发网络，根据距离用户最近的位置分配资源，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫边缘节点，其实就是缓存了源站内容的代理服务器。</p><p>应用CDN后，DNS 返回的不再是 IP 地址，而是一个CNAME(Canonical Name ) 别名记录，指向CDN的全局负载均衡</p><h2 id="35-url组成"><a class="markdownIt-Anchor" href="#35-url组成"></a> 3.5 url组成</h2><ol><li>协议</li><li>域名</li><li>端口号</li><li>路径</li><li>请求参数</li><li>锚点</li></ol><h1 id="4-浏览器"><a class="markdownIt-Anchor" href="#4-浏览器"></a> 4 浏览器</h1><h2 id="41-cookie-sessionstorage-localstorage"><a class="markdownIt-Anchor" href="#41-cookie-sessionstorage-localstorage"></a> 4.1 cookie &amp; sessionStorage &amp; localStorage</h2><p>都存储在客户端</p><ul><li>数据大小：cookie大小不能超过4k，其他两个可以存储5M+大小的数据</li><li>有效时间：cookie在有效期结束之前一直有效，localStorage永久有效（除非手动删除），sessionStorage在浏览器窗口关闭前有效（关闭后自动删除）</li><li>数据存储：cookie会被传输至服务端，local和session只存储在本地</li></ul><p>详情查看js篇</p><h2 id="42-缓存机制"><a class="markdownIt-Anchor" href="#42-缓存机制"></a> 4.2 缓存机制</h2><h3 id="421-强制缓存"><a class="markdownIt-Anchor" href="#421-强制缓存"></a> 4.2.1 强制缓存</h3><p>浏览器缓存结果和缓存标识都存在，查找请求结果，根据缓存规则决定是否使用缓存</p><h3 id="422-协商缓存"><a class="markdownIt-Anchor" href="#422-协商缓存"></a> 4.2.2 协商缓存</h3><p>强制缓存失效，浏览器携带本地缓存标识询问服务器是否使用缓存。</p><p>命中协商缓存返回304</p><h3 id="423-优先使用"><a class="markdownIt-Anchor" href="#423-优先使用"></a> 4.2.3 优先使用</h3><p>先根据cache-control查询是否超过了有效期时间，没有超过使用强制缓存；</p><p>超过则向服务器发送请求询问是否使用缓存，服务器比较etag，返回更新的资源</p><p>【etag和last-modified】</p><p>last-modified保存上一次更新的时间，etag保存hash</p><p>last-modified只精确到秒级，并且依赖于文件修改时间，不够准确</p><p>【刷新】</p><p>刷新会导致本地文件强制过期，如果在地址栏输入url则按照正常流程查询是否过期</p><h2 id="43-严格模式和混杂模式"><a class="markdownIt-Anchor" href="#43-严格模式和混杂模式"></a> 4.3 严格模式和混杂模式</h2><h2 id="44-浏览器进程和线程"><a class="markdownIt-Anchor" href="#44-浏览器进程和线程"></a> 4.4 浏览器进程和线程</h2><p>关于同步、异步问题，事件循环等内容</p><ul><li>浏览器主进程（一个），浏览器tab切换、回退刷新等操作</li><li>网络进程，负责网络资源加载（一个）</li><li>GPU进程（一个），负责像素点绘制</li><li>插件进程（一个插件一个）</li><li>渲染进程（一个tab一个），多个tab互不影响：渲染进程中有多个线程<ul><li>GUI渲染线程</li><li>JS引擎线程</li><li>事件触发线程</li><li>异步请求线程</li><li>定时触发器线程</li></ul></li></ul><p>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</p><p>线程之间关系：gui和js互斥</p><h1 id="5-网络攻击与安全"><a class="markdownIt-Anchor" href="#5-网络攻击与安全"></a> 5 网络攻击与安全</h1><h2 id="51-xss攻击"><a class="markdownIt-Anchor" href="#51-xss攻击"></a> 5.1 xss攻击</h2><p>跨站脚本攻击，允许攻击者将恶意代码植入到提供给其它用户使用的页面中</p><p>注入恶意sql语句 劫持cookie</p><p>【解决方案】<br />在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等</p><h2 id="52-csrf攻击"><a class="markdownIt-Anchor" href="#52-csrf攻击"></a> 5.2 csrf攻击</h2><p>攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求</p><p>【解决方案】</p><ul><li>阻止不明外域的访问</li><li>要求提供token或双重cookie验证</li></ul><h2 id="53-ddos攻击"><a class="markdownIt-Anchor" href="#53-ddos攻击"></a> 5.3 ddos攻击</h2><h2 id="54-sql注入攻击"><a class="markdownIt-Anchor" href="#54-sql注入攻击"></a> 5.4 sql注入攻击</h2><p>将恶意的 Sql查询或添加语句插入到应用的输入参数中，再在后台 Sql服务器上解析执行进行的攻击</p><p>【解决方案】</p><ul><li>严格检查输入变量的类型和格式</li><li>过滤和转义特殊字符</li><li>对访问数据库的Web应用程序采用Web应用防火墙</li></ul><h1 id="6-qa"><a class="markdownIt-Anchor" href="#6-qa"></a> 6 Ｑ＆Ａ</h1><ol><li><strong>什么是三次握手和四次挥手？</strong><br />见1.2.2节。回答要点：数据包内容+客户端、服务端状态</li><li><strong>http和https是什么？有什么联系和区别？</strong><br />http和https是超文本传输协议，联系与区别见2.6节</li><li><strong>在浏览器中输入url后到加载完整页面的过程？</strong><br />见3节</li><li><strong>常见的http状态码和含义？</strong><br />见2.4节</li><li><strong>跨域的解决方案？</strong><br />见2.5节，浏览器同源策略以及避开安全限制的方法</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-网络工作原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-网络工作原理&quot;&gt;&lt;/a&gt; 1 网络工作原理&lt;/h1&gt;
&lt;h2 id=&quot;11-网络模型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#11-网</summary>
      
    
    
    
    <category term="Technology" scheme="https://aliceraylu.github.io/categories/Technology/"/>
    
    <category term="Frontend" scheme="https://aliceraylu.github.io/categories/Technology/Frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>NJU SE 机器学习</title>
    <link href="https://aliceraylu.github.io/2024/01/05/knowledge/machine%20learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://aliceraylu.github.io/2024/01/05/knowledge/machine%20learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-01-04T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.485Z</updated>
    
    <content type="html"><![CDATA[<p>重点整理复习版</p><p>图片无法完全加载，请访问<a href="https://www.yuque.com/u34135790/laiu5z/ensdbirr9p0xpaac">语雀文档</a></p><h1 id="1-基础概念"><a class="markdownIt-Anchor" href="#1-基础概念"></a> 1 基础概念</h1><h2 id="11-什么是机器学习"><a class="markdownIt-Anchor" href="#11-什么是机器学习"></a> 1.1 什么是机器学习</h2><p>通过数据训练的学习算法</p><h2 id="12-监督无监督自监督半监督"><a class="markdownIt-Anchor" href="#12-监督无监督自监督半监督"></a> 1.2 监督，无监督，自监督，半监督</h2><ul><li>监督：利用大量标注数据（真实标签）训练模型</li><li>无监督：不依赖任何人工标注标签（聚类/降维/离散点检测）</li><li>自监督：标注来源于数据本身（对比学习）</li><li>半监督：深度学习领域…?</li></ul><h2 id="13-欠拟合和过拟合"><a class="markdownIt-Anchor" href="#13-欠拟合和过拟合"></a> 1.3 欠拟合和过拟合</h2><p>过拟合：病态问题，学习能力强，过度计算导致模型泛化能力下降。在训练集上表现好（训练误差小），在测试集上表现差。<br />欠拟合：模型复杂度低，不能在训练集上实现足够低的误差，学习不到数据的规律。</p><h2 id="14-评价学习算法的指标"><a class="markdownIt-Anchor" href="#14-评价学习算法的指标"></a> 1.4 评价学习算法的指标</h2><p>混淆矩阵<br />列：预测为该类别的数目；行：实际为该类别的数目<br />【二分类】</p><table><thead><tr><th></th><th>postive</th><th>negative</th></tr></thead><tbody><tr><td>positive</td><td>TP</td><td>FN</td></tr><tr><td>negative</td><td>FP</td><td>TN</td></tr></tbody></table><ul><li>精度/准确率：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi><mi>C</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi><mo>+</mo><mi>T</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">ACC = \frac{TP+TN}{TP+FP+FN+TN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.275662em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>（错误率：1-acc）</li><li>查准率：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>P</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">Precision = \frac{TP}{TP+FP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.275662em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>查全率：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">Recall = \frac{TP}{TP+FN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.275662em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>F1：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mn>1</mn><mo>=</mo><mn>2</mn><mfrac><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>∗</mo><mi>r</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi></mrow><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>+</mo><mi>r</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">F1 = 2\frac{precision*recall}{precision+recall}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.4133239999999998em;vertical-align:-0.481108em;"></span><span class="mord">2</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul><h2 id="15-没有免费的午餐"><a class="markdownIt-Anchor" href="#15-没有免费的午餐"></a> 1.5 没有免费的午餐</h2><p>没有天生优越的学习器，只有相对好的建模，充分利用了与问题相关的先验知识模型才是最优的</p><h2 id="16-距离度量的计算方式"><a class="markdownIt-Anchor" href="#16-距离度量的计算方式"></a> 1.6 距离度量的计算方式</h2><p><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml01.png?raw=true" alt="" /></p><h3 id="161-曼哈顿距离"><a class="markdownIt-Anchor" href="#161-曼哈顿距离"></a> 1.6.1 曼哈顿距离</h3><p>向量在每一维度上的相对距离和，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>=</mo><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>d</mi></msubsup><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>j</mi><mi>k</mi></mrow></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">d = \Sigma_{k=1}^d|x_{ik}-x_{jk}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.132216em;vertical-align:-0.2831079999999999em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span><br />在二维平面上，两个点的曼哈顿距离表现为x方向上距离和y方向上距离的和</p><h3 id="162-切比雪夫距离"><a class="markdownIt-Anchor" href="#162-切比雪夫距离"></a> 1.6.2 切比雪夫距离</h3><p>各维度坐标数值差绝对值的最大值</p><h3 id="163-马氏距离"><a class="markdownIt-Anchor" href="#163-马氏距离"></a> 1.6.3 马氏距离</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>为协方差矩阵的逆矩阵，要求<strong>总体样本数大于样本的维数</strong>，否则得到的总体样本协方差矩阵逆矩阵不存在<br />【如何计算协方差矩阵】<br /><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml02.png?raw=true" alt="" /><br />一行是一个样本，每一列是一个随机变量</p><h3 id="164-闵可夫斯基距离"><a class="markdownIt-Anchor" href="#164-闵可夫斯基距离"></a> 1.6.4 闵可夫斯基距离</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>x</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>u</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mrow><mi>i</mi><mi>u</mi></mrow></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>j</mi><mi>u</mi></mrow></msub><msup><mi mathvariant="normal">∣</mi><mi>p</mi></msup><msup><mo stretchy="false">)</mo><mfrac><mn>1</mn><mi>p</mi></mfrac></msup></mrow><annotation encoding="application/x-tex">d(x_i,x_j) = (\Sigma_{u=1}^n|x_{iu}-x_{ju}|^p)^{\frac{1}{p}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.322898em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mathdefault mtight">u</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0367899999999999em;"><span style="top:-3.44577em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.48288571428571425em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span><br />p = 1：曼哈顿距离<br />p = 2：欧氏距离<br />p = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span>：切比雪夫距离</p><h1 id="2-knn"><a class="markdownIt-Anchor" href="#2-knn"></a> 2 KNN</h1><p>k nearest neighbor classifier<br />懒惰学习算法，不需要学习成本，需要存储数据成本</p><h2 id="21-算法流程"><a class="markdownIt-Anchor" href="#21-算法流程"></a> 2.1 算法流程</h2><ol><li>计算所有测试样本和所有训练样本的距离d</li><li>（距离升序排序？）</li><li>针对每一个测试样本，选择k个最近的训练样本</li><li>采用投票法为测试样本选定分类标签</li></ol><p>（如果是回归：将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mi>d</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>作为权重，取k个近邻标签的加权平均）<br />测试阶段时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>d</mi><mo>+</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nd+nlogk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>：nlogk的解释，k个数的最小堆</p><h2 id="22-k值影响"><a class="markdownIt-Anchor" href="#22-k值影响"></a> 2.2 k值影响</h2><ul><li>取奇数，避免平局</li><li>k较小，对噪声敏感，模型复杂，容易过拟合；k较大，对噪声不敏感，容易欠拟合</li></ul><h2 id="23-核平滑"><a class="markdownIt-Anchor" href="#23-核平滑"></a> 2.3 核平滑</h2><p><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml03.png?raw=true" alt="" /><br />核平滑方法是指使用核函数来计算测试样本的标签值（在回归中）</p><h2 id="24-降低计算"><a class="markdownIt-Anchor" href="#24-降低计算"></a> 2.4 降低计算</h2><h3 id="241-维诺图"><a class="markdownIt-Anchor" href="#241-维诺图"></a> 2.4.1 维诺图</h3><p>适合维度2-5：划分区块（维诺单元），每个维诺单元都是一个凸多面体<br />【2维维诺图】<br />计算维诺图：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>算法决定<br />测试：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>使用空间搜索树确定维诺单元（类似于平衡二叉树）</p><h3 id="242-kd-tree"><a class="markdownIt-Anchor" href="#242-kd-tree"></a> 2.4.2 KD-Tree</h3><p>适合特征维度6-30：相当于二叉树，用来划分空间<br /><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml04.png?raw=true" alt="" /><br /><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml05.png?raw=true" alt="" /><br />【构造】</p><ol><li>计算x、y方向上的方差，选择方差大的轴进行划分</li><li>选取选定方向上数据的中位数进行划分</li><li>在划分出的新区域递归以上步骤</li></ol><p>【测试】<br />kd树搜索</p><ol><li>二叉搜索：从根节点开始，以递归的方式从树的顶端向下移动</li><li>当到达一个叶子节点，即得到最邻近的近似点，判断其是否为最优，并保存为“当前最优”</li><li>回溯：对整棵树进行递归，并对每个节点执行以下操作</li></ol><ul><li>如果当前节点比&quot;当前最优&quot;更近，替换为新的&quot;当前最优&quot;</li><li>判断分割平面的另一侧是否存在比&quot;当前最优&quot;更优的点。构造一个超球面，球心为查询点，半径为与当前最优的距离<ul><li>如果超球面跟超平面相交，则有可能存在更优的点；按照相同的搜索过程从当前节点向下移动到树的另一个分支以寻找更近的点</li><li>如果超球面跟超平面不相交，则沿着树继续往上走，当前节点的另个分支则被排除</li></ul></li></ul><ol start="4"><li>当算法为根节点完成整个过程时，算法结束</li></ol><h3 id="243-降维"><a class="markdownIt-Anchor" href="#243-降维"></a> 2.4.3 降维</h3><p>参考降维</p><h3 id="244-ann-近似最近邻"><a class="markdownIt-Anchor" href="#244-ann-近似最近邻"></a> 2.4.4 ANN 近似最近邻</h3><p>搜索可能是近邻的数据项，牺牲精度</p><h3 id="245-哈希"><a class="markdownIt-Anchor" href="#245-哈希"></a> 2.4.5 哈希</h3><p>把任意长度输入映射成固定长度输出</p><h1 id="3-聚类"><a class="markdownIt-Anchor" href="#3-聚类"></a> 3 聚类</h1><p>聚类：数据对象的集合<br />聚类算法：根据给定的相似性评价标准将一个数据集合划分成几个聚类<br />相似性度量+聚类准则</p><h2 id="31-聚类算法"><a class="markdownIt-Anchor" href="#31-聚类算法"></a> 3.1 聚类算法</h2><h3 id="311-试探法"><a class="markdownIt-Anchor" href="#311-试探法"></a> 3.1.1 试探法</h3><p>凭借感觉/经验针对实际问题定义阈值 -&gt; 最近邻规则（某种距离计算方式+对应阈值）<br />误差：与聚类中心（均值）距离平方和<br />初始点、样本次序和阈值都会影响<br />【最大最小距离法】<br />选择与确定的聚类中心最远的点作为新的中心，预先选定聚类中心<br />已经选定多个后添加新的中心：每一个样本，计算到所有中心的最小值，选择所有样本中的最大值，如果大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>z</mi><mn>1</mn></msub><mo>−</mo><msub><mi>z</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">\theta ||z_1-z_2||</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord">∣</span></span></span></span>选定，否则选取过程结束</p><h3 id="312-系统聚类"><a class="markdownIt-Anchor" href="#312-系统聚类"></a> 3.1.2 系统聚类</h3><p>计算类之间的距离，合并新类<br />【类之间距离】</p><ul><li>最短距离</li><li>最长距离</li><li>类平均距离</li></ul><h3 id="313-动态聚类法"><a class="markdownIt-Anchor" href="#313-动态聚类法"></a> 3.1.3 动态聚类法</h3><h4 id="3131-k-means"><a class="markdownIt-Anchor" href="#3131-k-means"></a> 3.1.3.1 K-means</h4><ol><li>确定聚类数量k</li><li>初始化k个聚类中心：随机选择k个样本点</li><li>对每个样本点计算最近聚类距离</li><li>更新聚类中心（平均值）</li><li>没有聚类中心移动：停止</li></ol><p><strong>【k-means++】</strong></p><ul><li>随机选1个样本点作为初始聚类中心</li><li>每一个样本点被选为下一个聚类中心的概率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>x</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mi mathvariant="normal">Σ</mi><mi>D</mi><mo stretchy="false">(</mo><mi>x</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{D(x)^2}{\Sigma D(x)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.62892em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10892em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Σ</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>表示和所有中心的最短距离</li><li>使用轮盘法选择聚类中心</li></ul><h4 id="3132-isodata"><a class="markdownIt-Anchor" href="#3132-isodata"></a> 3.1.3.2 ISODATA</h4><p>分裂+合并<br />根据样本到聚类中心分配样本，如果某一类样本数少于n，合并；类别数目小于K0/2，分裂；类别数目大于2K0，合并；<br />以平均中心作为聚类中心，更新中心后重复以上操作<br /><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml06.png?raw=true" alt="" /><br /><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml07.png?raw=true" alt="" /></p><h2 id="32-如何评价聚类好坏"><a class="markdownIt-Anchor" href="#32-如何评价聚类好坏"></a> 3.2 如何评价聚类好坏</h2><p>类内距离小，类间距离大</p><h3 id="321-compactness-cp"><a class="markdownIt-Anchor" href="#321-compactness-cp"></a> 3.2.1 Compactness - CP</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>C</mi><msub><mi>P</mi><mi>i</mi></msub></mrow><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><msub><mi mathvariant="normal">Ω</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi></mrow></mfrac><msub><mi mathvariant="normal">Σ</mi><mrow><msub><mi>x</mi><mi>j</mi></msub><mo>∈</mo><msub><mi mathvariant="normal">Ω</mi><mi>i</mi></msub></mrow></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">{CP_i} = \frac{1}{|\Omega_i|}\Sigma_{x_j \in \Omega_i}||x_i-w_i||</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.365108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mtight">Ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833100000000004em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mtight">Ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34731999999999996em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord">∣</span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\Omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">Ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示某一个类，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示聚类中心<br />紧密度计算类内距离：越小类内越紧凑</p><h3 id="322-separation-sp"><a class="markdownIt-Anchor" href="#322-separation-sp"></a> 3.2.2 Separation - SP</h3><p><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml08.png?raw=true" alt="" /></p><p>间隔度越大越分散</p><h3 id="323-davies-bouldin-index-dbi"><a class="markdownIt-Anchor" href="#323-davies-bouldin-index-dbi"></a> 3.2.3 Davies-Bouldin Index - DBI</h3><p>戴维森堡丁指数/分类适确性指标<br /><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml09.png?raw=true" alt="" /><br />缺点：欧氏距离对于环状分布聚类评价很差</p><h3 id="324-dunn-validity-index-dvi"><a class="markdownIt-Anchor" href="#324-dunn-validity-index-dvi"></a> 3.2.4 Dunn Validity Index - DVI</h3><p>邓恩指数<br /><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml10.png?raw=true" alt="" /><br />对离散点聚类测评很高，对环状分布测评效果差</p><h3 id="325-其他评价指标"><a class="markdownIt-Anchor" href="#325-其他评价指标"></a> 3.2.5 其他评价指标</h3><p><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml11.png?raw=true" alt="" /></p><h1 id="4-树学习"><a class="markdownIt-Anchor" href="#4-树学习"></a> 4 树学习</h1><h2 id="41-符号学习"><a class="markdownIt-Anchor" href="#41-符号学习"></a> 4.1 符号学习</h2><h3 id="411-推理"><a class="markdownIt-Anchor" href="#411-推理"></a> 4.1.1 推理</h3><p>推理（正向/反向）<br />归纳推理：前件为真，后件未必为真</p><h3 id="412-概念学习"><a class="markdownIt-Anchor" href="#412-概念学习"></a> 4.1.2 概念学习</h3><p>给定样例判断每个样例是否属于某个概念</p><h4 id="4121-实例空间与假设空间"><a class="markdownIt-Anchor" href="#4121-实例空间与假设空间"></a> 4.1.2.1 实例空间与假设空间</h4><p>【实例空间】所有可能样例集合<br />【假设空间】除了所有样例，还可能涉及到未知、空等情况</p><h4 id="4122-泛化和特化"><a class="markdownIt-Anchor" href="#4122-泛化和特化"></a> 4.1.2.2 泛化和特化</h4><p>样例<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">h_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">h_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>预测的类别相同，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">h_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>包含的实例数更多<br />【泛化】<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>j</mi></msub><msub><mo>≥</mo><mi>g</mi></msub><msub><mi>h</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">h_j \ge_g h_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">≥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br />【特化】<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>k</mi></msub><msub><mo>≥</mo><mi>s</mi></msub><msub><mi>h</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">h_k \ge_s h_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">≥</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p><h4 id="4123-find-s"><a class="markdownIt-Anchor" href="#4123-find-s"></a> 4.1.2.3 Find-S</h4><p>寻找极大特殊假设<br /><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml12.png?raw=true" alt="" /><br />满足：同一种结果，在这种属性上取值一致<br />【列表消除算法】<br />列出所有假设空间，消除不符合实例的假设（实际中不太可能）</p><h2 id="42-变型空间"><a class="markdownIt-Anchor" href="#42-变型空间"></a> 4.2 变型空间</h2><h3 id="421-概念"><a class="markdownIt-Anchor" href="#421-概念"></a> 4.2.1 概念</h3><p>【一致】一个假设和样例集合一致：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(x) = c(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>表示假设函数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>表示实例结果<br />变型空间定义：假设空间和样例集合一致的所有假设构成子集<br />【极大泛化】<br />【极大特化】</p><h3 id="422-表示定理"><a class="markdownIt-Anchor" href="#422-表示定理"></a> 4.2.2 表示定理</h3><p><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml13.png?raw=true" alt="" /><br />h：其中一种假设（布尔函数）</p><h3 id="423-候选消除算法"><a class="markdownIt-Anchor" href="#423-候选消除算法"></a> 4.2.3 候选消除算法</h3><p>正例用于S泛化，搜索S集合；反例用于G特化，缩小G集合<br /><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml14.png?raw=true" alt="" /><br />有关find-s和候选消除算法讲解很细致易懂的博客<a href="https://www.cnblogs.com/WTSRUVF/p/15680429.html">概念学习和一般到特殊序 - WTSRUVF - 博客园</a></p><h3 id="424-find-s-与候选消除算法区别"><a class="markdownIt-Anchor" href="#424-find-s-与候选消除算法区别"></a> 4.2.4 Find-S 与候选消除算法区别</h3><ul><li>find-s找到适合所有正例的假设，候选消除算法维护一组能够区分正例和负例的一致性假设</li><li>find-s从最特殊的假设开始进行泛化，候选消除算法从一般的泛化集合和最特殊的特化集合开始</li><li>find-s只考虑正例，不考虑负例；候选消除算法中正负例都会影响假设集合</li><li>find-s使用专门的搜索策略找到最特定的假设；候选消除算法搜索更全面</li></ul><h2 id="43-归纳偏置"><a class="markdownIt-Anchor" href="#43-归纳偏置"></a> 4.3 归纳偏置</h2><p>某种形式的预先假定（前提）</p><h2 id="44-决策树"><a class="markdownIt-Anchor" href="#44-决策树"></a> 4.4 决策树</h2><p>归纳偏置：优先选择较小树<br />【优点】</p><ul><li>容错能力好，健壮性高</li><li>可解释性强</li><li>不需要数据预处理</li><li>可以处理多维度输出分类问题</li></ul><p>【缺点】</p><ul><li>容易过拟合</li><li>样本改动会剧烈影响树结构</li><li>NP问题容易陷入局部最优</li></ul><h3 id="441-id3算法"><a class="markdownIt-Anchor" href="#441-id3算法"></a> 4.4.1 ID3算法</h3><h4 id="4411-算法流程"><a class="markdownIt-Anchor" href="#4411-算法流程"></a> 4.4.1.1 算法流程</h4><ol><li>创建root结点</li><li>如果所有样本属性一致，返回叶子节点；如果未划分的属性为空，选择所有样本中最普遍的标签（目标属性）；如果所有样本类别相同，返回叶子节点。【递归停止条件】</li><li>否则，选择分类样本能力最好的属性，依据属性的每个可能值划分样本递归执行</li></ol><h4 id="4412-如何选择最佳属性"><a class="markdownIt-Anchor" href="#4412-如何选择最佳属性"></a> 4.4.1.2 如何选择最佳属性</h4><h5 id="44121-熵"><a class="markdownIt-Anchor" href="#44121-熵"></a> 4.4.1.2.1 熵</h5><p>目标属性为布尔值<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>y</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><msub><mi>p</mi><mo>+</mo></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mo>+</mo></msub><mo stretchy="false">)</mo><mo>−</mo><msub><mi>p</mi><mo>−</mo></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mo>−</mo></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Entropy(S) = -p_+log(p_+)-p_-log(p_-)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.25833100000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h5 id="44122-信息增益"><a class="markdownIt-Anchor" href="#44122-信息增益"></a> 4.4.1.2.2 信息增益</h5><p>使用A属性分割样例，导致期望熵降低（选择maxGain）<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>y</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi mathvariant="normal">Σ</mi><mrow><mi>v</mi><mo>∈</mo><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mi>s</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></msub><mfrac><mrow><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mi>v</mi></msub><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mi>E</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>y</mi><mo stretchy="false">(</mo><msub><mi>S</mi><mi>v</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(S,A) = Entropy(S) - \Sigma_{v\in Values(A)} \frac{|S_v|}{|S|} Entropy(S_v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">A</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h4 id="4413-特点"><a class="markdownIt-Anchor" href="#4413-特点"></a> 4.4.1.3 特点</h4><p>假设空间包含所有决策树，一次遍历，不进行回溯（局部最优）<br />对错误样例不敏感，不适用于增量处理<br />对可取值数目多的属性<strong>有偏好</strong></p><h3 id="442-奥卡姆剃刀原理"><a class="markdownIt-Anchor" href="#442-奥卡姆剃刀原理"></a> 4.4.2 奥卡姆剃刀原理</h3><p>如果对同一现象有两种不同假说，应该采取比较简单的一种<br />优先选择拟合数据最简单的假设</p><h3 id="443-c45算法"><a class="markdownIt-Anchor" href="#443-c45算法"></a> 4.4.3 C4.5算法</h3><p>【<strong>信息增益比】</strong><br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>R</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>G</mi><mi>a</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mrow><mi>E</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>p</mi><msub><mi>y</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">GainRate(S,A) = \frac{Gain(S,A)}{Entropy_A(S)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">p</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">A</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>p</mi><msub><mi>y</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><msub><mi mathvariant="normal">Σ</mi><mrow><mi>v</mi><mo>∈</mo><mi>V</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mi>s</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></msub><mfrac><mrow><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mi>v</mi></msub><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mi>v</mi></msub><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Entropy_A(S) = -\Sigma_{v\in Values(A)} \frac{|S_v|}{|S|} log(\frac{|S_v|}{|S|})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord">−</span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">A</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span><br />除以属性的熵</p><h3 id="444-cart算法"><a class="markdownIt-Anchor" href="#444-cart算法"></a> 4.4.4 CART算法</h3><h4 id="4441-gini系数"><a class="markdownIt-Anchor" href="#4441-gini系数"></a> 4.4.4.1 Gini系数</h4><p>k个类中，样本属于第k类的概率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>k</mi></msub><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><msub><mi>C</mi><mi>k</mi></msub><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>D</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">p_k = \frac{|C_k|}{|D|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.07153em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br /><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml15.png?raw=true" alt="" /><br />二分类问题gini系数<img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml16.png?raw=true" alt="" /><br />gini系数代表模型的纯度，越小越好<br />【属性划分后计算基尼系数】<br /><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml17.png?raw=true" alt="" /></p><h4 id="4442-回归"><a class="markdownIt-Anchor" href="#4442-回归"></a> 4.4.4.2 回归</h4><p>对某一属性A，找到一个点s使得s左右两边数据集各自均方差（标准差？）相加最小<br />选择和最小的属性<br />s为经过排序后，某两个相邻样本的平均数<br />【回归输出】<br />采用叶子节点的均值或中位数作为预测结果</p><h3 id="445-剪枝"><a class="markdownIt-Anchor" href="#445-剪枝"></a> 4.4.5 剪枝</h3><h4 id="4451-后剪枝"><a class="markdownIt-Anchor" href="#4451-后剪枝"></a> 4.4.5.1 后剪枝</h4><p>从决策树底部剪去一些子树，在独立验证集上测试选择最优子树<br />剪去子树：变成占比高的叶子节点标签</p><h4 id="4452-最小化子树损失函数"><a class="markdownIt-Anchor" href="#4452-最小化子树损失函数"></a> 4.4.5.2 最小化子树损失函数</h4><p><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml18.png?raw=true" alt="" /></p><h1 id="5-集成学习"><a class="markdownIt-Anchor" href="#5-集成学习"></a> 5 集成学习</h1><h2 id="51-原理"><a class="markdownIt-Anchor" href="#51-原理"></a> 5.1 原理</h2><p>多个分类器集成在一起以提高分类准确率<br />集成方法包括多数投票法等等</p><h3 id="511-准确性计算"><a class="markdownIt-Anchor" href="#511-准确性计算"></a> 5.1.1 准确性计算</h3><p>假设每个二分类器精度为p，且相互独立<br />继承后T个二分类器的分类器的精度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>k</mi><mo>=</mo><mfrac><mi>T</mi><mn>2</mn></mfrac><mo>+</mo><mn>1</mn></mrow><mi>T</mi></msubsup><msubsup><mi>C</mi><mi>T</mi><mi>k</mi></msubsup><msup><mi>p</mi><mi>k</mi></msup><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mi>T</mi><mo>−</mo><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\Sigma_{k=\frac{T}{2}+1}^T C_T^k p^k(1-p)^{T-k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.497373em;vertical-align:-0.6482650000000001em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.592535em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8720928571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6482650000000001em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.424669em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span><br />T足够大时近似二项分布，要求每个分类器的准确率要在50%以上</p><h3 id="512-bias-variance-tradeoff"><a class="markdownIt-Anchor" href="#512-bias-variance-tradeoff"></a> 5.1.2 bias &amp; variance tradeoff</h3><p><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml19.png?raw=true" alt="" /></p><h3 id="513-基本策略"><a class="markdownIt-Anchor" href="#513-基本策略"></a> 5.1.3 基本策略</h3><h4 id="5131-回归问题"><a class="markdownIt-Anchor" href="#5131-回归问题"></a> 5.1.3.1 回归问题</h4><ul><li>简单平均</li><li>加权平均</li></ul><h4 id="5132-分类问题"><a class="markdownIt-Anchor" href="#5132-分类问题"></a> 5.1.3.2 分类问题</h4><p>投票法</p><ul><li>绝对多数</li><li>相对多数</li><li>加权投票</li></ul><h2 id="52-bagging"><a class="markdownIt-Anchor" href="#52-bagging"></a> 5.2 Bagging</h2><p>bootstrap aggregating</p><h3 id="521-基本原理"><a class="markdownIt-Anchor" href="#521-基本原理"></a> 5.2.1 基本原理</h3><p>有放回的采样方法<br /><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml20.png?raw=true" alt="" /></p><h3 id="522-优点缺点"><a class="markdownIt-Anchor" href="#522-优点缺点"></a> 5.2.2 优点&amp;缺点</h3><p>【优点】<br />并行式集成学习，降低分类器方差，改善泛化<br />【缺点】<br />基学习器高bias会影响集成后学习器的高bias<br />集成后损失可解释性</p><h3 id="523-随机森林rf"><a class="markdownIt-Anchor" href="#523-随机森林rf"></a> 5.2.3 随机森林RF</h3><p>有放回抽样 -&gt; 生成随机树（随机抽取特征） -&gt; 使用没有被抽到的样本进行测试（多数投票/平均）<br /><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml21.png?raw=true" alt="" /><br />【特点】</p><ul><li>差异性：每棵树使用特征不同</li><li>缓解维度灾难：抽取一部分特征来生成决策树</li><li>可并行化</li><li>训练测试无需划分：有30%左右数据没有被采样</li><li>稳定：投票/平均</li></ul><h2 id="53-boosting"><a class="markdownIt-Anchor" href="#53-boosting"></a> 5.3 Boosting</h2><h3 id="531-基本原理"><a class="markdownIt-Anchor" href="#531-基本原理"></a> 5.3.1 基本原理</h3><p><strong>probably approximately correct(PAC) - <strong>概率近似正确<br />【强可学习】如果存在一个多项式的学习算法能够学习，并且正确率很高<br />【弱可学习】多项式的学习算法，但是正确率仅比随机猜测略好<br />【PAC学习理论】强学习器和弱学习器是等价的，可以通过</strong>提升</strong>将弱学习器转化为强学习器</p><h3 id="532-adaboost"><a class="markdownIt-Anchor" href="#532-adaboost"></a> 5.3.2 AdaBoost</h3><p>Adaptive Boost，二分类学习算法</p><h4 id="5321-基本思想"><a class="markdownIt-Anchor" href="#5321-基本思想"></a> 5.3.2.1 基本思想</h4><p>改变训练数据的概率分布，反复学习，得到一系列的弱学习器组合形成一个强分类器<br />提高错误分类样本权值，降低正确分类权值<br />集成时加权投票：错误率小的分类器权重高，错误率大权重低</p><h4 id="5322-计算"><a class="markdownIt-Anchor" href="#5322-计算"></a> 5.3.2.2 计算</h4><p>第k个弱分类器<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>G</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G_k(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>在训练集上加权分类的错误率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mi>k</mi></msub><mo>=</mo><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><msub><mi>w</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub><mi>I</mi><mo stretchy="false">(</mo><msub><mi>G</mi><mi>k</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">≠</mi><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e_k = \Sigma_{i=1}^m w_{k,i}I(G_k(x_i) \neq y_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">w_{k,i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示第k个分类器输出i个样本权重<br />得到第k个分类器<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>G</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G_k(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>投票权重系数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>α</mi><mi>k</mi></msub><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mrow><mn>1</mn><mo>−</mo><msub><mi>e</mi><mi>k</mi></msub></mrow><msub><mi>e</mi><mi>k</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\alpha_k = \frac{1}{2} log\frac{1-e_k}{e_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.317828em;vertical-align:-0.4508599999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.866968em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.41586em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4508599999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br /><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml22.png?raw=true" alt="" /><br />【可视化表现】<br /><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml23.png?raw=true" alt="" /></p><h4 id="5323-解释"><a class="markdownIt-Anchor" href="#5323-解释"></a> 5.3.2.3 解释</h4><h5 id="53231-加法模型"><a class="markdownIt-Anchor" href="#53231-加法模型"></a> 5.3.2.3.1 加法模型</h5><p><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml24.png?raw=true" alt="" /><br />损失函数可以写作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(y_i,f(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，f(x)为上述表达式，这个函数优化起来十分复杂，可以采用前向分步算法</p><h5 id="53232-前向分步算法"><a class="markdownIt-Anchor" href="#53232-前向分步算法"></a> 5.3.2.3.2 前向分步算法</h5><p>每一步只学习一个基函数及其系数<br /><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/knowledge/machine%20learning/assets/ml25.png?raw=true" alt="" /><br />adaboost是前向分步算法的特例，损失函数是指数函数</p><h5 id="53233-分类器与损失函数"><a class="markdownIt-Anchor" href="#53233-分类器与损失函数"></a> 5.3.2.3.3 分类器与损失函数</h5><p>【最终分类器】<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></msubsup><msub><mi>α</mi><mi>k</mi></msub><msub><mi>G</mi><mi>k</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x) = \Sigma_{k=1}^{K} \alpha_k G_k(x_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1244389999999997em;vertical-align:-0.2831079999999999em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br />【损失函数】<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mo>−</mo><mi>y</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(y,f(x)) = exp(-yf(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><h3 id="533-其他boosting算法"><a class="markdownIt-Anchor" href="#533-其他boosting算法"></a> 5.3.3 其他boosting算法</h3><h4 id="5331-boosting-tree"><a class="markdownIt-Anchor" href="#5331-boosting-tree"></a> 5.3.3.1 boosting tree</h4><p>平方误差损失函数</p><h4 id="5332-gbdt"><a class="markdownIt-Anchor" href="#5332-gbdt"></a> 5.3.3.2 GBDT</h4><p>梯度提升树，使用损失函数和分类器分类结果的偏导求得梯度作为残差，拟合回归树</p><h4 id="5333-xgboost"><a class="markdownIt-Anchor" href="#5333-xgboost"></a> 5.3.3.3 XGBoost</h4><p>extreme gradient boosting<br />GBDT的高效实现，使用二阶泰勒展开做近似</p><h2 id="54-stacking"><a class="markdownIt-Anchor" href="#54-stacking"></a> 5.4 Stacking</h2><p>k-fold<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704177200490-7a4c7e9d-5f29-4978-a1f9-56d1019e72d8.png#averageHue=%23f7f5f3&amp;clientId=u01548630-8dd6-4&amp;from=paste&amp;height=340&amp;id=u35cbeb46&amp;originHeight=510&amp;originWidth=1084&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=213720&amp;status=done&amp;style=none&amp;taskId=uf3e2acd6-c32e-4927-aac7-2a66db78f8a&amp;title=&amp;width=722.6666666666666" alt="image.png" /></p><h1 id="6-概率学习"><a class="markdownIt-Anchor" href="#6-概率学习"></a> 6 概率学习</h1><h2 id="61-基本数学概念"><a class="markdownIt-Anchor" href="#61-基本数学概念"></a> 6.1 基本数学概念</h2><h3 id="611-张量tensor"><a class="markdownIt-Anchor" href="#611-张量tensor"></a> 6.1.1 张量tensor</h3><p>一个泛化的实数构成的n维数组</p><h3 id="612-带不带约束的数学优化问题"><a class="markdownIt-Anchor" href="#612-带不带约束的数学优化问题"></a> 6.1.2 带/不带约束的数学优化问题</h3><h4 id="6121-带约束"><a class="markdownIt-Anchor" href="#6121-带约束"></a> 6.1.2.1 带约束</h4><p>比如拉格朗日（见SVM部分）</p><h4 id="6122-不带约束"><a class="markdownIt-Anchor" href="#6122-不带约束"></a> 6.1.2.2 不带约束</h4><p>**【最小二乘问题】**least-squares<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704241201180-ddc723a1-8230-4900-9cba-4bdf63c5a335.png#averageHue=%23f9f9f8&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=273&amp;id=u29350ac6&amp;originHeight=409&amp;originWidth=952&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=97631&amp;status=done&amp;style=none&amp;taskId=u2a1224b8-326f-4a48-b3d1-5e5d478a571&amp;title=&amp;width=634.6666666666666" alt="image.png" /></p><h3 id="613-凹凸函数"><a class="markdownIt-Anchor" href="#613-凹凸函数"></a> 6.1.3 凹凸函数</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704241826448-6386f48f-0441-42dc-a797-5096e10e0855.png#averageHue=%23fafafa&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=197&amp;id=uf190090c&amp;originHeight=669&amp;originWidth=1114&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=131799&amp;status=done&amp;style=none&amp;taskId=ua4c27820-97fc-4d0d-942d-e42f0b3f205&amp;title=&amp;width=328.3333435058594" alt="image.png" /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704241953365-a816085e-5a6f-48b6-b1b3-b468a31633b6.png#averageHue=%23fafafa&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=196&amp;id=u3a611acf&amp;originHeight=706&amp;originWidth=1089&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=112475&amp;status=done&amp;style=none&amp;taskId=u7171875e-9c16-4b68-8fe7-f8bd87b8517&amp;title=&amp;width=302.3333435058594" alt="image.png" /><br />判断凹凸可以通过计算二阶导确定，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>f</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f&#x27;&#x27;(x) \ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>是凸函数或hessian矩阵半正定：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="normal">∇</mi><mn>2</mn></msup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≽</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\nabla^2f(x)\succcurlyeq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">∇</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">≽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span><br />【hessian矩阵-矩阵二阶导】<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704242444472-fe2a3ace-2b94-4e97-8a00-04cef8aa90f5.png#averageHue=%23fefefe&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=342&amp;id=u8682c1d7&amp;originHeight=513&amp;originWidth=661&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=32606&amp;status=done&amp;style=none&amp;taskId=u87ece63a-4d8e-4141-9d04-c189e03b4f7&amp;title=&amp;width=440.6666666666667" alt="image.png" /><br />【jacob矩阵】<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704242470613-b15a1ee6-6f3d-4748-8096-e74cabb9cbd0.png#averageHue=%23fefefe&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=219&amp;id=ub1584990&amp;originHeight=328&amp;originWidth=865&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=25779&amp;status=done&amp;style=none&amp;taskId=u694ee665-8071-442a-b46a-a8899e904c8&amp;title=&amp;width=576.6666666666666" alt="image.png" /></p><h3 id="614-概率"><a class="markdownIt-Anchor" href="#614-概率"></a> 6.1.4 概率</h3><h4 id="6141-概率函数"><a class="markdownIt-Anchor" href="#6141-概率函数"></a> 6.1.4.1 概率函数</h4><ul><li>概率密度函数（PDF）：连续值取某个值的概率</li><li>概率质量函数（PMF）：离散值，正好等于某个值的概率</li></ul><h4 id="6142-期望"><a class="markdownIt-Anchor" href="#6142-期望"></a> 6.1.4.2 期望</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704242966836-4cea70d3-62dd-4d31-a650-a13aad19b695.png#averageHue=%23f7f7f7&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=275&amp;id=uda109d93&amp;originHeight=412&amp;originWidth=1102&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=84285&amp;status=done&amp;style=none&amp;taskId=ucf0acc7c-5a52-4c49-bf8d-4b3ff1c4dc2&amp;title=&amp;width=734.6666666666666" alt="image.png" /></p><h3 id="615-jensen不等式"><a class="markdownIt-Anchor" href="#615-jensen不等式"></a> 6.1.5 jensen不等式</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704243095807-36cc4d11-d308-4a5a-83a9-5d61207d50e8.png#averageHue=%23f8f7f7&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=465&amp;id=u6aa9b6a4&amp;originHeight=697&amp;originWidth=1009&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=138864&amp;status=done&amp;style=none&amp;taskId=u7325de29-9216-477d-8b55-bc21ea78b5d&amp;title=&amp;width=672.6666666666666" alt="image.png" /></p><h3 id="616-高斯分布正态分布"><a class="markdownIt-Anchor" href="#616-高斯分布正态分布"></a> 6.1.6 高斯分布/正态分布</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>∼</mo><mi>N</mi><mo stretchy="false">(</mo><mi>μ</mi><mo separator="true">,</mo><msup><mi>σ</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \sim N(\mu,\sigma^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br />概率密度函数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>σ</mi><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mrow></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">p(x) = \frac{1}{\sigma \sqrt{2\pi}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.8670900000000001em;vertical-align:-0.5379999999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.5510085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5379999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.32909em;"><span style="top:-3.4534200000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.250957142857143em;"><span style="top:-2.5061857142857145em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9384399999999999em;"><span style="top:-2.93844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.5020714285714285em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">μ</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.04844em;"><span style="top:-3.04844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49381428571428565em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span><br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>σ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mu = 0, \sigma = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>是标准正态分布<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704243376849-19de419a-58de-485b-aa49-bf8d5a578e2a.png#averageHue=%23f8f7f7&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=283&amp;id=uc8b119c5&amp;originHeight=424&amp;originWidth=760&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=94164&amp;status=done&amp;style=none&amp;taskId=uccb2f8db-f9bc-401f-ad80-4b27154c19d&amp;title=&amp;width=506.6666666666667" alt="image.png" /><br />【<strong>多变量高斯分布】</strong><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704243424250-3e5fdff6-1eec-4d9b-8b09-02e5a5159ed5.png#averageHue=%23f5f4f3&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=362&amp;id=u1708eadd&amp;originHeight=543&amp;originWidth=999&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=162443&amp;status=done&amp;style=none&amp;taskId=u8bbd9569-e314-4526-a746-9440ca189e7&amp;title=&amp;width=666" alt="image.png" /></p><h2 id="62-高斯混合模型gmm"><a class="markdownIt-Anchor" href="#62-高斯混合模型gmm"></a> 6.2 高斯混合模型GMM</h2><p>多个高斯分布的加权和，利用此模型进行聚类，每一个子分布都是高斯分布<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704243949906-9411b378-6c6a-4ba4-a303-ad5fb3ae4db8.png#averageHue=%23f9f9f8&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=395&amp;id=u9729bdac&amp;originHeight=592&amp;originWidth=1083&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=146838&amp;status=done&amp;style=none&amp;taskId=ud5514d27-0e29-4fb9-857d-f0fb6cb6566&amp;title=&amp;width=722" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704244827574-9c07a893-28eb-425e-a86c-98bae895eabf.png#averageHue=%23f8f6f6&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=425&amp;id=u5b66f284&amp;originHeight=637&amp;originWidth=958&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=151280&amp;status=done&amp;style=none&amp;taskId=u437939bc-869e-451d-9bcc-ac378be9069&amp;title=&amp;width=638.6666666666666" alt="image.png" /></p><h2 id="63-最大似然估计mle"><a class="markdownIt-Anchor" href="#63-最大似然估计mle"></a> 6.3 最大似然估计MLE</h2><h3 id="631-定义"><a class="markdownIt-Anchor" href="#631-定义"></a> 6.3.1 定义</h3><p>maximum likelihood estimation，最大化似然函数以估计概率分布<br />【单高斯模型】<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></msubsup><mi>p</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(\theta | X) =  p (X | \theta) = \prod_{j=1}^M p(x_j|\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.417049em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span><br />两边取对数</p><h3 id="632-期望最大化算法em"><a class="markdownIt-Anchor" href="#632-期望最大化算法em"></a> 6.3.2 期望最大化算法EM</h3><h4 id="6321-核心思想"><a class="markdownIt-Anchor" href="#6321-核心思想"></a> 6.3.2.1 核心思想</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704245444555-12fa7a40-ed43-430f-818a-ac23d6d830c7.png#averageHue=%23eee9e7&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=243&amp;id=u7c70c4fb&amp;originHeight=364&amp;originWidth=1069&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=210688&amp;status=done&amp;style=none&amp;taskId=ud76fff3e-a35b-46f3-86a3-442e763901b&amp;title=&amp;width=712.6666666666666" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704381298277-8c8acfe5-1a60-425f-95c0-47e971889720.png#averageHue=%23faf8f7&amp;clientId=u1cfd4743-4f7a-4&amp;from=paste&amp;height=327&amp;id=u48c32b5d&amp;originHeight=490&amp;originWidth=1117&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=140100&amp;status=done&amp;style=none&amp;taskId=u82b7c835-3caf-4aa2-bd0d-98674728838&amp;title=&amp;width=744.6666666666666" alt="image.png" /><br />M-step：使用最大似然估计得到更好的参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704381580460-c1e43ca5-e83f-47f3-9198-34f40f43d350.png#averageHue=%23f5f4f4&amp;clientId=u1cfd4743-4f7a-4&amp;from=paste&amp;height=393&amp;id=u37ae03fd&amp;originHeight=589&amp;originWidth=969&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=165474&amp;status=done&amp;style=none&amp;taskId=u7a6d87bb-b746-468e-8c91-3d05f4864b3&amp;title=&amp;width=646" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704381646399-ad797dcc-c0f6-47a4-81d0-38c765b15df0.png#averageHue=%23f5edd8&amp;clientId=u1cfd4743-4f7a-4&amp;from=paste&amp;height=409&amp;id=uf7e5993d&amp;originHeight=613&amp;originWidth=1183&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=265488&amp;status=done&amp;style=none&amp;taskId=u2e0f536b-df6a-4524-9597-c248a30c851&amp;title=&amp;width=788.6666666666666" alt="image.png" /></p><h1 id="7-svm"><a class="markdownIt-Anchor" href="#7-svm"></a> 7 SVM</h1><p>找到能够最大化不同类别数据间隔的超平面，通过最大化决策边界和支持向量的距离提高模型的泛化能力，将数据映射到高维空间中实现线性可分</p><h2 id="71-间隔与支持向量"><a class="markdownIt-Anchor" href="#71-间隔与支持向量"></a> 7.1 间隔与支持向量</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704246165540-92d279de-7f4e-48dd-bd8a-af639693ae5f.png#averageHue=%23f9f7f6&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=493&amp;id=u656677ea&amp;originHeight=739&amp;originWidth=1147&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=200230&amp;status=done&amp;style=none&amp;taskId=u8d629cc3-21ff-4069-a96d-aec8164668a&amp;title=&amp;width=764.6666666666666" alt="image.png" /><br />【间隔】每个样本点到分界超平面的垂直距离<br />【支持向量】所有样本中拥有最小间隔的点<br />【SVM目标】最大化最小间隔</p><h2 id="72-计算"><a class="markdownIt-Anchor" href="#72-计算"></a> 7.2 计算</h2><h3 id="721-点到法平面距离"><a class="markdownIt-Anchor" href="#721-点到法平面距离"></a> 7.2.1 点到法平面距离</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704246458529-f27a7560-06d2-4c99-bf43-7cdfb753ddd1.png#averageHue=%23f7f5f4&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=348&amp;id=u5bf482ca&amp;originHeight=522&amp;originWidth=1132&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=211823&amp;status=done&amp;style=none&amp;taskId=u775ea354-8465-45bc-90e0-ed04f2f5643&amp;title=&amp;width=754.6666666666666" alt="image.png" /><br />f(x)&gt;0是正类，反之负类。判断分类预测的正误可以使用yf(x)&gt;0来确认，&lt;0表示分类不统一，错误</p><h3 id="722-优化"><a class="markdownIt-Anchor" href="#722-优化"></a> 7.2.2 优化</h3><ul><li>只需要方向，不需要大小，令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">||w||=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">∣</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li>限制<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msup><mi>w</mi><mi>T</mi></msup><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">min(y_if(x_i)) = min(y_i (w^Tx_i+b)) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>（最优解除以任意非0倍数依然是最优解），此时相当于最大化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{||w||}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.365108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mord mtight">∣</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，即最小化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mi>w</mi><mi>T</mi></msup><mi>w</mi></mrow><annotation encoding="application/x-tex">\frac{1}{2}w^Tw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>（加1/2为了消除求导平方系数）</li></ul><h3 id="723-求解"><a class="markdownIt-Anchor" href="#723-求解"></a> 7.2.3 求解</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704247513799-7933e49b-8ad1-45c6-8a90-cfdafe1a40bc.png#averageHue=%23faf8f8&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=416&amp;id=u3c165688&amp;originHeight=624&amp;originWidth=1000&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=153439&amp;status=done&amp;style=none&amp;taskId=u289fef1a-025e-4e6b-8159-2e07f7a18c0&amp;title=&amp;width=666.6666666666666" alt="image.png" /></p><h4 id="7231-kkt条件"><a class="markdownIt-Anchor" href="#7231-kkt条件"></a> 7.2.3.1 KKT条件</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704247946483-f8bdc631-0735-4592-9d6f-0579b2d3e86e.png#averageHue=%23faf8f8&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=445&amp;id=ufa1dff4e&amp;originHeight=667&amp;originWidth=1093&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=159685&amp;status=done&amp;style=none&amp;taskId=u2bf1b48e-e34f-418d-9e08-b5d68b736e0&amp;title=&amp;width=728.6666666666666" alt="image.png" /></p><h4 id="7232-对偶"><a class="markdownIt-Anchor" href="#7232-对偶"></a> 7.2.3.2 对偶</h4><p>引入拉格朗日乘子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>后，该乘子构成对偶空间<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704248036562-8ea4d2b9-cdbd-47f2-ad13-4ae3d5edfd45.png#averageHue=%23fcfbfb&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=191&amp;id=u77e67fb3&amp;originHeight=286&amp;originWidth=1002&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=59036&amp;status=done&amp;style=none&amp;taskId=u90e3daa6-9a4c-48dd-bc63-48e28cf51d8&amp;title=&amp;width=668" alt="image.png" /></p><h4 id="7233-最优解"><a class="markdownIt-Anchor" href="#7233-最优解"></a> 7.2.3.3 最优解</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704248154157-f3f1873e-4119-421f-a8c6-92a97ed5410a.png#averageHue=%23faf9f9&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=371&amp;id=uf1b62d4f&amp;originHeight=556&amp;originWidth=1023&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=153722&amp;status=done&amp;style=none&amp;taskId=u8b326fb3-edeb-4789-9302-2d9420bfe9e&amp;title=&amp;width=682" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704248178406-f3d233c7-b955-49c4-8a4a-b31446dfcc2d.png#averageHue=%23fbf9f9&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=383&amp;id=u8e8fa6c4&amp;originHeight=574&amp;originWidth=961&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=124528&amp;status=done&amp;style=none&amp;taskId=u1271a148-38e8-403f-8fff-ae1d6562dac&amp;title=&amp;width=640.6666666666666" alt="image.png" /></p><h2 id="73-soft-margin"><a class="markdownIt-Anchor" href="#73-soft-margin"></a> 7.3 soft margin</h2><p>惩罚：松弛变量<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704248279370-2d8cddc0-3e7d-4010-a558-a13833190700.png#averageHue=%23f9f8f7&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=367&amp;id=u4f1e5f83&amp;originHeight=550&amp;originWidth=1047&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=193853&amp;status=done&amp;style=none&amp;taskId=ud54c1f0a-5247-4a2b-a13a-251d89ce2eb&amp;title=&amp;width=698" alt="image.png" /></p><h2 id="74-非线性svm"><a class="markdownIt-Anchor" href="#74-非线性svm"></a> 7.4 非线性SVM</h2><p>映射到更高维的特征空间使得样本线性可分</p><h3 id="741-kernel-trick"><a class="markdownIt-Anchor" href="#741-kernel-trick"></a> 7.4.1 kernel trick</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704248571064-ef1d2c5b-b461-4d84-9fe1-f822a94f86a8.png#averageHue=%23f6f5f3&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=350&amp;id=uc7d3827b&amp;originHeight=525&amp;originWidth=1036&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=210383&amp;status=done&amp;style=none&amp;taskId=uc8add346-e987-403b-8d75-995f81974ad&amp;title=&amp;width=690.6666666666666" alt="image.png" /></p><h3 id="742-mercers-condition"><a class="markdownIt-Anchor" href="#742-mercers-condition"></a> 7.4.2 Mercer’s condition</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704248682735-38f9cdb2-4b94-4838-82f7-6256a3c593be.png#averageHue=%23f7f5f3&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=302&amp;id=u3ed4b1a7&amp;originHeight=453&amp;originWidth=1062&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=193394&amp;status=done&amp;style=none&amp;taskId=u9284b88b-2024-4edd-b28d-ce482dd1033&amp;title=&amp;width=708" alt="image.png" /></p><h3 id="743-kernel-svm"><a class="markdownIt-Anchor" href="#743-kernel-svm"></a> 7.4.3 Kernel SVM</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704249047988-47c03703-47ab-4569-a99e-bcd8315b1e08.png#averageHue=%23f6f4f2&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=385&amp;id=u65d87cfd&amp;originHeight=577&amp;originWidth=988&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=199604&amp;status=done&amp;style=none&amp;taskId=u6f7d80ea-1839-4e21-b963-4db5e62ad57&amp;title=&amp;width=658.6666666666666" alt="image.png" /><br />测试时间为O(nd)</p><h4 id="7431-线性核"><a class="markdownIt-Anchor" href="#7431-线性核"></a> 7.4.3.1 线性核</h4><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mi>T</mi></msup><mi>y</mi></mrow><annotation encoding="application/x-tex">K(x,y) = x^T y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></p><h4 id="7432-rbfgaussian核"><a class="markdownIt-Anchor" href="#7432-rbfgaussian核"></a> 7.4.3.2 RBF/Gaussian核</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704249384746-e894ab74-d7d9-43cc-84cf-930e7ec7e29e.png#averageHue=%23efeeec&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=81&amp;id=u696ec210&amp;originHeight=121&amp;originWidth=751&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=39423&amp;status=done&amp;style=none&amp;taskId=ua33b5132-7031-4b99-b355-f55b13acf98&amp;title=&amp;width=500.6666666666667" alt="image.png" /></p><h4 id="7433-多项式核"><a class="markdownIt-Anchor" href="#7433-多项式核"></a> 7.4.3.3 多项式核</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704249409012-9a9cb04c-8150-4423-90d8-2715a9d98578.png#averageHue=%23f3f1f0&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=59&amp;id=uee00fc25&amp;originHeight=88&amp;originWidth=391&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=13684&amp;status=done&amp;style=none&amp;taskId=ubec03e3a-94c2-48e9-ba4f-e1ca1b58a7c&amp;title=&amp;width=260.6666666666667" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704249518616-43983e3c-c5b9-49d7-a2eb-c3960c038e27.png#averageHue=%23f8f5f5&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=472&amp;id=ud5080357&amp;originHeight=708&amp;originWidth=1057&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=154422&amp;status=done&amp;style=none&amp;taskId=uaaeda80a-fc29-4e31-8ca7-9b5cc8efcda&amp;title=&amp;width=704.6666666666666" alt="image.png" /><br />【超参数】<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704249502258-d5ba2f56-e447-4f58-947b-cbf7b0bc9a3d.png#averageHue=%23f7f5f4&amp;clientId=u11c3f106-9eb4-4&amp;from=paste&amp;height=303&amp;id=ucfecd9dd&amp;originHeight=454&amp;originWidth=1063&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=191753&amp;status=done&amp;style=none&amp;taskId=u040b6c79-7520-469a-9c72-c977bf0dd25&amp;title=&amp;width=708.6666666666666" alt="image.png" /></p><h2 id="75-多类svm"><a class="markdownIt-Anchor" href="#75-多类svm"></a> 7.5 多类SVM</h2><h3 id="751-1v1"><a class="markdownIt-Anchor" href="#751-1v1"></a> 7.5.1 1V1</h3><p>转化为两类问题，构造<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">C_n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>个分类器<br />将一个样本得到的所有结果按照投票法做决定</p><h3 id="752-1-v-all"><a class="markdownIt-Anchor" href="#752-1-v-all"></a> 7.5.2 1 V all</h3><p>共n个类，设置n个分类器，每个分类器用类i做正类，其他所有类做负类<br />每个分类器采用实际值输出作为信心，选择信心最高类</p><h1 id="8-神经元与感知机"><a class="markdownIt-Anchor" href="#8-神经元与感知机"></a> 8 神经元与感知机</h1><h2 id="81-hebbian-theory赫布理论"><a class="markdownIt-Anchor" href="#81-hebbian-theory赫布理论"></a> 8.1 Hebbian Theory赫布理论</h2><p>连接强度的调整量和输入输出的乘积成正比，经常出现的模式将增强神经元之间的连接<br />又称长度增强机制（LTP：Long Term Potentiation）或神经可塑（Neural Plasticity）</p><h2 id="82-mp神经元"><a class="markdownIt-Anchor" href="#82-mp神经元"></a> 8.2 MP神经元</h2><h3 id="821-基本工作原理"><a class="markdownIt-Anchor" href="#821-基本工作原理"></a> 8.2.1 基本工作原理</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704290638932-0ee33e10-b189-4854-afbf-37b64df5ca61.png#averageHue=%23f0f0f0&amp;clientId=uee44fb03-d81d-4&amp;from=paste&amp;height=141&amp;id=u9205ea46&amp;originHeight=211&amp;originWidth=508&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=23485&amp;status=done&amp;style=none&amp;taskId=u08c5a3c5-3e97-4e6f-96d6-5e4ff1735ee&amp;title=&amp;width=338.6666666666667" alt="image.png" /><br />输入 -》 权值 -》 激活函数<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704290750702-4be51ad0-82eb-441a-a4a7-32fd60ce60ed.png#averageHue=%23faf9f9&amp;clientId=uee44fb03-d81d-4&amp;from=paste&amp;height=456&amp;id=ua8d301ad&amp;originHeight=684&amp;originWidth=1108&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=188857&amp;status=done&amp;style=none&amp;taskId=uc5221662-5ba3-47bc-af0e-063d5af07c2&amp;title=&amp;width=738.6666666666666" alt="image.png" /></p><h3 id="822-局限"><a class="markdownIt-Anchor" href="#822-局限"></a> 8.2.2 局限</h3><p>输入：线性求和<br />输出：单一输出值<br />更新：时钟同步更新</p><h3 id="823-激活函数"><a class="markdownIt-Anchor" href="#823-激活函数"></a> 8.2.3 激活函数</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704290929368-a09f7cb3-9f98-48be-b3b3-4c339e6fe377.png#averageHue=%23faf6f6&amp;clientId=uee44fb03-d81d-4&amp;from=paste&amp;height=479&amp;id=u8fc2c09d&amp;originHeight=718&amp;originWidth=1038&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=189170&amp;status=done&amp;style=none&amp;taskId=u55a6ec55-c6f1-4f17-93a7-e73d35f9b8b&amp;title=&amp;width=692" alt="image.png" /><br />【sigmoid】<br />饱和激活函数（tanh）<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>n</mi><mo>→</mo><mo>+</mo><mi>inf</mi><mo>⁡</mo></mrow></msub><msup><mi>h</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>n</mi><mo>→</mo><mo>−</mo><mi>inf</mi><mo>⁡</mo></mrow></msub><msup><mi>h</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lim_{n \to +\inf}h&#x27;(x) = \lim_{n\to-\inf}h&#x27;(x) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">→</span><span class="mord mtight">+</span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mop mtight">in<span style="margin-right:0.07778em;">f</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">→</span><span class="mord mtight">−</span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mop mtight">in<span style="margin-right:0.07778em;">f</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>饱和激活函数<br />导数始终小于1，在0周围变化，容易造成梯度消失问题<br />指数的计算代价大<br />【ReLU】<br />非饱和激活函数可以解决梯度消失问题，加快模型收敛速度<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704291289160-443aa5b2-62c5-4603-aeae-d72accd31a3d.png#averageHue=%23f8f7f7&amp;clientId=uee44fb03-d81d-4&amp;from=paste&amp;height=372&amp;id=u51d5a8c8&amp;originHeight=558&amp;originWidth=1128&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=129964&amp;status=done&amp;style=none&amp;taskId=u904e052f-bb22-4f2b-b419-279f5d70ed0&amp;title=&amp;width=752" alt="image.png" /></p><h2 id="83-感知机"><a class="markdownIt-Anchor" href="#83-感知机"></a> 8.3 感知机</h2><p>最简单形式的前馈式人工神经网络<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704292415394-178ad335-3a82-4e5b-85bb-f3690795df7e.png#averageHue=%23f9f7f7&amp;clientId=uee44fb03-d81d-4&amp;from=paste&amp;height=435&amp;id=u7eadf653&amp;originHeight=652&amp;originWidth=991&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=134018&amp;status=done&amp;style=none&amp;taskId=ua39a1895-e652-4bbb-9fbe-ec69582427c&amp;title=&amp;width=660.6666666666666" alt="image.png" /></p><ul><li>同层内无互联，不同层间没有反馈</li><li>输入输出均为离散值</li><li>由阈值函数决定输出</li></ul><p>c：学习率，d：期望输出（1或-1），signal：感知机输出<br />【偏置单元<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>】取常数，通常为1<br />【重要计算】根据样本序列调整权重参数</p><h3 id="831-感知机学习算法"><a class="markdownIt-Anchor" href="#831-感知机学习算法"></a> 8.3.1 感知机学习算法</h3><ol><li>权值初始化</li><li>输入样本对</li><li>计算输出</li><li>根据学习规则调整权重</li><li>返回步骤2，接着输入下一对样本，直到所有样本的实际输出与期望输出相等</li></ol><h3 id="832-线性可分性"><a class="markdownIt-Anchor" href="#832-线性可分性"></a> 8.3.2 线性可分性</h3><p>【感知机收敛理论】定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span>是分离超平面和最接近的数据点之间的距离，迭代次数的界是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><msup><mi>γ</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{\gamma^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>（前提是样例是线性可分的）<br />单层神经网络不能解决非线性可分问题：如异或<br />用多层网络处理异或（二层神经网络可以表达所有的布尔函数）</p><h1 id="9-神经网络"><a class="markdownIt-Anchor" href="#9-神经网络"></a> 9 神经网络</h1><h2 id="91-多层感知机mlp"><a class="markdownIt-Anchor" href="#91-多层感知机mlp"></a> 9.1 多层感知机MLP</h2><p>又称BP神经网络，back propagation</p><h3 id="911-基本结构"><a class="markdownIt-Anchor" href="#911-基本结构"></a> 9.1.1 基本结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704330543169-1d4bfd3a-9da8-418d-bcaa-1be8524ae8e9.png#averageHue=%23fbfbfb&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=473&amp;id=u4f50aa77&amp;originHeight=709&amp;originWidth=1038&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=151139&amp;status=done&amp;style=none&amp;taskId=u98127244-0fdf-48da-b7dc-5a39414e6ea&amp;title=&amp;width=692" alt="image.png" /></p><ul><li>为什么要使用隐藏层？隐藏层是特征检测算子，隐藏层用于发现并刻画数据的特征，可以帮助模型学习非线性和更复杂的模式。</li><li>如何更新隐藏层的权值？<strong>前向+反向</strong></li></ul><h3 id="912-反向传播"><a class="markdownIt-Anchor" href="#912-反向传播"></a> 9.1.2 反向传播</h3><p>误差反传算法BP</p><h4 id="9121-误差定义"><a class="markdownIt-Anchor" href="#9121-误差定义"></a> 9.1.2.1 误差定义</h4><ul><li>经典感知机（N=1）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><msub><mi>E</mi><mi>k</mi></msub><mo>=</mo><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mo stretchy="false">(</mo><msub><mi>y</mi><mi>k</mi></msub><mo>−</mo><msub><mi>t</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Sigma_{k=1}^N E_k = \Sigma_{k=1}^N (y_k-t_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1244389999999997em;vertical-align:-0.2831079999999999em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1244389999999997em;vertical-align:-0.2831079999999999em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li>多层感知机（BP神经网络）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msubsup><mi mathvariant="normal">Σ</mi><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mo stretchy="false">(</mo><msub><mi>y</mi><mi>k</mi></msub><mo>−</mo><msub><mi>t</mi><mi>k</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E = \frac{1}{2}\Sigma_{k=1}^N (y_k-t_k)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 1/2非必须</li></ul><h4 id="9122-delta规则"><a class="markdownIt-Anchor" href="#9122-delta规则"></a> 9.1.2.2 Delta规则</h4><p>基于误差平面，激活函数必须是<strong>连续的可微分的</strong><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704331603693-887160f3-81d1-4e55-bbfb-861900121681.png#averageHue=%23f7f6f6&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=239&amp;id=u421dd312&amp;originHeight=358&amp;originWidth=1024&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=83478&amp;status=done&amp;style=none&amp;taskId=u90028b8d-9290-4094-bd73-6b68d96582c&amp;title=&amp;width=682.6666666666666" alt="image.png" /><br />误差定义中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">t_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可以按照<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msubsup><mi>W</mi><mi>k</mi><mi>T</mi></msubsup><mo separator="true">⋅</mo><msub><mi>X</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(W_k^T · X_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1244389999999997em;vertical-align:-0.2831079999999999em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4168920000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2831079999999999em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>计算<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704331905560-838fea62-ccf2-4325-b394-d5ea946cae77.png#averageHue=%23f9f6f5&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=346&amp;id=ucb90c66e&amp;originHeight=519&amp;originWidth=1038&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=127728&amp;status=done&amp;style=none&amp;taskId=u2bf4a867-bebe-41bf-9393-3a6c244fb25&amp;title=&amp;width=692" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704331969748-2a56013d-a087-4c5a-94c4-ed7270a20866.png#averageHue=%23f7f5f4&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=344&amp;id=u3f7df104&amp;originHeight=418&amp;originWidth=841&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=96914&amp;status=done&amp;style=none&amp;taskId=u2c256b55-8451-42f4-b9f2-0aa0486d7d9&amp;title=&amp;width=692.6666870117188" alt="image.png" /><br />【学习常数c的影响】<br />c决定学习过程中权值变化快慢<br />c过大，容易越过最优值或在最优值附近震荡</p><h4 id="9123-反向传播算法bp"><a class="markdownIt-Anchor" href="#9123-反向传播算法bp"></a> 9.1.2.3 反向传播算法BP</h4><p>前向：权值固定，输入信号经过网络正向一层层传播，达到输出端<br />反向：比较输出和期望输出，产生误差信号，误差信号通过网络反向一层层传播，对每一层权值进行修正<br />【信用分配难题】如何给隐藏层神经元分配信用或责任？<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704332969374-345b33d7-530e-4c15-9323-b9a5329df6f9.png#averageHue=%23f8f8f7&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=419&amp;id=u8e9d476c&amp;originHeight=628&amp;originWidth=1144&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=181600&amp;status=done&amp;style=none&amp;taskId=u28ef0d36-30ae-4e1f-8e73-f11c1a9c3d7&amp;title=&amp;width=762.6666666666666" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704333009116-846c5f07-a677-4226-a7cf-b4b2884cacfa.png#averageHue=%23fbf6f5&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=245&amp;id=u78f9f5b9&amp;originHeight=367&amp;originWidth=1065&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=95106&amp;status=done&amp;style=none&amp;taskId=u6b7a1139-72e6-40d0-bb12-a05b889de3f&amp;title=&amp;width=710" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704333068720-2f8192f2-1c20-4173-94c2-8d2c671697bb.png#averageHue=%23fbf8f8&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=293&amp;id=u6435e7f5&amp;originHeight=439&amp;originWidth=1086&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=119088&amp;status=done&amp;style=none&amp;taskId=u746c92e5-b807-42fa-b22a-263aaa3ae6f&amp;title=&amp;width=724" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704333135535-1d80313c-5f29-4284-b28f-6d2eda8c03ea.png#averageHue=%23faf3f3&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=232&amp;id=u67fa6669&amp;originHeight=348&amp;originWidth=774&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=74310&amp;status=done&amp;style=none&amp;taskId=ue87148f3-475d-45e7-8d1a-2ce63399012&amp;title=&amp;width=516" alt="image.png" /><br />【权值修正的两种情况】</p><ul><li>神经元j是输出层节点：直接使用delta规则</li><li>j是隐藏层：没有指定输出</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704333511361-2303c4c1-6dcf-48e0-972b-6a8fa9292497.png#averageHue=%23f5efee&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=81&amp;id=u03b8d41d&amp;originHeight=121&amp;originWidth=1077&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=37015&amp;status=done&amp;style=none&amp;taskId=u14ad4f4e-4458-4c8e-90fa-b951e10a11b&amp;title=&amp;width=718" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704333523049-f6202f2b-d583-4387-a913-fc5d8316c169.png#averageHue=%23f5f3f2&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=89&amp;id=u4842decd&amp;originHeight=133&amp;originWidth=636&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=23942&amp;status=done&amp;style=none&amp;taskId=u3e9e8fab-387c-49de-acf8-043b4059f39&amp;title=&amp;width=424" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704333689624-ce677a1e-9df9-4ff7-bd9c-c2042fbad890.png#averageHue=%23f8f3f3&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=587&amp;id=ubbc098b8&amp;originHeight=880&amp;originWidth=1090&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=212400&amp;status=done&amp;style=none&amp;taskId=u32bd9ce0-fb27-4a76-b761-5c4472e9fc3&amp;title=&amp;width=726.6666666666666" alt="image.png" /><br />隐藏层到输出层的梯度d1以error<em>f’直接计算<br />输入层到隐藏层的梯度d2 = f’</em>(所有d1*w的和）计算</p><h4 id="9124-梯度下降"><a class="markdownIt-Anchor" href="#9124-梯度下降"></a> 9.1.2.4 梯度下降</h4><ul><li>随机梯度下降</li><li>批量梯度下降（mini-batch随机梯度下降）</li></ul><p><strong>局部梯度域</strong>是指在神经网络中，对于每个特定的参数或权重，它所在的损失函数的梯度的局部环境。换句话说，局部梯度域描述了在参数空间中某一点附近损失函数的变化情况。</p><h3 id="913-影响因素"><a class="markdownIt-Anchor" href="#913-影响因素"></a> 9.1.3 影响因素</h3><h4 id="9131-初始权值"><a class="markdownIt-Anchor" href="#9131-初始权值"></a> 9.1.3.1 初始权值</h4><p>使用正态分布，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>∼</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w\sim (0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，输出值~（0，n）<br />独立变量和的方差 = 独立变量方差和<br />如果初始权值<strong>过大</strong>，会导致输出值过大，激活函数饱和，梯度消失（学习失效）</p><h4 id="9132-顺序和批量训练"><a class="markdownIt-Anchor" href="#9132-顺序和批量训练"></a> 9.1.3.2 顺序和批量训练</h4><ul><li>批量训练：计算所有样本误差和（计算代价大、收敛速度快、局部极小）</li><li>顺序训练：按次序计算每个样本的误差（局部极小、噪声敏感）</li><li>小批量训练：适合大规模数据</li></ul><p>【冲量】<br />加大搜索步长的效果，越过狭窄的局部极小值</p><h4 id="9133-停止机制"><a class="markdownIt-Anchor" href="#9133-停止机制"></a> 9.1.3.3 停止机制</h4><ul><li>设定固定<strong>迭代步数</strong></li><li>设定误差小于固定<strong>阈值</strong></li><li>两者结合</li></ul><p>利用验证集选择合适参数</p><h2 id="92-自动编码器"><a class="markdownIt-Anchor" href="#92-自动编码器"></a> 9.2 自动编码器</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704335111454-8b0ddead-93eb-4434-a752-213085ba6633.png#averageHue=%23f9f8f5&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=405&amp;id=ua98b498d&amp;originHeight=607&amp;originWidth=1092&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=182034&amp;status=done&amp;style=none&amp;taskId=u72792935-a016-45ec-bf55-f3153c63a4d&amp;title=&amp;width=728" alt="image.png" /><br />结构：编码器+解码器<br />高维到低维，减少神经元数量；低维到高维，增加<br />前向 -&gt; 重构 -&gt; 计算损失 -&gt; 反向</p><h2 id="93-径向基网络rbf"><a class="markdownIt-Anchor" href="#93-径向基网络rbf"></a> 9.3 径向基网络RBF</h2><h3 id="931-感受野"><a class="markdownIt-Anchor" href="#931-感受野"></a> 9.3.1 感受野</h3><p>Receptive Field<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704335233458-544c1360-1e59-4e93-8b6b-7e15f5f86351.png#averageHue=%23fbf8f8&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=423&amp;id=u67a010e3&amp;originHeight=634&amp;originWidth=1036&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=313316&amp;status=done&amp;style=none&amp;taskId=uce1d85cf-5478-4e8a-aa27-2a7d2f64943&amp;title=&amp;width=690.6666666666666" alt="image.png" /><br />激活程度/输出 和 输入数据和权值向量的距离 成比例</p><h3 id="932-激活规则"><a class="markdownIt-Anchor" href="#932-激活规则"></a> 9.3.2 激活规则</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704335471228-7758f1cd-ae06-4fa0-a4e4-435c8d7c59ee.png#averageHue=%23fbfbfb&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=442&amp;id=u1e8d6dc8&amp;originHeight=663&amp;originWidth=1057&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=262357&amp;status=done&amp;style=none&amp;taskId=u4862239d-f557-4f7a-aace-7d065a6ba4e&amp;title=&amp;width=704.6666666666666" alt="image.png" /></p><ul><li>输入空间 -&gt; 隐藏层：非线性变换（核技巧）</li><li>隐藏层 -&gt; 输出层：线性变换（和MLP相同）</li></ul><h3 id="933-学习规则"><a class="markdownIt-Anchor" href="#933-学习规则"></a> 9.3.3 学习规则</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704335615760-2cd734e4-33ab-414b-9927-4274494186be.png#averageHue=%23f7f7f7&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=365&amp;id=udf25592b&amp;originHeight=547&amp;originWidth=1096&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=138052&amp;status=done&amp;style=none&amp;taskId=u68336940-480b-4d7b-88ef-d0ec8fbae2a&amp;title=&amp;width=730.6666666666666" alt="image.png" /><br />求解径向基中心<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，隐藏层到输出层的权值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>W</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">W_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><br />【算法步骤】<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704335791634-7d99db7d-86a2-41e6-a29d-baace6224666.png#averageHue=%23f2f1ec&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=269&amp;id=u9254d87b&amp;originHeight=403&amp;originWidth=987&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=150917&amp;status=done&amp;style=none&amp;taskId=u672b1c38-f85c-4bae-81e3-c589055af8c&amp;title=&amp;width=658" alt="image.png" /></p><h3 id="934-重要原理"><a class="markdownIt-Anchor" href="#934-重要原理"></a> 9.3.4 重要原理</h3><p><strong>隐含层的作用</strong>：把低维度的p映射到高维度的h，变成高维线性可分（核函数的思想）<br />【优点】</p><ul><li>输入到输出非线性，但是输出可调参数是线性的（权值）</li><li>网络的权可以由线性方程组直接解出</li></ul><h3 id="935-rbf与其他模型对比"><a class="markdownIt-Anchor" href="#935-rbf与其他模型对比"></a> 9.3.5 RBF与其他模型对比</h3><h4 id="9351-rbf-vs-mlp"><a class="markdownIt-Anchor" href="#9351-rbf-vs-mlp"></a> 9.3.5.1 RBF VS MLP</h4><ul><li>局部逼近VS全局逼近：BP全局逼近，RBF局部逼近</li><li>中间层数：RBF只能有一个隐含层，BP可以有多个隐含层</li><li>训练速度：RBF训练速度快</li><li>最优性：RBF是连续函数的最佳逼近</li></ul><h4 id="9352-rbf-vs-svm"><a class="markdownIt-Anchor" href="#9352-rbf-vs-svm"></a> 9.3.5.2 RBF VS SVM</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704336266257-60cab565-c497-417c-9664-cd9ddd76a589.png#averageHue=%23f7f6f5&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=403&amp;id=u85176081&amp;originHeight=604&amp;originWidth=1042&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=189820&amp;status=done&amp;style=none&amp;taskId=u7b5a6e69-4ebf-4ef4-adca-849e830f209&amp;title=&amp;width=694.6666666666666" alt="image.png" /></p><h1 id="10-cnn"><a class="markdownIt-Anchor" href="#10-cnn"></a> 10 CNN</h1><h2 id="101-卷积"><a class="markdownIt-Anchor" href="#101-卷积"></a> 10.1 卷积</h2><ul><li>全连接</li><li>局部连接</li></ul><h3 id="1011-超参数"><a class="markdownIt-Anchor" href="#1011-超参数"></a> 10.1.1 超参数</h3><ul><li>depth：number of filters</li><li>stride</li><li>zero-padding</li></ul><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>96</mn></mrow><annotation encoding="application/x-tex">3 \times 3 \times 3 \times 96</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">6</span></span></span></span><br />3*3：核大小，感受野<br />3：3个通道（彩色图像）<br />96：深度，层数，过滤器数目</p><h3 id="1012-池化"><a class="markdownIt-Anchor" href="#1012-池化"></a> 10.1.2 池化</h3><p>下采样<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704337923902-68c90ce3-db71-4b31-a7b4-bab57470c2a7.png#averageHue=%23e5d9c6&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=213&amp;id=u88d97d76&amp;originHeight=319&amp;originWidth=669&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=101622&amp;status=done&amp;style=none&amp;taskId=u8efaa08c-bebd-4df4-b9a3-ee28764b561&amp;title=&amp;width=446" alt="image.png" /><br />【作用】</p><ul><li>减少参数</li><li>避免过拟合</li><li>扩大感受域</li></ul><h3 id="1013-全连接层"><a class="markdownIt-Anchor" href="#1013-全连接层"></a> 10.1.3 全连接层</h3><p>用于全局特征提取（softmax是分类层/头）<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704338023380-d4cdba23-2821-4e53-8adf-594e64300578.png#averageHue=%23f9f9f7&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=280&amp;id=u79fe6d63&amp;originHeight=420&amp;originWidth=841&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=224287&amp;status=done&amp;style=none&amp;taskId=u178639a0-ada1-4005-93ac-96286b3f19e&amp;title=&amp;width=560.6666666666666" alt="image.png" /></p><h3 id="1014-dropoutregularization"><a class="markdownIt-Anchor" href="#1014-dropoutregularization"></a> 10.1.4 Dropout/Regularization</h3><p>对大的神经网络进行平均<br />破坏全连接，以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ρ</span></span></span></span>的概率保留该神经元<br />所有模型架构共享权重 -》 每个模型都受到了非常强的正则化约束</p><h3 id="1015-batch-normalization"><a class="markdownIt-Anchor" href="#1015-batch-normalization"></a> 10.1.5 batch normalization</h3><p>减少内部方差偏移或避免梯度扩散</p><h3 id="1016-损失函数"><a class="markdownIt-Anchor" href="#1016-损失函数"></a> 10.1.6 损失函数</h3><ul><li>交叉熵损失</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704339363334-1286cc6d-98ec-4d8e-a767-411a2c875fad.png#averageHue=%23fbfafa&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=129&amp;id=u853442ed&amp;originHeight=193&amp;originWidth=1009&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=51813&amp;status=done&amp;style=none&amp;taskId=ue9601ce3-dfa5-4e8c-b19c-2992a81e7f2&amp;title=&amp;width=672.6666666666666" alt="image.png" /></p><ul><li>L2-norm</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704339435606-0f5e4231-2b0c-467d-9de3-1c202e3ff599.png#averageHue=%23faf9f9&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=186&amp;id=u31b10356&amp;originHeight=279&amp;originWidth=907&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=46110&amp;status=done&amp;style=none&amp;taskId=u7f38768f-5f17-4aa5-8cea-3c319ab09ec&amp;title=&amp;width=604.6666666666666" alt="image.png" /></p><ul><li>三元组损失</li></ul><h2 id="102-深度学习的一些技巧"><a class="markdownIt-Anchor" href="#102-深度学习的一些技巧"></a> 10.2 深度学习的一些技巧</h2><h1 id="11-演化学习"><a class="markdownIt-Anchor" href="#11-演化学习"></a> 11 演化学习</h1><h2 id="111-遗传算法ga"><a class="markdownIt-Anchor" href="#111-遗传算法ga"></a> 11.1 遗传算法GA</h2><p>基本思想：通过对当前最好的假设模型<strong>重组</strong>来产生后续假设模型</p><h3 id="1111-基本概念"><a class="markdownIt-Anchor" href="#1111-基本概念"></a> 11.1.1 基本概念</h3><h4 id="11111-染色体"><a class="markdownIt-Anchor" href="#11111-染色体"></a> 11.1.1.1 染色体</h4><p>【一个合取/析取的表示实例】<br />有两种属性，对应<strong>是否</strong>去打网球两种结果</p><ul><li>outlook：sunny/overcast/rain</li><li>wind：strong/weak</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704352238678-7d2e5ad4-5f4e-4dc4-bf41-4887d49e5bca.png#averageHue=%23faf4f4&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=427&amp;id=u15840ae2&amp;originHeight=640&amp;originWidth=1096&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=190116&amp;status=done&amp;style=none&amp;taskId=u32866ff4-ee9c-414d-a3b1-ecebf810850&amp;title=&amp;width=730.6666666666666" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704352263649-36c524f4-8a46-4026-8a53-3e02886b0f22.png#averageHue=%23f7f3f2&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=233&amp;id=u403fcfbf&amp;originHeight=349&amp;originWidth=663&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=71821&amp;status=done&amp;style=none&amp;taskId=u86ba8e4e-51bb-4f36-86fe-42d2543d0eb&amp;title=&amp;width=442" alt="image.png" /><br />【染色体表示】01位串<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704352653859-8aef9bf5-2fe1-4ff8-ad83-3a5a8745b528.png#averageHue=%23f5f3f2&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=384&amp;id=ue75beaf8&amp;originHeight=576&amp;originWidth=1102&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=245015&amp;status=done&amp;style=none&amp;taskId=udfe0e267-3a19-4d5f-a19f-8dedd228f3e&amp;title=&amp;width=734.6666666666666" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704352823805-d00573b9-6b91-4674-8e49-08e275a4ebfe.png#averageHue=%23f6f2f1&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=422&amp;id=u9a70384a&amp;originHeight=633&amp;originWidth=1078&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=233248&amp;status=done&amp;style=none&amp;taskId=uaf275440-edfc-4dc3-98ec-81ce32e1876&amp;title=&amp;width=718.6666666666666" alt="image.png" /><br />染色体相当于训练数据输入</p><h4 id="11112-适应度函数种群"><a class="markdownIt-Anchor" href="#11112-适应度函数种群"></a> 11.1.1.2 适应度函数/种群</h4><p>适应度函数：学习的目标函数<br />种群表示一组染色体和计算的适应度<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704352932609-dfbfe6e2-2597-452d-9a41-6d6b5d5971d5.png#averageHue=%23f7f6f5&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=255&amp;id=u54dd9657&amp;originHeight=382&amp;originWidth=994&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=84296&amp;status=done&amp;style=none&amp;taskId=u74c09283-be2a-4acd-a3a6-d85b0c5b934&amp;title=&amp;width=662.6666666666666" alt="image.png" /></p><h4 id="11113-产生后代"><a class="markdownIt-Anchor" href="#11113-产生后代"></a> 11.1.1.3 产生后代</h4><p>基于适应度函数，有以下几种选择方式：</p><ul><li><strong>锦标赛选择</strong>：每次选n个（有放回抽样），选择最好的一个进入子代种群（重复直到子代与原来种群规模一致）</li><li><strong>截断选择</strong>：根据适应度排序，选择前k个；然后复制染色体达到相同的规模</li><li><strong>轮盘赌选择</strong>：与适应度成比例选择</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704353208218-b5d504b1-003f-4f99-a7e4-6b2b650e80bb.png#averageHue=%23f3f2f1&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=100&amp;id=u1f145091&amp;originHeight=150&amp;originWidth=723&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=38022&amp;status=done&amp;style=none&amp;taskId=u518de7ab-b99b-48ee-b849-44dda90328c&amp;title=&amp;width=482" alt="image.png" /></p><h3 id="1112-一般形式"><a class="markdownIt-Anchor" href="#1112-一般形式"></a> 11.1.2 一般形式</h3><ol><li>初始化种群P(t)：一般来说第0代种群随机生成</li><li>如果不满足终止条件<ol><li>评估每个染色体适应度</li><li>选择染色体产生后代</li><li>用后代替换染色体并重复这一阶段步骤</li></ol></li><li>终止</li></ol><h3 id="1113-遗传算子"><a class="markdownIt-Anchor" href="#1113-遗传算子"></a> 11.1.3 遗传算子</h3><p>GA Operator，对当前群体中的染色体进行重组以产生后代</p><h4 id="11131-交叉crossover"><a class="markdownIt-Anchor" href="#11131-交叉crossover"></a> 11.1.3.1 交叉crossover</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704353477285-10c1c67a-2142-4b9e-85a4-3e18061101dd.png#averageHue=%23f3eeeb&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=285&amp;id=ub8898422&amp;originHeight=427&amp;originWidth=1087&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=320936&amp;status=done&amp;style=none&amp;taskId=uc3f20fe4-b8cd-445a-929e-1ab44f79304&amp;title=&amp;width=724.6666666666666" alt="image.png" /></p><h4 id="11132-变异"><a class="markdownIt-Anchor" href="#11132-变异"></a> 11.1.3.2 变异</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704353513698-427498d2-51bb-421c-82b7-193d7499514f.png#averageHue=%23f4f0ee&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=383&amp;id=uf370f614&amp;originHeight=574&amp;originWidth=895&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=227559&amp;status=done&amp;style=none&amp;taskId=u24289b29-ee89-4204-a64b-909c658a5a5&amp;title=&amp;width=596.6666666666666" alt="image.png" /></p><h3 id="1114-种群演化"><a class="markdownIt-Anchor" href="#1114-种群演化"></a> 11.1.4 种群演化</h3><ul><li><strong>简易方案</strong>：后代替代父代（易丢失优秀解）</li><li><strong>精英法</strong>：保留上一代最优，差的用子代替换（与选择算子混用）</li><li><strong>锦标赛法</strong>：父代与后代参与竞争，选择胜者</li><li><strong>小生境法</strong>：先分类，每类选择优秀代表组成群，群内和群间杂交变异产生新一代</li></ul><p>新一代选择机制：</p><ul><li>预选择：只使用高适应度子代替换父代</li><li>排挤：子代与父代模式相似的个体被替换</li><li>共享：计算适应度和模式的关联关系，共享这种模式（见模式理论部分）</li></ul><h3 id="1115-问题"><a class="markdownIt-Anchor" href="#1115-问题"></a> 11.1.5 问题</h3><ul><li>编码不规范，表示不准确</li><li>约束：单一遗传算法编码不能全面表示优化问题的约束</li><li>搜索效率低，容易过早收敛</li><li>没有有效定量分析的手段</li></ul><h2 id="112-模式理论"><a class="markdownIt-Anchor" href="#112-模式理论"></a> 11.2 模式理论</h2><h3 id="1121-基本概念"><a class="markdownIt-Anchor" href="#1121-基本概念"></a> 11.2.1 基本概念</h3><p>模式是由0，1，#组成的任意串，#表示既可以是0也可以是1<br />阶o(H)表示模式中确定位置的个数，如o(##1#0) = 2<br />长度d(H)表示第一个确定位置到最后一个确定位置的距离d(##1#0) = 2<br />m(s,t)表示第t代种群中，模式s的实例数量</p><h3 id="1122-理论"><a class="markdownIt-Anchor" href="#1122-理论"></a> 11.2.2 理论</h3><p>根据GA原理，推断m(s,t+1)的期望值</p><h1 id="12-维度约简"><a class="markdownIt-Anchor" href="#12-维度约简"></a> 12 维度约简</h1><h2 id="121-特征选择和降维"><a class="markdownIt-Anchor" href="#121-特征选择和降维"></a> 12.1 特征选择和降维</h2><ul><li>特征选择</li><li>特征诱导/变化</li></ul><p>搜索最优特征子集</p><ul><li>前向：起点为空集</li><li>后向：起点为全集</li><li>双向</li></ul><h3 id="1211-搜索策略"><a class="markdownIt-Anchor" href="#1211-搜索策略"></a> 12.1.1 搜索策略</h3><ul><li>穷举</li><li>序列</li><li>随机</li></ul><h3 id="1212-特征评估"><a class="markdownIt-Anchor" href="#1212-特征评估"></a> 12.1.2 特征评估</h3><ul><li>过滤式：距离度量（方差）、互信息熵、依赖性度量（皮尔逊相关系数、卡方检验）、一致性度量</li><li>封装式：分类错误率</li><li>嵌入式：模型正则化+稀疏约束</li></ul><h2 id="122-线性判别分析lda"><a class="markdownIt-Anchor" href="#122-线性判别分析lda"></a> 12.2 线性判别分析LDA</h2><p>linear discriminant analysis<br /><strong>有监督的聚类</strong>特征降维方法：给定标注类别的高维数据集，投影到低维的超平面</p><h3 id="1221-目标"><a class="markdownIt-Anchor" href="#1221-目标"></a> 12.2.1 目标</h3><p>投影使得类内越近越好，类间越远越好<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704357723211-cfa9ccd8-5c1e-4874-914a-6393d9418433.png#averageHue=%23f8f8f7&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=335&amp;id=u8ba0fb41&amp;originHeight=502&amp;originWidth=1117&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=164013&amp;status=done&amp;style=none&amp;taskId=uc585759a-4592-461c-9c15-fe8762e70a1&amp;title=&amp;width=744.6666666666666" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704357789937-3a258ced-9f50-43c2-842e-662b9241f7dd.png#averageHue=%23f7f5f4&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=234&amp;id=uaec3241d&amp;originHeight=351&amp;originWidth=961&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=79187&amp;status=done&amp;style=none&amp;taskId=u00b57f8a-da45-435b-9bfe-5537e837b06&amp;title=&amp;width=640.6666666666666" alt="image.png" /><br />目标是最小化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><msup><mi>w</mi><mi>T</mi></msup><msub><mi>S</mi><mi>W</mi></msub><mi>w</mi></mrow><mrow><msup><mi>w</mi><mi>T</mi></msup><msub><mi>S</mi><mi>B</mi></msub><mi>w</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{w^TS_Ww}{w^TS_Bw}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5058399999999998em;vertical-align:-0.45216999999999996em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0536699999999999em;"><span style="top:-2.6481350000000003em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7740928571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.410305em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9190928571428572em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:-0.05764em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.14329285714285717em;"><span></span></span></span></span></span></span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.45216999999999996em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><h3 id="1222-计算"><a class="markdownIt-Anchor" href="#1222-计算"></a> 12.2.2 计算</h3><p>对目标式w求导，令导数为0，得到极值<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704358015933-434577b4-ef2f-45c1-98ad-d66fb1b4d129.png#averageHue=%23f6f5f5&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=302&amp;id=u4effcb18&amp;originHeight=453&amp;originWidth=675&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=76789&amp;status=done&amp;style=none&amp;taskId=uc8f89e2c-91df-4d0f-8de4-c6bea91ffca&amp;title=&amp;width=450" alt="image.png" /></p><h3 id="1223-算法流程"><a class="markdownIt-Anchor" href="#1223-算法流程"></a> 12.2.3 算法流程</h3><ol><li>计算每个类别均值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>μ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\mu_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，全局样本<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span></li><li>计算类内散度矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>W</mi></msub></mrow><annotation encoding="application/x-tex">S_W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，类间散度矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">S_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>对矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>S</mi><mi>W</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>S</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">S_W^{-1}S_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.14777em;vertical-align:-0.293531em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.4064690000000004em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.293531em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>做特征值分解</li><li>取数目最多的特征值对应的特征向量作为投影向量</li><li>计算投影矩阵</li></ol><h3 id="1224-例题理解"><a class="markdownIt-Anchor" href="#1224-例题理解"></a> 12.2.4 例题理解</h3><h2 id="123-主成分分析pca"><a class="markdownIt-Anchor" href="#123-主成分分析pca"></a> 12.3 主成分分析PCA</h2><p>Principal Component Analysis<br /><strong>无监督的</strong>特征降维方法</p><h3 id="1231-主成分"><a class="markdownIt-Anchor" href="#1231-主成分"></a> 12.3.1 主成分</h3><ul><li>最大可分性：样本在第一主成分上的投影离散程度要大于第二主成分投影离散程度</li><li>最近可重构性：样本到第一主成分线的平均距离要小于到第二主成分线的距离</li></ul><p>因此，要最大化样本点在主成分投影上的方差</p><h3 id="1232-计算推导"><a class="markdownIt-Anchor" href="#1232-计算推导"></a> 12.3.2 计算推导</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704358974942-848e9a10-e788-4aee-9047-88532d1b825e.png#averageHue=%23f6f6f6&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=377&amp;id=uf68770f7&amp;originHeight=565&amp;originWidth=1093&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=174446&amp;status=done&amp;style=none&amp;taskId=u2df56c04-69e3-49ab-981d-f2e266b3426&amp;title=&amp;width=728.6666666666666" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704359274658-e5afa1c7-8566-4e73-b9a3-dfaf73e6c229.png#averageHue=%23f8f0ef&amp;clientId=u5008a986-3ab3-4&amp;from=paste&amp;height=463&amp;id=u8dd181e7&amp;originHeight=694&amp;originWidth=1104&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=211169&amp;status=done&amp;style=none&amp;taskId=uf651a197-093a-4376-8af2-fe5c07d5e7b&amp;title=&amp;width=736" alt="image.png" /></p><h3 id="1233-算法流程"><a class="markdownIt-Anchor" href="#1233-算法流程"></a> 12.3.3 算法流程</h3><ol><li>样本去中心化（一行一个样本）：减去每列的平均值</li><li>计算协方差矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac><msup><mi>X</mi><mi>T</mi></msup><mi>X</mi></mrow><annotation encoding="application/x-tex">\frac{1}{n} X^T X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span></li><li>对协方差矩阵特征值分解</li><li>取最大特征值对应的特征向量作为投影向量</li><li>计算投影矩阵</li></ol><h3 id="1234-核pca"><a class="markdownIt-Anchor" href="#1234-核pca"></a> 12.3.4 核PCA</h3><p>投射到高维</p><h3 id="1235-pca-vs-lda"><a class="markdownIt-Anchor" href="#1235-pca-vs-lda"></a> 12.3.5 PCA VS LDA</h3><ul><li>PCA无监督，LDA有监督</li><li>PCA投影后数据方差最大，LDA目标组内方差小，组间方差大</li><li>PCA基础是特征的协方差矩阵，投影后更难被分类</li><li>PCA投影后坐标正交，LDA无需正交</li><li>PCA投影后维度数目与源数据相同，LDA投影后数目与类别数目相同</li></ul><h2 id="124-独立成分分析ica"><a class="markdownIt-Anchor" href="#124-独立成分分析ica"></a> 12.4 独立成分分析ICA</h2><h1 id="13-强化学习"><a class="markdownIt-Anchor" href="#13-强化学习"></a> 13 强化学习</h1><h2 id="131-mdp模型"><a class="markdownIt-Anchor" href="#131-mdp模型"></a> 13.1 MDP模型</h2><p>Markov Decision Process</p><h3 id="1311-数学模型"><a class="markdownIt-Anchor" href="#1311-数学模型"></a> 13.1.1 数学模型</h3><ul><li>S：states 状态集合</li><li>A：actions 动作集合</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span>：transition probability 状态转移概率</li><li>R：immediate reward 即时奖赏函数</li><li>episode：从初始状态开始经历一系列状态和动作，直到达到终止状态的一次完整实验或轨迹</li></ul><p>动态规划过程：利用贪心策略，最大化期望奖赏</p><h3 id="1312-返回函数"><a class="markdownIt-Anchor" href="#1312-返回函数"></a> 13.1.2 返回函数</h3><p>将所有即时奖赏线性组合成一个单一值<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704373190554-2a672fc2-2398-4762-8665-24b56426d11c.png#averageHue=%23f7f4f3&amp;clientId=u1cfd4743-4f7a-4&amp;from=paste&amp;height=381&amp;id=u6f1d6e4b&amp;originHeight=571&amp;originWidth=1077&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=142712&amp;status=done&amp;style=none&amp;taskId=ubbba8ca5-6d35-4545-9495-046eb5b02cc&amp;title=&amp;width=718" alt="image.png" /><br />奖赏/状态的分布是策略依赖的</p><h3 id="1313-动态规划"><a class="markdownIt-Anchor" href="#1313-动态规划"></a> 13.1.3 动态规划</h3><h4 id="13131-epsilon贪心策略"><a class="markdownIt-Anchor" href="#13131-epsilon贪心策略"></a> 13.1.3.1 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>贪心策略</h4><p>ϵ的值越小，贪婪行动的概率就越高，而随机行动的概率就越低；反之，ϵ的值越大，随机行动的概率就越高，而贪婪行动的概率就越低。<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704379897280-7797a15c-c5f7-4fb2-8a2b-6b6499e22f67.png#averageHue=%23f3f1f0&amp;clientId=u1cfd4743-4f7a-4&amp;from=paste&amp;height=112&amp;id=uff5abe94&amp;originHeight=168&amp;originWidth=820&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=55172&amp;status=done&amp;style=none&amp;taskId=u8a0e0441-1b36-4177-b50d-3043c4aa55b&amp;title=&amp;width=546.6666666666666" alt="image.png" /></p><h4 id="13132-值函数"><a class="markdownIt-Anchor" href="#13132-值函数"></a> 13.1.3.2 值函数</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704373462400-73e45dae-60c1-4b8b-9a15-a0bf314757c3.png#averageHue=%23f5f1f0&amp;clientId=u1cfd4743-4f7a-4&amp;from=paste&amp;height=403&amp;id=ufcc3f309&amp;originHeight=604&amp;originWidth=1090&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=217305&amp;status=done&amp;style=none&amp;taskId=u34af3d84-1950-4bb9-a6eb-60404d2ff93&amp;title=&amp;width=726.6666666666666" alt="image.png" /></p><h4 id="13133-bellman等式"><a class="markdownIt-Anchor" href="#13133-bellman等式"></a> 13.1.3.3 Bellman等式</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704373578885-3692d436-a19a-4fe0-9285-d9a33f7b2d83.png#averageHue=%23f7f4f4&amp;clientId=u1cfd4743-4f7a-4&amp;from=paste&amp;height=406&amp;id=u3887ecd6&amp;originHeight=609&amp;originWidth=1111&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=159315&amp;status=done&amp;style=none&amp;taskId=u56ff9418-fab7-47d9-8da6-d9e3fd71a74&amp;title=&amp;width=740.6666666666666" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704374561842-31c566c6-59ef-4396-83b7-091b6dafcc12.png#averageHue=%23f9f4f3&amp;clientId=u1cfd4743-4f7a-4&amp;from=paste&amp;height=179&amp;id=u2d5f3896&amp;originHeight=268&amp;originWidth=1081&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=67896&amp;status=done&amp;style=none&amp;taskId=u0cc2c82e-7aad-4b21-9afc-1ecaf604bdf&amp;title=&amp;width=720.6666666666666" alt="image.png" /></p><h3 id="1314-计算最优策略"><a class="markdownIt-Anchor" href="#1314-计算最优策略"></a> 13.1.4 计算最优策略</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704374753386-944fa37a-0c06-4da6-a543-0642311c7496.png#averageHue=%23fbf9f8&amp;clientId=u1cfd4743-4f7a-4&amp;from=paste&amp;height=281&amp;id=u45486dd3&amp;originHeight=421&amp;originWidth=861&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=81149&amp;status=done&amp;style=none&amp;taskId=u3bce2c0c-20dd-44d0-95d6-679e4fa3d90&amp;title=&amp;width=574" alt="image.png" /></p><h2 id="132-强化学习方法"><a class="markdownIt-Anchor" href="#132-强化学习方法"></a> 13.2 强化学习方法</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704374841649-0ab8f8fa-93fb-4837-aa3e-2052e3285a68.png#averageHue=%23f6f5f5&amp;clientId=u1cfd4743-4f7a-4&amp;from=paste&amp;height=430&amp;id=u0191f4bc&amp;originHeight=645&amp;originWidth=1141&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=208372&amp;status=done&amp;style=none&amp;taskId=u1ca3c8bb-d65f-402f-8e81-247e09ea5d5&amp;title=&amp;width=760.6666666666666" alt="image.png" /></p><h3 id="1321-monte-carlo"><a class="markdownIt-Anchor" href="#1321-monte-carlo"></a> 13.2.1 Monte Carlo</h3><h4 id="13211-策略评价"><a class="markdownIt-Anchor" href="#13211-策略评价"></a> 13.2.1.1 策略评价</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704375071608-1f2ee23c-12ef-4491-8b73-1ae0948f7e51.png#averageHue=%23f7f5f4&amp;clientId=u1cfd4743-4f7a-4&amp;from=paste&amp;height=445&amp;id=uf4dec3cd&amp;originHeight=667&amp;originWidth=1042&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=194944&amp;status=done&amp;style=none&amp;taskId=u8f7fa112-480c-4ad1-a03c-6aa94832305&amp;title=&amp;width=694.6666666666666" alt="image.png" /></p><h4 id="13212-最优控制"><a class="markdownIt-Anchor" href="#13212-最优控制"></a> 13.2.1.2 最优控制</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704375098490-6674b6fa-456a-45a0-9539-8ea52efe2a37.png#averageHue=%23f8f5f5&amp;clientId=u1cfd4743-4f7a-4&amp;from=paste&amp;height=443&amp;id=uc143c50e&amp;originHeight=664&amp;originWidth=1063&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=168066&amp;status=done&amp;style=none&amp;taskId=u9d04759f-b720-4056-aba1-a647ff3a53e&amp;title=&amp;width=708.6666666666666" alt="image.png" /><br />控制整个学习过程</p><h4 id="13213-mc方法"><a class="markdownIt-Anchor" href="#13213-mc方法"></a> 13.2.1.3 MC方法</h4><p>蒙特卡罗方法：不通过估计值更新，通过经验更新（区别于时差学习）-- 采样<br />N步回退学习？<br />【TD(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span>)算法】<br /><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704375630882-eaf6191c-684b-4813-964f-47b3bb90fdb7.png#averageHue=%23faf9f9&amp;clientId=u1cfd4743-4f7a-4&amp;from=paste&amp;height=447&amp;id=u244c1cad&amp;originHeight=670&amp;originWidth=886&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=137609&amp;status=done&amp;style=none&amp;taskId=u6f76a254-aad4-41a9-8df7-68281d2a209&amp;title=&amp;width=590.6666666666666" alt="image.png" /></p><h4 id="13214-时差学习方法"><a class="markdownIt-Anchor" href="#13214-时差学习方法"></a> 13.2.1.4 时差学习/方法</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704375325625-f8d6dcf2-24ce-4500-8c1a-b526e6817156.png#averageHue=%23fbfafa&amp;clientId=u1cfd4743-4f7a-4&amp;from=paste&amp;height=387&amp;id=ucf0d47e5&amp;originHeight=580&amp;originWidth=1033&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=148650&amp;status=done&amp;style=none&amp;taskId=u75b09da8-3ac6-4982-b59b-7c5f3c32519&amp;title=&amp;width=688.6666666666666" alt="image.png" /><br />通过一个估计值进行更新（bootstraps）</p><h4 id="13215-sampling和bootstraps的区别"><a class="markdownIt-Anchor" href="#13215-sampling和bootstraps的区别"></a> 13.2.1.5 Sampling和bootstraps的区别</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/png/35670178/1704375781944-0d933077-73bd-4d61-96fd-6fc088b459f2.png#averageHue=%23f9f5f5&amp;clientId=u1cfd4743-4f7a-4&amp;from=paste&amp;height=387&amp;id=u9877099a&amp;originHeight=580&amp;originWidth=927&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=143525&amp;status=done&amp;style=none&amp;taskId=u25bad01f-c666-4d23-ad12-a33a307b06e&amp;title=&amp;width=618" alt="image.png" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;重点整理复习版&lt;/p&gt;
&lt;p&gt;图片无法完全加载，请访问&lt;a href=&quot;https://www.yuque.com/u34135790/laiu5z/ensdbirr9p0xpaac&quot;&gt;语雀文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-基础概念&quot;&gt;&lt;a class=&quot;markd</summary>
      
    
    
    
    <category term="Knowledge" scheme="https://aliceraylu.github.io/categories/Knowledge/"/>
    
    <category term="Machine Learning" scheme="https://aliceraylu.github.io/categories/Knowledge/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>Umich EECS 498-007</title>
    <link href="https://aliceraylu.github.io/2023/10/30/knowledge/machine%20learning/Umich%20EECS%20498-007/"/>
    <id>https://aliceraylu.github.io/2023/10/30/knowledge/machine%20learning/Umich%20EECS%20498-007/</id>
    <published>2023-10-29T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.453Z</updated>
    
    <content type="html"><![CDATA[<p>课程主页：🔗https://web.eecs.umich.edu/~justincj/teaching/eecs498/WI2022/</p><p>在课程主页可以找到2019年的youtube课程录屏以及6项hw/Assignments。通过google colab打开完成作业。</p><p>这篇博客记录一些课堂笔记和作业笔记。可以在<a href="">这个仓库</a>中找到本人的作业实现</p><blockquote><p>正在施工建设中…</p></blockquote><h2 id="lec-2-image-classification"><a class="markdownIt-Anchor" href="#lec-2-image-classification"></a> Lec 2: Image Classification</h2><p>常用数据集：</p><ul><li><strong>CIFAR-10</strong> &amp; <strong>CIFAR-100</strong><br />图像尺寸：32*32<br />CIFAR-10有10类图像，每类6000张。总共分为50000张训练图片和10000张测试图片。<br />CIFAR-100有100类图像，每类600张，包括500张训练图片和100张测试图片。</li><li><strong>ImageNet</strong><br />最著名图像数据集，有1000类图像分类，数据量较大，有miniImageNet</li><li><strong>MNIST</strong><br />手写数字图像集<br />图像尺寸：28*28<br />50000张训练图片，10000张测试图片</li></ul><h2 id="a1-pytorch-knn"><a class="markdownIt-Anchor" href="#a1-pytorch-knn"></a> A1: Pytorch &amp; KNN</h2><h3 id="pytorch-101"><a class="markdownIt-Anchor" href="#pytorch-101"></a> Pytorch 101</h3><h4 id="1-tensor-basic"><a class="markdownIt-Anchor" href="#1-tensor-basic"></a> 1 Tensor Basic</h4><p>创建tensor使用python数组形式</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">a = torch.tensor([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line"><span class="built_in">print</span>(a.dim())</span><br><span class="line"><span class="built_in">print</span>(a.shape)</span><br><span class="line"><span class="built_in">print</span>(a.size())</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>输出结果</p><blockquote><p>2<br />torch.Size([2,3])<br />torch.Size([2,3])<br />4</p></blockquote><p><code>shape</code>是属性，<code>size()</code>是方法，返回的结果相同，可以使用<code>shape[1]</code>获取具体某一个维度大小</p><h4 id="2-tensor-index"><a class="markdownIt-Anchor" href="#2-tensor-index"></a> 2 Tensor Index</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;课程主页：🔗https://web.eecs.umich.edu/~justincj/teaching/eecs498/WI2022/&lt;/p&gt;
&lt;p&gt;在课程主页可以找到2019年的youtube课程录屏以及6项hw/Assignments。通过google colab打开</summary>
      
    
    
    
    <category term="Knowledge" scheme="https://aliceraylu.github.io/categories/Knowledge/"/>
    
    <category term="Machine Learning" scheme="https://aliceraylu.github.io/categories/Knowledge/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>IOS RD client连接到win10</title>
    <link href="https://aliceraylu.github.io/2023/10/08/technology/device%20usage/RD%20Client%E8%B8%A9%E5%9D%91%E5%AE%9E%E5%BD%95/"/>
    <id>https://aliceraylu.github.io/2023/10/08/technology/device%20usage/RD%20Client%E8%B8%A9%E5%9D%91%E5%AE%9E%E5%BD%95/</id>
    <published>2023-10-07T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.492Z</updated>
    
    <content type="html"><![CDATA[<p>如果使用的win家庭版还是建议升级到专业版（某宝几块钱搞定）</p><p>个人使用由于都是在校园网环境下因此没有做内网穿透。</p><h2 id="q1远程网关不可用错误代码0x300005e"><a class="markdownIt-Anchor" href="#q1远程网关不可用错误代码0x300005e"></a> Q1：远程网关不可用，错误代码0x300005e</h2><p>至今未解决，只要是在同一个网关下似乎无法互联。举个栗子，在宿舍时，由于平板和电脑的网关一致（同一个路由器）没有办法联通。（抽象的是在图书馆竟然可以联通，也不知道是不是宿舍路由器问题）</p><p>使用网关：远程网关不可用；不使用网关：0x204无法连接</p><h2 id="q2无法连接错误代码0x204"><a class="markdownIt-Anchor" href="#q2无法连接错误代码0x204"></a> Q2：无法连接，错误代码0x204</h2><p>检查是否配置网关，同一局域网内不同网关下需要配置远程网关。即使用<code>ipconfig</code>查看win的网关。</p><p>注意查看电脑设置中远程桌面和对应的服务是否开启。</p><h2 id="q3微软账户密码无法登录"><a class="markdownIt-Anchor" href="#q3微软账户密码无法登录"></a> Q3：微软账户密码无法登录</h2><p>需要先关闭windows hello，使用微软账号解锁一次自己的电脑，随后可以正常登入。</p><h2 id="q4远程桌面连接电脑使用vscode在markdown环境下无法输入中文"><a class="markdownIt-Anchor" href="#q4远程桌面连接电脑使用vscode在markdown环境下无法输入中文"></a> Q4：远程桌面连接电脑使用vscode，在markdown环境下无法输入中文</h2><p>很有可能是插件的原因，可以测试一下vscode左边栏中输入中文搜索是否好用。本人的vscode由于安装了<br /><code>markdown all in one</code>这款插件导致在markdwon区域无法有效输入中文，其他代码部分输入中文是可行的。</p><p>通过禁用插件或直接卸载插件可以解决上述问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果使用的win家庭版还是建议升级到专业版（某宝几块钱搞定）&lt;/p&gt;
&lt;p&gt;个人使用由于都是在校园网环境下因此没有做内网穿透。&lt;/p&gt;
&lt;h2 id=&quot;q1远程网关不可用错误代码0x300005e&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#q</summary>
      
    
    
    
    <category term="Technology" scheme="https://aliceraylu.github.io/categories/Technology/"/>
    
    <category term="Device Usage" scheme="https://aliceraylu.github.io/categories/Technology/Device-Usage/"/>
    
    
  </entry>
  
  <entry>
    <title>Latex-Beamer快速入门</title>
    <link href="https://aliceraylu.github.io/2023/09/08/technology/latex/Latex-Beamer/"/>
    <id>https://aliceraylu.github.io/2023/09/08/technology/latex/Latex-Beamer/</id>
    <published>2023-09-07T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.501Z</updated>
    
    <content type="html"><![CDATA[<p>官方教程: <a href="http://tug.ctan.org/macros/latex/contrib/beamer/doc/beameruserguide.pdf">The beamer class User Guide for version 3.70.</a> （最新版）</p><p>安装好Texlive后可以在命令行中使用<code>texdoc beamer</code>打开安装版本的官方文档。</p><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/266399513">知乎-如何使用beamer制作学术会议、学术演讲的幻灯片slides?</a><br /><a href="https://zhuanlan.zhihu.com/p/584431029">知乎-Beamer教程</a></p><h1 id="0-prerequisite"><a class="markdownIt-Anchor" href="#0-prerequisite"></a> 0 Prerequisite</h1><p>需要首先在本机配置好Latex环境，beamer支持pdflatex, latex+dvips, lualatex, xelatex.</p><h1 id="1-configurations"><a class="markdownIt-Anchor" href="#1-configurations"></a> 1 Configurations</h1><h2 id="11-document-class"><a class="markdownIt-Anchor" href="#11-document-class"></a> 1.1 document class</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;ctexbeamer&#125; <span class="comment">% 中文使用ctexbeamer</span></span><br><span class="line"><span class="keyword">\documentclass</span>&#123;beamer&#125;     <span class="comment">% 纯英文使用beamer</span></span><br></pre></td></tr></table></figure><h2 id="12-theme"><a class="markdownIt-Anchor" href="#12-theme"></a> 1.2 theme</h2><p>使用usetheme来应用主题，同时可以通过template自定义配置</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usetheme</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\setbeamertemplate</span>&#123;footline&#125;[FootlineTemplateII] <span class="comment">% 底部增加一行</span></span><br></pre></td></tr></table></figure><p>主题查看页面：<a href="https://hartwork.org/beamer-theme-matrix/">theme-matrix</a></p><p>STFI for more themes!</p><h2 id="13-infos"><a class="markdownIt-Anchor" href="#13-infos"></a> 1.3 infos</h2><p>和article中一样，beamer中幻灯片的标题、作者、日期等信息都可以在导言区以相同方式书写</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\title</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br><span class="line"><span class="keyword">\logo</span>&#123;<span class="keyword">\includegraphics</span>[height=1.5cm]&#123;logo.jpg&#125;&#125; <span class="comment">% 默认logo加在右下角</span></span><br></pre></td></tr></table></figure><h2 id="14-catalogue"><a class="markdownIt-Anchor" href="#14-catalogue"></a> 1.4 catalogue</h2><h3 id="141-整体目录"><a class="markdownIt-Anchor" href="#141-整体目录"></a> 1.4.1 整体目录</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;frame&#125;&#123;catalogue&#125;</span><br><span class="line"><span class="keyword">\tableofcontents</span>     <span class="comment">% 生成目录</span></span><br><span class="line"><span class="keyword">\end</span>&#123;frame&#125;</span><br></pre></td></tr></table></figure><h3 id="142-小节前导目录"><a class="markdownIt-Anchor" href="#142-小节前导目录"></a> 1.4.2 小节前导目录</h3><p>在导言区加上以下代码可以生成每一小节前的前导目录</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\AtBeginSection</span>[]</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">\begin</span>&#123;frame&#125;</span><br><span class="line">    <span class="keyword">\frametitle</span>&#123;Table of Contents&#125;</span><br><span class="line">    <span class="keyword">\tableofcontents</span>[currentsection]</span><br><span class="line">  <span class="keyword">\end</span>&#123;frame&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-font"><a class="markdownIt-Anchor" href="#15-font"></a> 1.5 font</h2><h3 id="151-全局"><a class="markdownIt-Anchor" href="#151-全局"></a> 1.5.1 全局</h3><ul><li><strong>大小</strong>：可以在<code>\documentclass[10pt]&#123;beamer&#125;</code>的方括号中修改字体大小</li><li><strong>字体</strong>：<ol><li>使用字体主题<code>\usefonttheme&#123;...&#125;</code>, 可用字体包括：structurebold, structurebolditalic, structuresmallcapsserif, structureitalicsserif, serif 以及 default</li><li>通过引入相应的包来设置：mathptmx, helvet, avat, bookman, chancery, charter, culer, mathtime, mathptm, newcent, palatino, pifont and utopia</li></ol></li></ul><h3 id="152-局部"><a class="markdownIt-Anchor" href="#152-局部"></a> 1.5.2 局部</h3><p>设置局部字体格式可以在导言区使用<code>\setbeamerfont&#123;structure&#125;&#123;size=&#123;\fontsize&#123;6pt&#125;&#123;0pt&#125;&#125;&#125;</code></p><h2 id="16-color"><a class="markdownIt-Anchor" href="#16-color"></a> 1.6 color</h2><p>color和主题强相关，对于某一项主题，可以使用<code>\usecolortheme&#123;...&#125;</code>来配置。</p><p>可以引入xcolor包使得颜色更丰富。</p><h1 id="2-contents"><a class="markdownIt-Anchor" href="#2-contents"></a> 2 Contents</h1><p>在导言区配置完后，所有的内容都包括在：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="21-sections"><a class="markdownIt-Anchor" href="#21-sections"></a> 2.1 Sections</h2><p>beamer和article一样，使用section来划分章节。beamer可以根据section自动生成目录页插入。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\section</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\subsection</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\section</span>*&#123;&#125; <span class="comment">% 无编号章节</span></span><br></pre></td></tr></table></figure><p>一个section中可以包含多个subsection，每个section/subsection可以包含多个幻灯片页面。</p><h2 id="22-frames"><a class="markdownIt-Anchor" href="#22-frames"></a> 2.2 Frames</h2><p>beamer中，frame包含了页面部分</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;frame&#125;</span><br><span class="line">    <span class="keyword">\titlepage</span>  <span class="comment">% 显示标题页面</span></span><br><span class="line">    <span class="keyword">\tableofcontents</span> <span class="comment">% 显示目录页面</span></span><br><span class="line"><span class="keyword">\end</span>&#123;frame&#125;</span><br></pre></td></tr></table></figure><h2 id="23-alert"><a class="markdownIt-Anchor" href="#23-alert"></a> 2.3 Alert</h2><p>使用<code>\alert&#123;...&#125;</code>来强调文字，文字会自动标红</p><h2 id="24-block"><a class="markdownIt-Anchor" href="#24-block"></a> 2.4 Block</h2><p>在页面上以块的方式展示</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;block&#125;&#123;Remark&#125; <span class="comment">% block title</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">\end</span>&#123;block&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;alertblock&#125;&#123;Important theorem&#125;</span><br><span class="line">Sample text in red box <span class="comment">% block content</span></span><br><span class="line"><span class="keyword">\end</span>&#123;alertblock&#125;</span><br></pre></td></tr></table></figure><h2 id="25-graphs"><a class="markdownIt-Anchor" href="#25-graphs"></a> 2.5 Graphs</h2><p>插入图片需要graphix宏包</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[ht]</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=0.8<span class="keyword">\textwidth</span>]&#123;dataset.png&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;A picture downloaded from the Internet.png&#125; <span class="comment">% 图片下方文字说明</span></span><br><span class="line">    <span class="keyword">\label</span>&#123;dataset&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><h2 id="26-multiple-columns"><a class="markdownIt-Anchor" href="#26-multiple-columns"></a> 2.6 Multiple Columns</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;columns&#125;</span><br><span class="line">    <span class="keyword">\column</span>&#123;0.5<span class="keyword">\textwidth</span>&#125;</span><br><span class="line">    This is a text in first column.</span><br><span class="line">    <span class="built_in">$</span><span class="built_in">$</span>E=mc<span class="built_in">^</span>2<span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">\column</span>&#123;0.5<span class="keyword">\textwidth</span>&#125;</span><br><span class="line">    This text will be in the second column</span><br><span class="line">    and on a second tought this is a nice looking</span><br><span class="line">    layout in some cases.</span><br><span class="line"><span class="keyword">\end</span>&#123;columns&#125;</span><br></pre></td></tr></table></figure><p>使用columns来呈现分栏效果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;官方教程: &lt;a href=&quot;http://tug.ctan.org/macros/latex/contrib/beamer/doc/beameruserguide.pdf&quot;&gt;The beamer class User Guide for version 3.70.&lt;/a&gt;</summary>
      
    
    
    
    <category term="Technology" scheme="https://aliceraylu.github.io/categories/Technology/"/>
    
    <category term="LaTex" scheme="https://aliceraylu.github.io/categories/Technology/LaTex/"/>
    
    
  </entry>
  
  <entry>
    <title>The Beginning of the Story</title>
    <link href="https://aliceraylu.github.io/2023/08/24/stories/The-Beginning-of-the-Story/"/>
    <id>https://aliceraylu.github.io/2023/08/24/stories/The-Beginning-of-the-Story/</id>
    <published>2023-08-23T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.489Z</updated>
    
    <content type="html"><![CDATA[<p>Once upon a time, there was a girl, who, after trying jekyll and hexo, after choosing so many themes, and failing at making her favourites work, finally got tired and decided that this is the begin of this site.</p><h2 id="to-learn-more-about-me"><a class="markdownIt-Anchor" href="#to-learn-more-about-me"></a> To learn more about ME!</h2><p>Click at <em>about</em> to see my profile.</p><h2 id="looking-for-notes"><a class="markdownIt-Anchor" href="#looking-for-notes"></a> Looking for Notes?</h2><p>Click at <em>categories</em> to get what you want.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Once upon a time, there was a girl, who, after trying jekyll and hexo, after choosing so many themes, and failing at making her favourite</summary>
      
    
    
    
    <category term="Stories" scheme="https://aliceraylu.github.io/categories/Stories/"/>
    
    
  </entry>
  
  <entry>
    <title>Github Personal Blog Quick Setup</title>
    <link href="https://aliceraylu.github.io/2023/08/24/technology/blog/Github-Personal-Blog-Quick-Setup/"/>
    <id>https://aliceraylu.github.io/2023/08/24/technology/blog/Github-Personal-Blog-Quick-Setup/</id>
    <published>2023-08-23T16:00:00.000Z</published>
    <updated>2025-07-15T06:38:03.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-prerequisite"><a class="markdownIt-Anchor" href="#0-prerequisite"></a> 0 Prerequisite</h2><ul><li>Markdown writing skills</li><li>A computer💻 and access to the internet🌏</li><li>Enough time: ⏰about 60 mins(exclude the time choosing themes)</li></ul><h1 id="github-pages-jekyll"><a class="markdownIt-Anchor" href="#github-pages-jekyll"></a> Github Pages + Jekyll</h1><h2 id="1-creating-github-repository"><a class="markdownIt-Anchor" href="#1-creating-github-repository"></a> 1 Creating Github Repository</h2><ol><li>The repository’s name must be <code>your-username.github.io</code> (remember to add a <code>README.md</code> or initialize the repo: set main branch)</li><li>In repository’s settings: change <em>Github Pages -&gt; source -&gt; main</em></li></ol><h2 id="2-choosing-your-favourite-jekyll-theme"><a class="markdownIt-Anchor" href="#2-choosing-your-favourite-jekyll-theme"></a> 2 Choosing Your Favourite Jekyll Theme</h2><p>Visit 🔗http://jekyllthemes.org/ to look through</p><h2 id="3-install-jekyll-and-ruby"><a class="markdownIt-Anchor" href="#3-install-jekyll-and-ruby"></a> 3 Install Jekyll and Ruby</h2><h3 id="31-install-ruby-rubygems"><a class="markdownIt-Anchor" href="#31-install-ruby-rubygems"></a> 3.1 Install Ruby &amp; RubyGems</h3><ol><li>Visit 🔗https://rubyinstaller.org/downloads/ to download installer</li><li>Double click the installer to start installation.</li></ol><blockquote><p>The install location can not have space!!!<br />Keep all the options ticked: like add to path, install msys2…<br />After the install finishes, a cmd window will pop up, just press <em>enter</em> or <em>3</em> to continue installing msys2.( This could take some time.) If the installation fails, run <code>ridk install</code> to reinstall.</p></blockquote><ol start="3"><li>Download from 🔗https://rubygems.org/pages/download to install RubyGems</li><li>Unzip the downloaded file in step3, enter the folder using <code>cd &lt;folderpath&gt;</code> in cmd</li></ol><h3 id="32-install-jekyll-github-pages"><a class="markdownIt-Anchor" href="#32-install-jekyll-github-pages"></a> 3.2 Install jekyll &amp; Github Pages</h3><ol><li>Run <code>gem install bundle</code></li><li>Run <code>gem install jekyll</code></li><li>Run <code>gem install jekyll-paginate</code></li><li>Run <code>jekyll -v</code> to verify installation: should display something like version</li><li>Run <code>gem install github-pages</code> to install github pages</li></ol><h3 id="33-add-environment-variables-start-jekyll-project-locally"><a class="markdownIt-Anchor" href="#33-add-environment-variables-start-jekyll-project-locally"></a> 3.3 Add Environment Variables &amp; Start Jekyll Project Locally</h3><ol><li>Open your computer’s envrionment path and add your ruby path with \bin, save and exit.</li><li>Run <code>bundle exec jekyll serve</code> to start locally</li></ol><h2 id="4-import-template"><a class="markdownIt-Anchor" href="#4-import-template"></a> 4 Import Template</h2><ol><li>Copy every file in the template into your own repository</li><li>Run <code>bundle install</code></li><li>Run <code>bundle exec jekyll serve</code> to start locally</li></ol><h1 id="github-pages-hexo"><a class="markdownIt-Anchor" href="#github-pages-hexo"></a> Github Pages + Hexo</h1><h2 id="1-creating-github-repository-2"><a class="markdownIt-Anchor" href="#1-creating-github-repository-2"></a> 1 Creating Github Repository</h2><p>Same as above</p><h2 id="2-install-nodejs-git"><a class="markdownIt-Anchor" href="#2-install-nodejs-git"></a> 2 Install Node.js &amp; Git</h2><p>Recommand install nvm to change node version flexibally.<br />About how to install nvm please search the friendly Internet.</p><h2 id="3-install-hexo-initialize"><a class="markdownIt-Anchor" href="#3-install-hexo-initialize"></a> 3 Install hexo &amp; Initialize</h2><ol><li>Run the command <code>npm install -g hexo-cli</code> to install hexo</li><li>Run <code>hexo init</code> in an empty folder to set up the files</li></ol><h2 id="4-how-to-release"><a class="markdownIt-Anchor" href="#4-how-to-release"></a> 4 How to release</h2><p>Choose your theme.</p><ul><li>Run <code>hexo generate</code> to generate file</li><li>Run <code>hexo server</code> to preview locally</li><li>Run <code>hexo depoly</code> to release to github<br />Before deploy, remember to set _config.yml file</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/your-username/your-username.github.io</span> </span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0-prerequisite&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0-prerequisite&quot;&gt;&lt;/a&gt; 0 Prerequisite&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Markdown writing skills&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="Technology" scheme="https://aliceraylu.github.io/categories/Technology/"/>
    
    <category term="Blog" scheme="https://aliceraylu.github.io/categories/Technology/Blog/"/>
    
    
  </entry>
  
</feed>
