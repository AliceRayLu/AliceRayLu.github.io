<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Stanford CS106L(2019)"><meta name="keywords" content=""><meta name="author" content="A.R.L"><meta name="copyright" content="A.R.L"><title>Stanford CS106L(2019) | A.R.L's Blog</title><link rel="shortcut icon" href="/bitbug_favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-283151977-1', 'auto');
ga('send', 'pageview');</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-MJTECTPJVQ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-MJTECTPJVQ');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="A.R.L's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#stdpair"><span class="toc-number">1.</span> <span class="toc-text"> std::pair</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto"><span class="toc-number">2.</span> <span class="toc-text"> auto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-1-2"><span class="toc-number">3.</span> <span class="toc-text"> Lecture 1-2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stringstream"><span class="toc-number">3.1.</span> <span class="toc-text"> stringstream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getline"><span class="toc-number">3.2.</span> <span class="toc-text"> getline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stdws"><span class="toc-number">3.3.</span> <span class="toc-text"> std::ws</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-3"><span class="toc-number">4.</span> <span class="toc-text"> Lecture 3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stlstandard-template-library"><span class="toc-number">4.1.</span> <span class="toc-text"> STL(Standard Template Library)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stdvectortype"><span class="toc-number">4.2.</span> <span class="toc-text"> std::vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stddequetype"><span class="toc-number">4.3.</span> <span class="toc-text"> std::deque</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#careful-initialization"><span class="toc-number">4.4.</span> <span class="toc-text"> careful initialization</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-4-5"><span class="toc-number">5.</span> <span class="toc-text"> Lecture 4-5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iterator"><span class="toc-number">5.1.</span> <span class="toc-text"> iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#functions-using-iterator"><span class="toc-number">5.2.</span> <span class="toc-text"> functions using iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iterator-types"><span class="toc-number">5.3.</span> <span class="toc-text"> iterator types</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#assignment-12022"><span class="toc-number">6.</span> <span class="toc-text"> Assignment 1（2022）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setup"><span class="toc-number">6.1.</span> <span class="toc-text"> setup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stdifstream"><span class="toc-number">6.2.</span> <span class="toc-text"> std::ifstream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-6"><span class="toc-number">7.</span> <span class="toc-text"> Lecture 6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#templates"><span class="toc-number">7.1.</span> <span class="toc-text"> Templates</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#templates-with-iterators"><span class="toc-number">7.2.</span> <span class="toc-text"> Templates with iterators</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#assignment-1-2019"><span class="toc-number">8.</span> <span class="toc-text"> Assignment 1 (2019)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-7"><span class="toc-number">9.</span> <span class="toc-text"> Lecture 7</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#explicit-interface-named-requirements-on-template-types"><span class="toc-number">9.1.</span> <span class="toc-text"> explicit interface: named requirements on template types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#predicate"><span class="toc-number">9.2.</span> <span class="toc-text"> predicate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda-functions"><span class="toc-number">9.3.</span> <span class="toc-text"> lambda functions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-8-9"><span class="toc-number">10.</span> <span class="toc-text"> Lecture 8-9</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stdminmax_element"><span class="toc-number">10.1.</span> <span class="toc-text"> std::minmax_element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stdaccumulate"><span class="toc-number">10.2.</span> <span class="toc-text"> std::accumulate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stdnth_element"><span class="toc-number">10.3.</span> <span class="toc-text"> std::nth_element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stdany_of"><span class="toc-number">10.4.</span> <span class="toc-text"> std::any_of</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stream-adaptor"><span class="toc-number">10.5.</span> <span class="toc-text"> stream adaptor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-10"><span class="toc-number">11.</span> <span class="toc-text"> Lecture 10</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stdsearch"><span class="toc-number">11.1.</span> <span class="toc-text"> std::search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dotproduct"><span class="toc-number">11.2.</span> <span class="toc-text"> dotproduct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">11.3.</span> <span class="toc-text"> const</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-11"><span class="toc-number">12.</span> <span class="toc-text"> Lecture 11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#operator-defination"><span class="toc-number">12.1.</span> <span class="toc-text"> operator defination</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#operator-function"><span class="toc-number">12.2.</span> <span class="toc-text"> operator function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-12"><span class="toc-number">13.</span> <span class="toc-text"> Lecture 12</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%A8"><span class="toc-number">13.1.</span> <span class="toc-text"> 初始化表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy-constructor"><span class="toc-number">13.2.</span> <span class="toc-text"> copy constructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy-assignment"><span class="toc-number">13.3.</span> <span class="toc-text"> copy assignment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-13"><span class="toc-number">14.</span> <span class="toc-text"> Lecture 13</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#emplace_back"><span class="toc-number">14.1.</span> <span class="toc-text"> emplace_back</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lvalue-rvalue"><span class="toc-number">14.2.</span> <span class="toc-text"> lvalue &amp; rvalue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#move"><span class="toc-number">14.3.</span> <span class="toc-text"> move</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-14"><span class="toc-number">15.</span> <span class="toc-text"> Lecture 14</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#scope-resolution"><span class="toc-number">15.1.</span> <span class="toc-text"> scope resolution</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#namespace"><span class="toc-number">15.2.</span> <span class="toc-text"> namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interface"><span class="toc-number">15.3.</span> <span class="toc-text"> interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#abstract-class"><span class="toc-number">15.4.</span> <span class="toc-text"> abstract class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inheritance"><span class="toc-number">15.5.</span> <span class="toc-text"> inheritance</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-15"><span class="toc-number">16.</span> <span class="toc-text"> Lecture 15</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#constructor"><span class="toc-number">16.1.</span> <span class="toc-text"> constructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#destructor"><span class="toc-number">16.2.</span> <span class="toc-text"> destructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#protected"><span class="toc-number">16.3.</span> <span class="toc-text"> protected</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inheritance%E5%AE%9E%E4%BE%8B"><span class="toc-number">16.4.</span> <span class="toc-text"> inheritance实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#templates-2"><span class="toc-number">16.5.</span> <span class="toc-text"> templates</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-16"><span class="toc-number">17.</span> <span class="toc-text"> Lecture 16</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#smart-pointers"><span class="toc-number">17.1.</span> <span class="toc-text"> smart pointers</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">A.R.L</div><div class="author-info__description text-center">Nothing holds still.</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">27</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">16</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/pics/back1.jpg?raw=true)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">A.R.L's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Stanford CS106L(2019)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-10-24</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Knowledge/">Knowledge</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Knowledge/C/">C++</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>建议先学完cs106B/或者相对应的c++基础再来上手这门课程，光有c的基础看起来有点吃力</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yJ411m7CE?p=1&amp;vd_source=63731e51187044a6065a97ae72adb12e">CS 106L Fall 2019 - Lecture 0 - Introduction (Screencast)_哔哩哔哩_bilibili</a></p>
<p>这是当时能找到的最新版本，其他版本暂时没有公开视频，2019年的作业也没有过期，可以也拿出来做一做，2022的作业还要配环境烦死了</p>
<p><a target="_blank" rel="noopener" href="http://web.stanford.edu/class/cs106l/">CS 106L: Standard C++ Programming (stanford.edu)</a></p>
<p>课程网站（2022spring）</p>
<h2 id="stdpair"><a class="markdownIt-Anchor" href="#stdpair"></a> std::pair</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;<span class="type">int</span>, string&gt; numSuffix = &#123;<span class="number">1</span>,<span class="string">&quot;st&quot;</span>&#125;;</span><br><span class="line">cout &lt;&lt; numSuffix.first &lt;&lt; numSuffix.second;</span><br><span class="line"><span class="comment">//prints 1st</span></span><br></pre></td></tr></table></figure>
<h2 id="auto"><a class="markdownIt-Anchor" href="#auto"></a> auto</h2>
<p>ask the compiler to deduce the type</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">4.3</span>;</span><br><span class="line"><span class="keyword">auto</span> c = ‘X’;</span><br><span class="line"><span class="keyword">auto</span> d = “Hello”;</span><br><span class="line"><span class="keyword">auto</span> e = std::<span class="built_in">make_pair</span>(<span class="number">3</span>, “Hello”)</span><br><span class="line"><span class="comment">// int, double, char, char* (a C string), std::pair&lt;int, char*&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="lecture-1-2"><a class="markdownIt-Anchor" href="#lecture-1-2"></a> Lecture 1-2</h2>
<h3 id="stringstream"><a class="markdownIt-Anchor" href="#stringstream"></a> stringstream</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostringstream <span class="title">oss</span><span class="params">(<span class="string">&quot;hello&quot;</span>,stringstream::ate)</span></span>;</span><br><span class="line"><span class="comment">//establish an output stream, the pointer ends at the end.</span></span><br><span class="line"><span class="function">ostringstream <span class="title">oss1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;<span class="comment">//the pointer points at the start</span></span><br><span class="line">std::cout &lt;&lt; oss.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">oss &lt;&lt; <span class="number">16</span> &lt;&lt; <span class="string">&quot; hi&quot;</span> ;<span class="comment">//start input string or others at the pointer</span></span><br><span class="line"></span><br><span class="line">fpos p = oss.<span class="built_in">tellp</span>() + <span class="built_in">streamoff</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//the number can be negative: streamoff(-3) move in another direction</span></span><br><span class="line"><span class="comment">//take the current pointer 3 spaces off </span></span><br><span class="line">oss.<span class="built_in">seekp</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="function">istringstream <span class="title">iss</span><span class="params">(oss.str())</span></span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">string s;</span><br><span class="line">iss &gt;&gt; i &gt;&gt; s;<span class="comment">//in iss divide by space</span></span><br><span class="line">iss.<span class="built_in">tellg</span>();<span class="comment">//tell the position</span></span><br><span class="line">iss.<span class="built_in">seekg</span>(<span class="number">2</span>);<span class="comment">//set the position</span></span><br></pre></td></tr></table></figure>
<p><strong>usage: use stringstream to seperate a line(or to say split)</strong></p>
<h3 id="getline"><a class="markdownIt-Anchor" href="#getline"></a> getline</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string name;</span><br><span class="line"><span class="built_in">getline</span>(cin,name,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cin.<span class="built_in">ignore</span>();</span><br></pre></td></tr></table></figure>
<h3 id="stdws"><a class="markdownIt-Anchor" href="#stdws"></a> std::ws</h3>
<p><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/assets/image-20221024215329-otyq0b8.png?raw=true" alt="" /></p>
<p>忽略下一个换行</p>
<h2 id="lecture-3"><a class="markdownIt-Anchor" href="#lecture-3"></a> Lecture 3</h2>
<h3 id="stlstandard-template-library"><a class="markdownIt-Anchor" href="#stlstandard-template-library"></a> STL(Standard Template Library)</h3>
<h3 id="stdvectortype"><a class="markdownIt-Anchor" href="#stdvectortype"></a> std::vector<type></h3>
<p><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/assets/image-20220906214443-tv83pni.png?raw=true" alt="" /></p>
<p><code>v[i]</code> notation will not check the boundary!!!</p>
<p><code>v.at()</code> will check and call the error</p>
<h3 id="stddequetype"><a class="markdownIt-Anchor" href="#stddequetype"></a> std::deque<type></h3>
<p>a double ended queue(see cs61b-lab1 for review)</p>
<h3 id="careful-initialization"><a class="markdownIt-Anchor" href="#careful-initialization"></a> careful initialization</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec1</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>; </span><br><span class="line"><span class="comment">// makes &#123;5, 5, 5&#125;, not &#123;3, 5&#125;!</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec2&#123;<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// makes &#123;3, 5&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="lecture-4-5"><a class="markdownIt-Anchor" href="#lecture-4-5"></a> Lecture 4-5</h2>
<h3 id="iterator"><a class="markdownIt-Anchor" href="#iterator"></a> iterator</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; container;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt;::iterator iter = container.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(iter != container.<span class="built_in">end</span>())&#123;</span><br><span class="line">    *iter += <span class="number">1</span>;<span class="comment">//must visit elements with * </span></span><br><span class="line">    ++iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>note</strong>: why use prefix <code>++</code>: <code>++iter</code> returns the value after being incremented! <code>iter++</code> returns the previous value and then increments it. (wastes just a bit of time)</p>
<h3 id="functions-using-iterator"><a class="markdownIt-Anchor" href="#functions-using-iterator"></a> functions using iterator</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//then v will be &#123;1,3,4,5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="number">5</span>);</span><br><span class="line"><span class="comment">//auto should be type iterator, find will return a pointer pointing at the //position of 5</span></span><br><span class="line"><span class="keyword">if</span>(iter == v.<span class="built_in">end</span>()) cout &lt;&lt; <span class="string">&quot;not found&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p1 = v.<span class="built_in">lower_bound</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//return an iterator pointing at 5(the smallest element that is bigger than 4</span></span><br><span class="line"><span class="keyword">auto</span> p2 = v.<span class="built_in">upper_bound</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//return an iterator pointing at 4(the smallest element that is </span></span><br><span class="line"><span class="comment">//equal or bigger</span></span><br></pre></td></tr></table></figure>
<h3 id="iterator-types"><a class="markdownIt-Anchor" href="#iterator-types"></a> iterator types</h3>
<p><strong>common</strong>:</p>
<ul>
<li>can be created by existing iterators(copyable) <mark>[warning: not all types are copyable!!! streams can’t be copied like cout…]</mark> pass by reference</li>
<li>can be advanced using <code>++</code></li>
<li>can be compared using <code>==</code> and <code>!=</code></li>
</ul>
<p><strong>different types</strong>:</p>
<ol>
<li><strong>input</strong>: single-pass, read only(can only be dereferenced on right side of expression) e.g.<code>find</code> and <code>count</code>, <code>inputstream</code></li>
<li><strong>output</strong>: single-pass, write only(dereferenced only on the left side of enpression) e.g. <code>copy</code>, <code>output streams</code></li>
<li><strong>forward</strong>: multi-pass, can do both read and write(if not <code>const</code> iterator) e.g.<code>replace</code>,<code>forward_list</code></li>
<li><strong>bidirectional</strong>: same as forward, and this one can use <code>--</code> to move backwards e.g.<code>reverse</code>, <code>std::set</code>,<code>std::map</code>,<code>std::list</code></li>
<li><strong>random access</strong>: same as bidirectional, but also can be incremented or decremented by arbitary amount of steps like <code>iter = iter +3</code> e.g.<code>std::vector</code>,<code>std::deque</code>,<code>std::string</code></li>
</ol>
<h2 id="assignment-12022"><a class="markdownIt-Anchor" href="#assignment-12022"></a> Assignment 1（2022）</h2>
<h3 id="setup"><a class="markdownIt-Anchor" href="#setup"></a> setup</h3>
<p>依据assignment 0 配置过后运行<code>./setup.sh</code>会有很多报错，要先给Ubuntu安装cmake，然后git clone下载cpr库，按照网上教程安装，再次运行setup命令</p>
<p>还是报错，配环境真的老大难。然后有个<code>undefined reference to cpr::Session::session()</code>,github上有一个老哥直接硬链接加文件，这样总算可以运行了，走一步看一步吧。。。结果报了bad_alloc错，找半天也不知道怎么解决</p>
<h3 id="stdifstream"><a class="markdownIt-Anchor" href="#stdifstream"></a> std::ifstream</h3>
<h2 id="lecture-6"><a class="markdownIt-Anchor" href="#lecture-6"></a> Lecture 6</h2>
<h3 id="templates"><a class="markdownIt-Anchor" href="#templates"></a> Templates</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U...&gt;<span class="comment">//can be multi-type</span></span><br><span class="line"><span class="function">std::pair&lt;T,T&gt; <span class="title">myFunc</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> [min,max] = <span class="built_in">myFunc</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">5</span>);<span class="comment">//explicit instantiation</span></span><br><span class="line"><span class="keyword">auto</span> [min1,max1] = <span class="built_in">myFunc</span>(<span class="number">3.2</span>,<span class="number">24.4</span>);<span class="comment">//this is also valid</span></span><br></pre></td></tr></table></figure>
<p>if pass in different types:</p>
<ul>
<li>
<p>use different typename</p>
</li>
<li>
<p>use explicit instantiation(which will convert it automatically)</p>
</li>
<li>
<p>convert it manually in parameters</p>
</li>
</ul>
<h3 id="templates-with-iterators"><a class="markdownIt-Anchor" href="#templates-with-iterators"></a> Templates with iterators</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Collection,<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countVal</span><span class="params">(<span class="type">const</span> Collection&lt;T&gt;&amp; list,T val)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = list.<span class="built_in">begin</span>();iter != list.<span class="built_in">end</span>();++iter)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*iter == val)count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>if we want special range in collection</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countVal</span><span class="params">(InputIterator begin,InputIterator end,T val)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = begin;iter != end;++iter)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*iter == val)++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="assignment-1-2019"><a class="markdownIt-Anchor" href="#assignment-1-2019"></a> Assignment 1 (2019)</h2>
<h2 id="lecture-7"><a class="markdownIt-Anchor" href="#lecture-7"></a> Lecture 7</h2>
<h3 id="explicit-interface-named-requirements-on-template-types"><a class="markdownIt-Anchor" href="#explicit-interface-named-requirements-on-template-types"></a> explicit interface: named requirements on template types</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It,<span class="keyword">typename</span> Type&gt;</span><br><span class="line">    <span class="keyword">requires</span> Input_Iterator&lt;It&gt; &amp;&amp; Iterator_of&lt;It&gt; &amp;&amp; </span><br><span class="line">        Equality_comparable&lt;Value_type&lt;It&gt;,Type&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_occurences</span><span class="params">(It begin,It end,Type val)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = begin;it != end;++it)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*it == val)count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="predicate"><a class="markdownIt-Anchor" href="#predicate"></a> predicate</h3>
<p>defination: takes in some parameters and returns a boolean value</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It,<span class="keyword">typename</span> UniaryPredicate&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_occurences</span><span class="params">(It begin,It end,UniaryPredicate predicate)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = begin;it != end;++it)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">predicate</span>(*it))count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lambda-functions"><a class="markdownIt-Anchor" href="#lambda-functions"></a> lambda functions</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> limit = <span class="number">3</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; grades;</span><br><span class="line"><span class="keyword">auto</span> func = [limit](<span class="keyword">auto</span> val)&#123;<span class="keyword">return</span> val &gt;= limit;&#125;</span><br><span class="line"><span class="built_in">count_occurences</span>(grades.<span class="built_in">begin</span>(),grades.<span class="built_in">end</span>(),func);</span><br><span class="line"><span class="comment">//the function mentioned above</span></span><br></pre></td></tr></table></figure>
<p>two different ways to pass reference or pass value</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [=,&amp;teas](parameters)&#123;</span><br><span class="line">    <span class="comment">//body</span></span><br><span class="line">&#125;<span class="comment">//pass every parameter by value except that teas is passed by reference</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = [&amp;,banned](parameters)&#123;</span><br><span class="line">    <span class="comment">//body</span></span><br><span class="line">&#125;<span class="comment">//pass every parameter by reference except banned</span></span><br></pre></td></tr></table></figure>
<h2 id="lecture-8-9"><a class="markdownIt-Anchor" href="#lecture-8-9"></a> Lecture 8-9</h2>
<h3 id="stdminmax_element"><a class="markdownIt-Anchor" href="#stdminmax_element"></a> std::minmax_element</h3>
<p>header: <code>#include&lt;algorithm&gt;</code></p>
<p><code>minmax_element(ForwardIt begin,ForwardIt end,Compare cmp)</code></p>
<p>take in two parameters(forward iterator) and a compare function(tells about comparison between undefined type parameters) , then return a pair of <code>&#123;min,max&#125;</code></p>
<p>example code 1: (default comparison)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line"><span class="keyword">auto</span> [min,max] = <span class="built_in">minmax_element</span>(numbers.<span class="built_in">begin</span>(),numbers.<span class="built_in">out</span>());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;the min number is&quot;</span> &lt;&lt; *min &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>example code 2: (undefined type)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> average;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line">vector&lt;Student&gt; students;</span><br><span class="line"><span class="keyword">auto</span> compare_student = [](Student&amp; s1,Student&amp; s2)&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.average &lt; s2.average;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> [minStudent,maxStudent] = <span class="built_in">minmax_element</span>(students.<span class="built_in">begin</span>(),</span><br><span class="line">    students.<span class="built_in">end</span>(), compare_student);</span><br></pre></td></tr></table></figure>
<h3 id="stdaccumulate"><a class="markdownIt-Anchor" href="#stdaccumulate"></a> std::accumulate</h3>
<p>header:<code>#include&lt;numeric&gt;</code></p>
<p>usage: <code>accumulate(InputIt begin,InputIt end, T init)</code></p>
<p>add everything between the iterator, return the value + init value(type T)</p>
<h3 id="stdnth_element"><a class="markdownIt-Anchor" href="#stdnth_element"></a> std::nth_element</h3>
<p>put every element smaller of the chosen one</p>
<h3 id="stdany_of"><a class="markdownIt-Anchor" href="#stdany_of"></a> std::any_of</h3>
<p><code>any_of(It begin,It end,Predicate predicate)</code></p>
<p>find if the collection has one element which satisfy the predicate sentence(return a boolean)</p>
<h3 id="stream-adaptor"><a class="markdownIt-Anchor" href="#stream-adaptor"></a> stream adaptor</h3>
<p><code>ostream_iterator&lt;T&gt;(cout,'\n')</code></p>
<p>creates an iterator of stream (adapter can automatically expand space)</p>
<h2 id="lecture-10"><a class="markdownIt-Anchor" href="#lecture-10"></a> Lecture 10</h2>
<h3 id="stdsearch"><a class="markdownIt-Anchor" href="#stdsearch"></a> std::search</h3>
<p><code>search(s.begin(),s.end(),elem.begin(),elem.end())</code></p>
<p>Find elem in s. return an iterator which tells the postion of first found, if not found return <code>s.end()</code></p>
<h3 id="dotproduct"><a class="markdownIt-Anchor" href="#dotproduct"></a> dotproduct</h3>
<p>计算两个向量的点乘(cos),使用vector做容器</p>
<p>【numeric库中还有accumulate】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dotProduct</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vec1,<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vec2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">inner_product</span>(vec1.<span class="built_in">begin</span>(),vec1.<span class="built_in">end</span>(),vec2.<span class="built_in">begin</span>()，<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inner_product 最后一个参数是点乘的原始值，一般设为0；不需要传入vec2.end()因为已经保证vec2向量维数（大小）和vec1是一样的。</p>
<p>【取向量的模(magnitude)的巧法】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span><span class="comment">//the header of sqrt</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mag</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(<span class="built_in">dotProduct</span>(vec,vec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="const"><a class="markdownIt-Anchor" href="#const"></a> const</h3>
<ul>
<li>
<p>const pointer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> p;<span class="comment">//a const pointer pointing to a non-const integer</span></span><br><span class="line"><span class="comment">//it&#x27;s ok to use (*p)++</span></span><br><span class="line"><span class="comment">//it&#x27;s not allowed to use p++</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p;<span class="comment">//a non-const pointer pointing to a const integer</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p;<span class="comment">//the same as above </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * <span class="type">const</span> p;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>const iterator</p>
<p>to make an iterator read only(can’t change the value the iterator points to), define a new <code>const_iterator</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt;::iterator iter = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//the same as const pointer</span></span><br><span class="line">++iter;<span class="comment">//not allowed</span></span><br><span class="line">*iter = <span class="number">15</span>;<span class="comment">//allowed</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator iter = v.<span class="built_in">begin</span>();</span><br><span class="line">*iter = <span class="number">5</span>;<span class="comment">//not allowed</span></span><br><span class="line">++iter;<span class="comment">//allowed</span></span><br><span class="line"><span class="type">int</span> i = *iter;<span class="comment">//allowed</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>const functions: function that can’t modify the parameters passed into it, can not call any non-const functions</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxVal</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a,<span class="type">const</span> <span class="type">int</span> b)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>const object: treat all public members as const, only allow to call</p>
</li>
</ul>
<h2 id="lecture-11"><a class="markdownIt-Anchor" href="#lecture-11"></a> Lecture 11</h2>
<h3 id="operator-defination"><a class="markdownIt-Anchor" href="#operator-defination"></a> operator defination</h3>
<p><img src="https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/_posts/assets/image-20221012172946-uq1d9bc.png?raw=true" alt="" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v&#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">cout.<span class="keyword">operator</span>&lt;&lt;(v.<span class="keyword">operator</span>[](<span class="number">0</span>));<span class="comment">//cout &lt;&lt; v[0];</span></span><br><span class="line">v.<span class="keyword">operator</span>[](<span class="number">1</span>).<span class="keyword">operator</span>+=(<span class="string">&quot;!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span>&lt;&lt;(cout,<span class="keyword">operator</span>[](v,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">operator</span>+=(<span class="keyword">operator</span>[](v,<span class="number">1</span>),<span class="string">&quot;!&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="operator-function"><a class="markdownIt-Anchor" href="#operator-function"></a> operator function</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt;&amp; vector&lt;string&gt;::<span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">int</span>&amp; element)&#123;</span><br><span class="line">    <span class="built_in">push_back</span>(element);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//this: a pointer to the class self</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt;&amp; vector&lt;string&gt;::<span class="keyword">operator</span>+=(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; other)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> val:other)&#123;</span><br><span class="line">        <span class="built_in">push_back</span>(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; vector&lt;string&gt;::<span class="keyword">operator</span>+(<span class="type">const</span> vector&lt;string&gt;&amp; other) <span class="type">const</span>&#123;</span><br><span class="line">    vector&lt;string&gt; res = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> std::string&amp; s:other)&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;<span class="comment">//make a copy and does not change the original one</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>operator as a member function</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; <span class="keyword">operator</span>+(<span class="type">const</span> vector&lt;string&gt;&amp; first,<span class="type">const</span> vector&lt;string&gt;&amp; second)&#123;</span><br><span class="line">    vector&lt;string&gt; result = first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> std::string&amp; s:second)&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>operator as non-member function</p>
<ul>
<li>
<p><code>[],(),-&gt;,=</code>必须是成员函数</p>
</li>
<li>
<p><code>&lt;&lt;,&gt;&gt;</code>必须是非成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> denum;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os,<span class="type">const</span> Fraction&amp; f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os,<span class="type">const</span> Fraction&amp; f)&#123;</span><br><span class="line">    os &lt;&lt; f.num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; f.denum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用ostream返回值使得cout等可以叠加使用操作符(cout &lt;&lt; a&lt;&lt;b;)</p>
<p>【在类中使用友元（friend）允许该友元访问类中的私有变量，友元可以是类或者函数】</p>
</li>
<li>
<p>unary operators(一元操作符：只有一个变量）like<code>++,--</code>必须是成员函数</p>
</li>
<li>
<p>如果操作符是binary operator或者表达式的左值右值都不改变，以非成员函数形式声明，可以是友元</p>
</li>
<li>
<p>如果是binary operator但是左值改变以成员函数形式声明（对私有变量访问方便）</p>
</li>
</ul>
<h2 id="lecture-12"><a class="markdownIt-Anchor" href="#lecture-12"></a> Lecture 12</h2>
<h3 id="初始化表"><a class="markdownIt-Anchor" href="#初始化表"></a> 初始化表</h3>
<p>see c++ in nju</p>
<h3 id="copy-constructor"><a class="markdownIt-Anchor" href="#copy-constructor"></a> copy constructor</h3>
<p>create a new object from existing value(l-value)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringVector::<span class="built_in">StringVector</span>(<span class="type">const</span> StringVector&amp; other)<span class="keyword">noexcept</span>:</span><br><span class="line">    <span class="built_in">logicalSize</span>(other.logicalSize),<span class="built_in">allocatedSize</span>(other.allocatedSize)&#123;</span><br><span class="line">        elems = <span class="keyword">new</span> std::string[allocatedSize];</span><br><span class="line">        std::<span class="built_in">copy</span>(other.<span class="built_in">begin</span>(),other.<span class="built_in">end</span>(),<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="copy-assignment"><a class="markdownIt-Anchor" href="#copy-assignment"></a> copy assignment</h3>
<p>与copy constructor不同，本质上是=的重载</p>
<p>overwrite existing object with existing value(l-value)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StringVector&amp; StringVector::<span class="keyword">operator</span>=(<span class="type">const</span> StringVector&amp; other)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;other)&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] elems;</span><br><span class="line">        allocatedSize = other.allocatedSize;</span><br><span class="line">        logicalSize = other.logicalSize;</span><br><span class="line">        elems = <span class="keyword">new</span> std::string[allocatedSize];</span><br><span class="line">        std::<span class="built_in">copy</span>(other.<span class="built_in">begin</span>(),other.<span class="built_in">end</span>(),<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>use <code>StringVector&amp;</code>as return type: v1 = (v2 = v3) 重叠式赋值</p>
<p>【如果显式定义了copy constructor,copy assignment,destructor其中一个，必须同时定义其他两个】</p>
<h2 id="lecture-13"><a class="markdownIt-Anchor" href="#lecture-13"></a> Lecture 13</h2>
<h3 id="emplace_back"><a class="markdownIt-Anchor" href="#emplace_back"></a> emplace_back</h3>
<p>在vector里面的成员函数，往vector里面push一个元素（no copy）：在emplace_back的参数中直接构造一个</p>
<h3 id="lvalue-rvalue"><a class="markdownIt-Anchor" href="#lvalue-rvalue"></a> lvalue &amp; rvalue</h3>
<p>lvalue: an expression that has a name(can find address using <code>&amp;</code> address of operator)</p>
<p>rvalue: doesn’t have a name, temporary values(can’t find address)</p>
<p>左值可以出现在左右两边，但是右值只能出现在右边（=）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; v4 = v1+v2;<span class="comment">//v4 is an r-value reference</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; ptr3 = ptr+<span class="number">5</span>;<span class="comment">//can bind a const l-value reference to rvalue</span></span><br></pre></td></tr></table></figure>
<p>左值可以被copy，但是不可以move;右值都可以</p>
<h3 id="move"><a class="markdownIt-Anchor" href="#move"></a> move</h3>
<p>move constructor: create new object from existing <strong>r-value</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StrVector::<span class="built_in">StrVector</span>(StrVector&amp;&amp; other):<span class="built_in">elems</span>(std::<span class="built_in">move</span>(other.elems))&#123;<span class="comment">//why using move see below</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello from move constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    other.elems = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>move assignment</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StrVector&amp; <span class="keyword">operator</span>=(StrVector&amp;&amp; rhs)&#123;<span class="comment">//rhs itself is a lvalue,but bind to a r-value</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] elems;</span><br><span class="line">        allocatedSize = rhs.allocatedSize;<span class="comment">//this is a copy</span></span><br><span class="line">        elems = rhs.elems;</span><br><span class="line">        rhs.elems = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>change: <code>allocatedSize = std::move(rhs.allocatedSize);</code> move unconditionally cast the parameter into an r-value</p>
<h2 id="lecture-14"><a class="markdownIt-Anchor" href="#lecture-14"></a> Lecture 14</h2>
<h3 id="scope-resolution"><a class="markdownIt-Anchor" href="#scope-resolution"></a> scope resolution</h3>
<p>范围解析，example: <code>std::</code></p>
<h3 id="namespace"><a class="markdownIt-Anchor" href="#namespace"></a> namespace</h3>
<p>解决命名冲突问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Lecture&#123;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(iterator begin,iterator end, T elem)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; Lecture::<span class="built_in">count</span>(...) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在namespace中命名类</p>
<h3 id="interface"><a class="markdownIt-Anchor" href="#interface"></a> interface</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Drink</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> <span class="keyword">implements</span> <span class="title class_">Drink</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于java中的interface，c++中的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Drink</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">make</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//pure virtual function</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">make</span><span class="params">()</span></span>;<span class="comment">//non-pure virtual</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span>: <span class="keyword">public</span> Drink&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">make</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>make() = 0</code>：任何implements Drink的类必须实现make函数，否则不能编译通过(pure virtual)</p>
<p>c++中没有<code>interface</code>关键字，如果想要使一个类成为interface只要使该类中成员函数都是pure virtual即可（interface不能有实例对象）</p>
<h3 id="abstract-class"><a class="markdownIt-Anchor" href="#abstract-class"></a> abstract class</h3>
<p>若某一个class至少包含一个pure virtual函数则这个类被成为抽象类（interface是抽象类的子集）</p>
<p><strong>抽象类不能被实例化（instantiated）</strong></p>
<h3 id="inheritance"><a class="markdownIt-Anchor" href="#inheritance"></a> inheritance</h3>
<p>继承类如果和被继承的类有重名变量or函数，在继承类中会被隐藏（hide）</p>
<p>发生隐藏时，如果是调用父类则使用父类变量/函数，调子类则使用子类</p>
<h2 id="lecture-15"><a class="markdownIt-Anchor" href="#lecture-15"></a> Lecture 15</h2>
<h3 id="constructor"><a class="markdownIt-Anchor" href="#constructor"></a> constructor</h3>
<p>继承父类的子类必须要调用父类的constructor</p>
<h3 id="destructor"><a class="markdownIt-Anchor" href="#destructor"></a> destructor</h3>
<p>如果这个class是可以被继承的，该类的destructor必须是virtual,否则会发生内存泄漏</p>
<h3 id="protected"><a class="markdownIt-Anchor" href="#protected"></a> protected</h3>
<p>类似于private，但是private中的成员只能在这个class里被访问，protected成员可以在该类和继承这个类的子类里面被访问</p>
<h3 id="inheritance实例"><a class="markdownIt-Anchor" href="#inheritance实例"></a> inheritance实例</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drink</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Drink</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Drink</span>(std::string flavor): _flavor(flavor)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">make</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** virtual void make()&#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;make drink from drink class&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Drink</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string _flavor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span>: <span class="keyword">public</span> Drink&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tea</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Tea</span>(std::string flavor):<span class="built_in">Drink</span>(flavor)&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Tea</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">make</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;make tea from tea class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Tea <span class="title">t</span><span class="params">(<span class="string">&quot;red&quot;</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">make</span>();<span class="comment">//print from tea&#x27;s make</span></span><br><span class="line">    t.Drink::<span class="built_in">make</span>();<span class="comment">//print from drink&#x27;s make</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="templates-2"><a class="markdownIt-Anchor" href="#templates-2"></a> templates</h3>
<p>templates are implicit interfaces</p>
<p>【static/dynamic polymorphism: templates是静多态，inheritance是动态多态。静态和动态的区别在于静态的在编译之前就直到要调用哪一个，而动态的只有编译完之后才知道调用的对象】</p>
<p>class can be templates</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Container</span> = std::vector&lt;T&gt;&gt;<span class="comment">//by default,the container is a vector which includes the class T</span></span><br><span class="line"><span class="keyword">class</span> Priority_Q&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="lecture-16"><a class="markdownIt-Anchor" href="#lecture-16"></a> Lecture 16</h2>
<h3 id="smart-pointers"><a class="markdownIt-Anchor" href="#smart-pointers"></a> smart pointers</h3>
<ul>
<li>
<p><code>std::unique_ptr</code>：uniquely owns its source and delete it when the object is deleted( can’t be copied)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node* n = <span class="keyword">new</span> Node;</span><br><span class="line"><span class="comment">//equals to</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Node&gt; <span class="title">n</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>std::shared_ptr</code>：resources can be stored in any number of pointers,delete when none of them point to an object</p>
<p>实现方法使用一个count变量</p>
</li>
<li>
<p><code>std::weak_ptr</code>：weak_ptr的对象count不计入weak_ptr</p>
</li>
</ul>
</div></article><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/02/26/knowledge/computer%20network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(22Fall)/"><i class="fa fa-chevron-left">  </i><span>计算机网络(22Fall)</span></a></div><div class="next-post pull-right"><a href="/2022/09/26/knowledge/algorithm/UCB%20CS61B(2021)/"><span>UCB CS61B(2021)</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://github.com/AliceRayLu/AliceRayLu.github.io/blob/main/source/pics/back1.jpg?raw=true)"><div class="layout" id="footer"><div class="copyright">&copy;2023 - 2025 By A.R.L</div><div class="footer_custom_text">本站图片资源托管于Github, 网速限制可能无法正确加载</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>